% Generated by Discussion model rails.24224.txt
% File generated on 2017/08/02 15:59:30

@relation pr1501703970252

@attribute author String
@attribute textual String
@attribute isProjectMember {TRUE, FALSE}
@attribute isInvited {TRUE, FALSE}
@attribute numberOfWords numeric
@attribute commentsSoFar numeric
@attribute allUtterancesSoFar numeric
@attribute utterancesInCommentSoFar numeric
@attribute utteredByOriginalPoster {TRUE, FALSE}
@attribute hasCapitalizedWord {TRUE, FALSE}
@attribute containsShould {TRUE, FALSE}
@attribute hasDecisions {TRUE, FALSE}
@attribute howManyDecisions numeric
@attribute idComment numeric

@data
danielrhodes,"A first stab at negotiating an acceptable protocol as was mentioned in #23976 @maclover7 @jeremy @javan",FALSE,FALSE,16,0,0,0,TRUE,FALSE,FALSE,TRUE,0,1
danielrhodes,"Going forward, if the ActionCable protocol changes, there ought to be some way for the client/server to negotiate this change and gracefully stop communicating if no common protocol can be established.",FALSE,FALSE,31,0,2,2,TRUE,TRUE,FALSE,TRUE,0,1
danielrhodes,"Using the Sec-Websocket-Protocol from the WebSocket spec, the client and server negotiate a protocol from a list. Most of the work is being done by the WebSocket driver and the web browser WebSocket client, so all this really does is make sure the client does not get into a bad state if the server has been upgraded and the client has not.",FALSE,FALSE,62,0,3,3,TRUE,TRUE,FALSE,TRUE,0,1
danielrhodes,"The browser websocket client automatically chooses to disconnect if the server does not respond with an acceptable protocol (this is not configurable), so instead of trying to reconnect (as this would not be useful), the client shuts down the monitor.",FALSE,FALSE,40,0,4,4,TRUE,TRUE,FALSE,TRUE,0,1
rails-bot,"Thanks for the pull request, and welcome! The Rails team is excited to review your changes, and you should hear from @arthurnn (or someone else) soon.",FALSE,FALSE,26,1,5,0,FALSE,TRUE,TRUE,TRUE,0,2
rails-bot,"If any changes to this PR are deemed necessary, please add them as extra commits. This ensures that the reviewer can see what has changed since they last reviewed the code. Due to the way GitHub handles out-of-date commits, this should also make it reasonably obvious what issues have or haven't been addressed. Large or tricky changes may require several passes of review and changes.",FALSE,FALSE,65,1,6,1,FALSE,TRUE,TRUE,TRUE,0,2
rails-bot,"Please see the contribution instructions for more information.",FALSE,FALSE,8,1,7,2,FALSE,TRUE,FALSE,TRUE,0,2
javan,"What browsers have you tested this in? I'm curious if protocols and onclose event codes are broadly supported. Unclear from documentation I've found online: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket#Browser_compatibility and https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Browser_compatibility",FALSE,TRUE,27,2,9,1,FALSE,TRUE,FALSE,TRUE,0,3
javan,"return is implicit in CoffeeScript, you can cut it.",FALSE,TRUE,9,3,10,0,FALSE,TRUE,FALSE,TRUE,0,4
javan,"More CoffeeScripty:",FALSE,TRUE,2,4,11,0,FALSE,TRUE,FALSE,TRUE,0,5
javan,"Also, why an additional log for 1006 only? Might as well log event.code, event.reason, and event.wasClean with every close.",FALSE,TRUE,19,5,13,1,FALSE,TRUE,FALSE,TRUE,0,6
javan,"In CoffeeScript you can do unless event.wasClean (or if not event.wasClean).",FALSE,TRUE,11,6,14,0,FALSE,TRUE,FALSE,TRUE,0,7
jeremy,"Cool! TIL that Sec-Websocket-Protocol is for subprotocol negotiation.",FALSE,TRUE,8,7,15,0,FALSE,TRUE,FALSE,TRUE,0,8
jeremy,"Can we bubble this up to the app in some way so it can react in the UI, e.g. show a prompt to reload the page or auto-reload it?",FALSE,TRUE,29,8,17,1,FALSE,TRUE,FALSE,TRUE,0,9
danielrhodes,"Yeah we need a way of telling the app why there was a hard disconnect. To be discussed, as there are other cases where we need this as well (e.g. authentication failure).",FALSE,FALSE,32,9,19,1,TRUE,TRUE,FALSE,TRUE,0,10
danielrhodes,"@javan Ok I tested it on Chrome, Safari, Firefox, and Mobile Safari. I don't have IE, but it does have the CloseEvent. Mobile Safari was the only one which behaved differently from the others (it did not automatically disconnect when the negotiation failed). Therefore, I changed the code to check the protocol negotiated to see if it is in the list the client knows it can accept and if not, to disconnect. I likewise took out that close event code stuff and checked the protocols as a way to decide if the monitor should be stopped. I think that should resolve your comments.",FALSE,FALSE,103,10,21,1,TRUE,TRUE,TRUE,TRUE,0,11
jeremy,"How about e.g. actioncable-v17-json? Tack on the transport encoding (which is always JSON now) and use a big chunky version that looks nothing like the AC version number since the only purpose is to break major compat (there are no  minor  changes).",FALSE,TRUE,42,11,23,1,FALSE,TRUE,FALSE,TRUE,0,12
jeremy,"Then the server can negotiate by parsing out the requested version and transfer encoding and picking the matching protocol handler for the conn.",FALSE,TRUE,23,11,24,2,FALSE,TRUE,FALSE,TRUE,0,12
matthewd,"Do we only want to version the ACa transport version, or also provide for an application-level value? I'm thinking of something equivalent to config.assets.version...",FALSE,FALSE,24,12,26,1,FALSE,TRUE,FALSE,TRUE,0,13
danielrhodes,"@jeremy This is a good idea.",FALSE,FALSE,6,13,27,0,TRUE,TRUE,FALSE,TRUE,0,14
danielrhodes,"@matthewd This kind of gets to a bigger question of how much backwards-compatibility we build into this.",FALSE,FALSE,17,14,28,0,TRUE,TRUE,FALSE,TRUE,0,15
danielrhodes,"If somebody wants to make their ActionCable server a publicly available resource, then backwards compatibility becomes important. Likewise, I made a Swift client for ActionCable and a changing protocol version becomes a real pain for the developer because the longer upgrade cycle becomes a chicken-and-egg problem.",FALSE,FALSE,46,14,30,2,TRUE,TRUE,FALSE,TRUE,0,15
danielrhodes,"On the other hand, if this is really only used so a person can communicate with their own backend in the browser, there doesn't need to be a lot of backwards compatibility built-in. Only enough so that the client can gracefully degrade until the next reload.",FALSE,FALSE,46,14,32,4,TRUE,TRUE,FALSE,TRUE,0,15
danielrhodes,"In either case, there is no benefit for the developer in being able to pin a version because if the server is able to support a version, it should because it's an internal protocol.",FALSE,FALSE,34,14,34,6,TRUE,TRUE,TRUE,TRUE,0,15
danielrhodes,"I'm interested to see what feedback we get about this.",FALSE,FALSE,10,14,35,7,TRUE,TRUE,FALSE,TRUE,0,15
jeremy,"App-level protocol versioning is interesting. It could be helpful, at minimum, to provide a big hammer so apps can wiggle out of a stale-client compatibility mess by bumping the protocol.",FALSE,TRUE,30,15,37,1,FALSE,TRUE,FALSE,TRUE,0,16
jeremy,"For other cases, like changing channel behavior, I'd lean to leaving it up to apps to make changes in a compatible way. But, heck, leaning on bumping the app proto version could be simpler in many of these cases too.",FALSE,TRUE,40,15,39,3,FALSE,TRUE,FALSE,TRUE,0,16
jeremy,"Good one to pass as a keyword arg, no need to keep @options around",FALSE,TRUE,14,16,40,0,FALSE,FALSE,FALSE,TRUE,0,17
jeremy,"Or glob the keyword args as websocket options:",FALSE,TRUE,8,18,41,0,FALSE,FALSE,FALSE,TRUE,0,19
danielrhodes,"Would be happy to do this as it is cleaner. I haven't seen much use of the Ruby keyword arguments in the Rails codebase, but I guess it's ok now?",FALSE,FALSE,30,19,42,0,TRUE,TRUE,FALSE,TRUE,0,20
danielrhodes,"UPDATE: Seems Ruby 2+ is now required for Rails 5, so I'll do the keyword args.",FALSE,FALSE,16,19,43,1,TRUE,TRUE,FALSE,TRUE,0,20
danielrhodes,"In the comments @jeremy pointed out that it would be helpful if there was some way the client could communicate to the app a reason for the disconnect. There isn't currently a global way of doing this, so any opinions on this? We can pass some sort of reason object through to the disconnect method like WebSocket does.",FALSE,FALSE,58,21,45,1,TRUE,TRUE,FALSE,TRUE,0,22
jeremy,"Do we need the || nil? Would only kick in if protocols was oddly false",FALSE,TRUE,15,23,47,0,FALSE,TRUE,FALSE,TRUE,0,24
javan,"This will prevent the connection monitor from infinitely attempting to reconnect (as noted in #23976 (comment)), but leaves you disconnected until you reload your browser. Think we should notify subscriptions of this state so they can manage / instruct reloading.",FALSE,TRUE,40,25,50,1,FALSE,TRUE,TRUE,TRUE,0,26
danielrhodes,"Yes, @jeremy wants something along these lines. I guess just a simple object with code and a reason passed into the disconnect method?",FALSE,FALSE,23,26,52,1,TRUE,TRUE,FALSE,TRUE,0,27
javan,"Yeah, I think that'd work fine. Would be cool to hot-reload the client-side js, but that's probably more trouble than it's worth for what will be an infrequent event.",FALSE,TRUE,29,27,53,0,FALSE,TRUE,FALSE,TRUE,0,28
danielrhodes,"I guess if you could plug into Sprockets somehow, you could pull a new version of the classes (perhaps namespaced differently for each asset build) and then hot swap in the ActionCable classes and reconnect. It would be super cool, but yes a lot of trouble.",FALSE,FALSE,46,28,55,1,TRUE,TRUE,FALSE,TRUE,0,29
danielrhodes,"As a side note: Facebook was doing something similar on Android for awhile, before Google made them stop by modifying the TOS for the Google Play Store.",FALSE,FALSE,27,28,56,2,TRUE,TRUE,FALSE,TRUE,0,29
javan,"How about adding :protocols to INTERNAL instead? It's a general purpose data bag.",FALSE,TRUE,13,29,58,1,FALSE,TRUE,FALSE,TRUE,0,30
javan,"I'd extract this to a new method since it's duplicated",FALSE,TRUE,10,30,59,0,FALSE,FALSE,FALSE,TRUE,0,31
maclover7,"Do we want this to have the same version number as the gem? Would prevent having two different version numbers for Action Cable...",FALSE,TRUE,23,31,61,1,FALSE,TRUE,FALSE,TRUE,0,32
jeremy,"The protocol version is distinct from the library version and will be stable over longer periods. Using separate versions is intentional.",FALSE,TRUE,21,32,63,1,FALSE,TRUE,FALSE,TRUE,0,33
jeremy,"Missed this line? options gone now",FALSE,TRUE,6,33,64,0,FALSE,FALSE,FALSE,TRUE,0,34
danielrhodes,"Oops  :-)",FALSE,FALSE,3,34,65,0,TRUE,FALSE,FALSE,TRUE,0,35
javan,"For debugging, it would be useful to log the client and server protocol versions rather than say they're not common.",FALSE,TRUE,20,35,67,1,FALSE,TRUE,FALSE,TRUE,0,36
danielrhodes,"The server does not tell the client which subprotocols it supports. It simply chooses one or none, and then responds with that protocol in the header.",FALSE,FALSE,26,36,69,1,TRUE,TRUE,FALSE,TRUE,0,37
javan,"I mean add @webSocket.protocol and ActionCable.PROTOCOLS to the log message",FALSE,TRUE,10,37,70,0,FALSE,TRUE,FALSE,TRUE,0,38
danielrhodes,"@javan I removed @disconnect() from the error handler for the websocket. From what I understand, this always gets fired with close anyways, but it creates a race condition and doesn't provide any information.",FALSE,FALSE,33,38,72,1,TRUE,TRUE,FALSE,TRUE,0,39
javan,"Subscriptions don't receive Event objects anywhere else so I think passing a plain object would do. Perhaps:",FALSE,TRUE,17,39,73,0,FALSE,TRUE,FALSE,TRUE,0,40
javan,"I think willReconnect better indicates wether action is needed.",FALSE,TRUE,9,39,74,1,FALSE,TRUE,FALSE,TRUE,0,40
javan,"Think this should move to the close handler so it's more closely tied to the related condition.",FALSE,TRUE,17,41,77,1,FALSE,TRUE,TRUE,TRUE,0,42
javan,"Can use the protocol method instead of repeating @webSocket?.protocol",FALSE,TRUE,9,42,78,0,FALSE,FALSE,FALSE,TRUE,0,43
javan,"Arrays are implicitly joined with , when coerced to a String. Can do .log( Opening WebSocket, current state is #{@getState()}, subprotocols: #{protocols} )",FALSE,TRUE,21,43,79,0,FALSE,TRUE,FALSE,TRUE,0,44
javan,"I'd move this logging to the initial open entry. And prefer CoffeeScript's string interpolation:  using #{@protocol()} subprotocol ",FALSE,TRUE,17,44,80,0,FALSE,TRUE,FALSE,TRUE,0,45
danielrhodes,"There is a log in the initial open which shows the available protocols. The log above is showing the actual protocol chosen by the server.",FALSE,FALSE,25,45,82,1,TRUE,TRUE,FALSE,TRUE,0,46
javan,"I'm suggesting combining them. No need for two log entries.",FALSE,TRUE,10,46,83,0,FALSE,TRUE,FALSE,TRUE,0,47
javan,"getProtocol would better match the other accessor methods like getState.",FALSE,TRUE,10,47,84,0,FALSE,FALSE,FALSE,TRUE,0,48
javan,"ditto re: matching method naming convention: isSupportedProtocol",FALSE,TRUE,7,48,85,0,FALSE,FALSE,FALSE,TRUE,0,49
javan,"Might as well flip the conditions to avoid if noting.",FALSE,TRUE,10,49,86,0,FALSE,FALSE,FALSE,TRUE,0,50
javan,"ditto re: flipping condition",FALSE,TRUE,4,50,87,0,FALSE,FALSE,FALSE,TRUE,0,51
javan,"I removed @disconnect() from the error handler for the websocket. From what I understand, this always gets fired with close anyways, but it creates a race condition and doesn't provide any information.",FALSE,TRUE,32,51,89,1,FALSE,TRUE,FALSE,TRUE,0,52
javan,"This assumes every error results in a close, yeah? If you can verify then ðŸ‘?, but otherwise it makes me a little uncomfortable.",FALSE,TRUE,23,51,91,3,FALSE,TRUE,FALSE,TRUE,0,52
danielrhodes,"If the user agent was required to fail the WebSocket connection or the WebSocket connection is closed with prejudice, fire a simple event named error at the WebSocket object.",FALSE,FALSE,29,52,93,1,TRUE,TRUE,FALSE,TRUE,0,53
danielrhodes,"Firefox and Safari do not consistently fire this error event, but they all seem to fire the close event consistently.",FALSE,FALSE,20,52,95,3,TRUE,TRUE,FALSE,TRUE,0,53
maclover7,"Isn't there only supposed to be one protocol here? Not sure why we need an array ðŸ˜¬",FALSE,TRUE,17,53,97,1,FALSE,TRUE,FALSE,TRUE,0,54
danielrhodes,"The websocket on both ends takes an array and for potential backwards compatibility reasons, it may be necessary in the future for the server to be able to respond to multiple versions (cross your fingers this doesn't come true!).",FALSE,FALSE,39,54,99,1,TRUE,TRUE,FALSE,TRUE,0,55
maclover7,"I think we can drop the default here for protocols -- the option to pass in a different array is already presented to users in Connection::WebSocket#initialize",FALSE,TRUE,26,55,100,0,FALSE,TRUE,FALSE,TRUE,0,56
maclover7,"ditto -- I think we can drop the default here for protocols -- the option to pass in a different array is already presented to users in Connection::WebSocket#initialize",FALSE,TRUE,28,56,101,0,FALSE,TRUE,FALSE,TRUE,0,57
danielrhodes,"Just had a bunch of fun trying to figure out an issue where, when the browser attempts to reconnect on a failed connection, it can sometimes look the same as if there was a protocol mismatch. To my horror this was also specified as the correct implementation of websockets. That would leave us with no ability to stop retrying/tell the app that the connection was not going to work.",FALSE,FALSE,69,57,102,0,TRUE,TRUE,FALSE,TRUE,0,58
danielrhodes,"Luckily this only seems to happen in Chrome. My solution, which is a tad bit hacky, is to test the connection using a temporary websocket connection but without protocols, and if that goes through, we know the protocols we tried before were incorrect. If it fails, no need to do anything. Tested on Chrome, Safari, Mobile Safari, and Firefox.",FALSE,FALSE,59,57,103,1,TRUE,TRUE,FALSE,TRUE,0,58
danielrhodes,"Does somebody have the ability to test on IE?",FALSE,FALSE,9,57,104,2,TRUE,TRUE,FALSE,TRUE,0,58
maclover7,"Bunch of empty lines here...?",FALSE,TRUE,5,58,105,0,FALSE,FALSE,FALSE,TRUE,0,59
maclover7,"Do we need these commented out lines?",FALSE,TRUE,7,59,106,0,FALSE,FALSE,FALSE,TRUE,0,60
maclover7,"ditto - Do we need these commented out lines?",FALSE,TRUE,9,60,107,0,FALSE,TRUE,FALSE,TRUE,0,61
javan,"Prefer CoffeeScript's operators: if event.code is 1000 and event.wasClean and @getProtocol() is   ",FALSE,TRUE,13,61,108,0,FALSE,TRUE,FALSE,TRUE,0,62
javan,"ditto re: operators",FALSE,TRUE,3,62,109,0,FALSE,FALSE,FALSE,TRUE,0,63
javan,">>>Thread end<",FALSE,TRUE,2,62,110,1,FALSE,FALSE,FALSE,TRUE,0,63
javan,"You can use a fat arrow function, which binds to this:",FALSE,TRUE,11,63,111,0,FALSE,FALSE,FALSE,TRUE,0,64
danielrhodes,"Will give this a try. Thanks for the tips! My CoffeeScript skillz are nascent.",FALSE,FALSE,14,64,112,0,TRUE,TRUE,FALSE,TRUE,0,65
javan,"Hmm, I don't think opening a new connection here is a good idea. Imagine a scenario when you're performing a server restart and suddenly every user attempts to reconnect. A flood of traffic like that can be crippling. I'm not totally clear on the circumstances that lead to this condition though so maybe you can elaborate.",FALSE,TRUE,56,65,114,1,FALSE,TRUE,FALSE,TRUE,0,66
danielrhodes,"So this is all so we can give the app a message saying it was disconnected for good and why.",FALSE,FALSE,20,66,116,1,TRUE,TRUE,FALSE,TRUE,0,67
danielrhodes,"I'm not a big fan of doing this either, but there isn't a good alternative for Chrome. The reason for all this is that Chrome does not distinguish between a bad disconnect and a protocol mismatch. In either case, it disconnects. For some reason the standard for websockets in browsers wants to disincentivize  probing  a websocket for capabilities (as if you would do this from a web browser!).",FALSE,FALSE,68,66,118,3,TRUE,TRUE,FALSE,TRUE,0,67
danielrhodes,"Thus, the only way to reliably tell if Chrome disconnected because of your normal bad connection is to create a new connection without protocols to see if Chrome stays connected.",FALSE,FALSE,30,66,120,5,TRUE,TRUE,FALSE,TRUE,0,67
danielrhodes,"This should only occur in two circumstances:",FALSE,FALSE,7,66,121,6,TRUE,TRUE,TRUE,TRUE,0,67
danielrhodes,"A previous connection attempt on Chrome was unsuccessful at connecting, at which point the server is down anyways.",FALSE,FALSE,18,66,122,7,TRUE,TRUE,FALSE,TRUE,0,67
danielrhodes,"There was a protocol mismatch when the server was up, at which point Chrome is going to disconnect, reconnect again without protocols, see that was the reason, and then disconnect permanently.",FALSE,FALSE,31,66,123,8,TRUE,TRUE,FALSE,TRUE,0,67
danielrhodes,"The alternative to this is just not upgrading the connection when the server sees that the client wants protocols it doesn't have. I don't think we could get an error code off that.",FALSE,FALSE,33,66,125,10,TRUE,TRUE,FALSE,TRUE,0,67
danielrhodes,"Otherwise, it's on the same retry interval as normal.",FALSE,FALSE,9,66,126,11,TRUE,TRUE,FALSE,TRUE,0,67
danielrhodes,"By the way, that thundering herd issue is still going to be a problem with the current retry handler. Given that all clients disconnect at the same time from a restarting server, they will all be on similar intervals when retrying. Could solve this by adding some jitter.",FALSE,FALSE,48,67,128,1,TRUE,TRUE,FALSE,TRUE,0,68
javan,"That would only be true if every client connected at the exact same time, which will never be the case. ConnectionMonitor's timer naturally distributes the herd based on the randomness of when each client openeda connection.",FALSE,TRUE,36,68,130,1,FALSE,TRUE,FALSE,TRUE,0,69
javan,"Thus, the only way to reliably tell if Chrome disconnected because of your normal bad connection is to create a new connection without protocols to see if Chrome stays connected.",FALSE,TRUE,30,69,132,1,FALSE,TRUE,FALSE,TRUE,0,70
javan,"If we can't reliably read the close event details, perhaps we should instead send a special rejection message that instructs the client to disconnect.",FALSE,TRUE,24,69,134,3,FALSE,TRUE,TRUE,TRUE,0,70
danielrhodes,"Well we can't send a Sec-Websocket-Protocol and then not receive one back from the server: the browser websocket clients just force disconnect. So that would mean moving the negotiation to outside of the websocket layer, which involves changing the protocol, and itself becomes subject to change. :-)",FALSE,FALSE,47,70,136,1,TRUE,TRUE,FALSE,TRUE,0,71
danielrhodes,"Closing the connection is no problem: the browser is forcefully doing that for us. This whole thing is quite effective in preventing the client side from getting into a bad state, which is the primary concern.",FALSE,FALSE,36,70,138,3,TRUE,TRUE,FALSE,TRUE,0,71
danielrhodes,"But the issue that remains is we can't tell the app why there has been this specific disconnect in Chrome, unless we use this reconnect thing. For me, that's not ideal but it's not a deal breaker.",FALSE,FALSE,37,70,140,5,TRUE,TRUE,FALSE,TRUE,0,71
danielrhodes,"I see a few options:",FALSE,FALSE,5,70,141,6,TRUE,TRUE,FALSE,TRUE,0,71
danielrhodes,"Keep the double reconnection thing. It's going to result in Chrome doing two very short-lived connections, but only if the protocol changes. However, the connection attempts will stop after that.Pros: We get consistent behavior across all browsers; from a load perspective it will in aggregate be less (no retries).",FALSE,FALSE,49,70,144,9,TRUE,TRUE,FALSE,TRUE,0,71
danielrhodes,"Cons: Only when there is a protocol change, there will be two back to back connection attempts by Chrome users; Unclear what load profile this would create. Solution is non standard.2. Let Chrome continue to retry as it normally would.Pros: No back to back connection attempt for Chrome.",FALSE,FALSE,48,70,148,13,TRUE,TRUE,FALSE,TRUE,0,71
danielrhodes,"Cons: Inconsistent behavior across browsers, and Chrome users won't be able to get a user-friendly message to refresh. Chrome will continue to retry fruitlessly.3. Don't attempt to understand reason for disconnection and continue retrying, but the app won't know why it disconnected.Pros: Consistent across all browsers.",FALSE,FALSE,46,70,152,17,TRUE,TRUE,FALSE,TRUE,0,71
danielrhodes,"Cons: No nice message to users. All browsers are going to continue to retry fruitlessly.4. Move protocol negotiation out of websocket layer.",FALSE,FALSE,22,70,155,20,TRUE,TRUE,FALSE,TRUE,0,71
danielrhodes,"Pros: We can get consistent behavior across browsers.",FALSE,FALSE,8,70,157,22,TRUE,TRUE,FALSE,TRUE,0,71
danielrhodes,"Cons: Re-inventing the wheel; solution is not resistant against future protocol changes; binds ActionCable to a content encoding.",FALSE,FALSE,18,70,159,24,TRUE,TRUE,FALSE,TRUE,0,71
danielrhodes,"Personally I think 1 or 3 are the best.",FALSE,FALSE,9,70,160,25,TRUE,TRUE,FALSE,TRUE,0,71
danielrhodes,"@jeremy Any opinions on this?",FALSE,FALSE,5,70,161,26,TRUE,TRUE,FALSE,TRUE,0,71
jeremy,"#1 is a cool idea, but it also relies on the server not returning a Sec-Websocket-Protocol choice when Sec-Websocket-Accept is omitted.",FALSE,TRUE,21,71,163,1,FALSE,TRUE,FALSE,TRUE,0,72
jeremy,"#2 is the odd one of the bunch.",FALSE,TRUE,8,71,164,2,FALSE,FALSE,FALSE,TRUE,0,72
jeremy,"#3 is nice because it's taking a small, simple step and the cost of fruitless retries is fairly low.",FALSE,TRUE,19,71,166,4,FALSE,FALSE,FALSE,TRUE,0,72
jeremy,"Re. #4â€¦ wonder if the client requested",FALSE,TRUE,7,71,167,5,FALSE,TRUE,FALSE,TRUE,0,72
jeremy,"Then we can guarantee we'll always have a handshake. From there, the actioncable-unsupported protocol's only job is to reject the connection as unsupported.",FALSE,TRUE,23,71,169,7,FALSE,TRUE,FALSE,TRUE,0,72
jeremy,"In any case, seems #3 is best for this PR! Plenty of room to improve in subsequent work ðŸ˜?",FALSE,TRUE,19,71,170,8,FALSE,TRUE,FALSE,TRUE,0,72
danielrhodes,"For 1. This is part of the WebSocket spec. If the server doesn't support any protocols, it needs to not return that header or return the header with a null value. In our case, there is no visibility into this process as the WebSocket driver does this for us.",FALSE,FALSE,49,72,172,1,TRUE,TRUE,FALSE,TRUE,0,73
danielrhodes,"Re 4: This is a fantastic idea! I'm going to give this a try. I think this would do the trick.",FALSE,FALSE,21,72,173,2,TRUE,TRUE,FALSE,TRUE,0,73
javan,"I'm -1 on using a custom Event object to communicate the disconnect info and would prefer a plain object instead.",FALSE,TRUE,20,73,174,0,FALSE,TRUE,FALSE,TRUE,0,74
danielrhodes,"Ok I removed the reconnection stuff and replaced it with actioncable-unsupported, which works across all browsers and gives us the visibility we need to disconnect if there's a protocol mismatch and tell the app. Also more elegant. I'm very happy with that solution. ðŸŽ©  tip to @jeremy",FALSE,FALSE,48,74,175,0,TRUE,TRUE,FALSE,TRUE,0,75
maclover7,"This is coming along very nicely -- can you start to squash down some of your commits?",FALSE,TRUE,17,75,176,0,FALSE,FALSE,FALSE,TRUE,0,76
danielrhodes,"@maclover7 Yep I plan on doing that before anything is merged!",FALSE,FALSE,11,76,177,0,TRUE,TRUE,FALSE,TRUE,0,77
javan,"WebSockets are an implementation detail of Action Cable so it smells wrong to dispatch WebSocket-based data here. The only useful data for the client is wether or not AC is going to reconnect automatically or stop.",FALSE,TRUE,36,77,179,1,FALSE,TRUE,FALSE,TRUE,0,78
danielrhodes,"Ok yeah I see what you mean: if ActionCable were to support say SSEs or HTTP/2 in the future, reducing the surface area of WebSocket dependencies would be a good thing. :-)",FALSE,FALSE,32,78,180,0,TRUE,TRUE,FALSE,TRUE,0,79
danielrhodes,"In that case, we should just return an object with a willAttemptReconnect property set to true/false.",FALSE,FALSE,16,78,181,1,TRUE,TRUE,TRUE,TRUE,0,79
javan,"Would be nice to add a Connection#stop method that closes any existing connection and stops the monitor. It could be called here instead, and would provide an API for clients use (a feature that's been requested). Currently, there isn't an easy way to close the connection because the monitor always reconnects it.",FALSE,TRUE,52,80,184,1,FALSE,TRUE,FALSE,TRUE,0,81
danielrhodes,"Check out what I just added. I put the start and stop methods on the consumer.",FALSE,FALSE,16,81,185,0,TRUE,TRUE,FALSE,TRUE,0,82
kaspth,"Non-standard indentation going on in the added docs. It goes, one for text, three for code.",FALSE,FALSE,16,82,186,0,FALSE,TRUE,FALSE,TRUE,0,83
kaspth,"Passing true reads really weird. I think adding a new API could capture this better, perhaps close(withoutReconnect: true) could do (if I'm understanding the purpose of the argument right).",FALSE,FALSE,29,84,189,1,FALSE,TRUE,FALSE,TRUE,0,85
javan,"Agree re: true as an arg, but I'd prefer a Connection#stop method instead.",FALSE,TRUE,13,85,190,0,FALSE,TRUE,FALSE,TRUE,0,86
kaspth,"Another thing to note is, we're adding extra terminology here. On top of close and open and the connected and disconnected callbacks, we now have start and stop. Since (dis)connect is generally what end-users will see that might be better than start & stop. E.g. App.cable.connect() over App.cable.start()",FALSE,FALSE,48,86,192,1,FALSE,TRUE,FALSE,TRUE,0,87
danielrhodes,"Agreed on the consistency. Changed it.",FALSE,FALSE,6,87,193,0,TRUE,TRUE,FALSE,TRUE,0,88
kaspth,"Could manifest the order requirement by using protocols.last in code instead of an extra key. Other parts of the code might even want to stay oblivious to the fact that last protocol means  unsupported , and write it as  whelp, we're all out of protocols, no reason to attempt reconnect. ",FALSE,FALSE,49,88,195,1,FALSE,TRUE,FALSE,TRUE,0,89
danielrhodes,"Yeah agreed it feels a bit fragile, which is why I was so explicit. I also just added a test to make sure that the protocol is last.",FALSE,FALSE,28,89,196,0,TRUE,TRUE,FALSE,TRUE,0,90
danielrhodes,"However, instead I could just add in the unsupported protocol right before we instantiate the driver (in ActionCable::Connection::WebSocket), which I think would accomplish what you were after when you say",FALSE,FALSE,30,89,198,2,TRUE,TRUE,FALSE,TRUE,0,90
danielrhodes,"Other parts of the code might even want to stay oblivious to the fact that last protocol means  unsupported ",FALSE,FALSE,19,89,199,3,TRUE,TRUE,FALSE,TRUE,0,90
danielrhodes,"This would keep the placement details safe from the rest of the code.",FALSE,FALSE,13,89,200,4,TRUE,TRUE,FALSE,TRUE,0,90
danielrhodes,"Ok I did that. Take a look. I think that looks much cleaner and makes it so nobody really has to think about the ordering.",FALSE,FALSE,25,90,201,0,TRUE,TRUE,FALSE,TRUE,0,91
javan,"How about:",FALSE,TRUE,2,91,202,0,FALSE,FALSE,FALSE,TRUE,0,92
danielrhodes,"@javan I just rolled that entire disconnect method into close (it's much cleaner this way).",FALSE,FALSE,15,92,203,0,TRUE,TRUE,FALSE,TRUE,0,93
javan,"Why was this moved? It introduces a subtle behavior / timing change that doesn't seem relevant to your PR.",FALSE,TRUE,19,93,205,1,FALSE,TRUE,FALSE,TRUE,0,94
danielrhodes,"A couple reasons:",FALSE,FALSE,3,94,206,0,TRUE,FALSE,FALSE,TRUE,0,95
danielrhodes,"That @monitor.recordConnect() is in a place which makes it protocol dependent. As I recall you wanted to get rid of the welcome message anyways.",FALSE,FALSE,24,94,208,2,TRUE,TRUE,FALSE,TRUE,0,95
danielrhodes,"It was creating a race condition where it was called after the decision to disconnect had been made when there was a protocol mismatch (because the welcome message was sent right after the server opens the connection), but before there was an actual disconnect. Maybe this doesn't matter because the monitor is being shut off anyways, but it seemed like an undesirable behavior.",FALSE,FALSE,63,94,210,4,TRUE,TRUE,FALSE,TRUE,0,95
javan,"You sold me on the welcome message in #23976 (comment) ðŸ˜?",FALSE,TRUE,11,95,211,0,FALSE,FALSE,FALSE,TRUE,0,96
javan,"I also like the idea that, especially when there is potentially authentication/the possibility that the server will reject the connection, the server sends a definitive message to the client saying you are connected: hence welcome.",FALSE,TRUE,35,95,213,2,FALSE,TRUE,FALSE,TRUE,0,96
danielrhodes,"Yes this is true as well, and I just realized there's a weakness I need to fix.",FALSE,FALSE,17,96,214,0,TRUE,TRUE,FALSE,TRUE,0,97
danielrhodes,"Your comment got me thinking about terminology, and I guess the question is: what determines a successful connection? I suppose the whole point of this PR is that we regard a successful connection as one where we have a socket connection and we have a successful protocol negotiation. So I put the recordConnect back where it was, and also moved the subscription reload there as well, because that was a race condition/bound to break.",FALSE,FALSE,74,97,216,1,TRUE,TRUE,FALSE,TRUE,0,98
javan,"Moving @monitor.recordDisconnect() and @subscriptions.notifyAll() from the onclose handler to the close method changes their timing such that they don't accurately reflect the connection's state. I also find it confusing that onclose calls close.",FALSE,TRUE,33,98,218,1,FALSE,TRUE,FALSE,TRUE,0,99
danielrhodes,"Ok @javan, changed the disconnection stuff so it's not using the close method as much. I think it looks better now.  At least from a timing perspective, everything falls into the right order in the logs.",FALSE,FALSE,37,99,219,0,TRUE,TRUE,FALSE,TRUE,0,100
danielrhodes,"Either way, it is an improvement from what was there before. There were several methods which  closed  the connection and they were called in different orders at different times. This follows much more logically.",FALSE,FALSE,34,99,220,1,TRUE,TRUE,FALSE,TRUE,0,100
danielrhodes,"Another gotcha which I've seen mentioned somewhere else is people who said they waited until the send buffer is clear before disconnecting. Not going to attempt that one here.",FALSE,FALSE,29,99,221,2,TRUE,TRUE,FALSE,TRUE,0,100
kaspth,"Still don't understand why we need to pass unsupported_protocol explicitly around in all these places. If protocols is a by-priority list of protocols for the client to respond to. Then wouldn't the last protocol really indicate nothing more to negotiate; close the connection altogether. To me that makes more sense than jumping through hoops with this variant of a protocol.",FALSE,FALSE,60,100,223,1,FALSE,TRUE,FALSE,TRUE,0,101
kaspth,"To top it off, I'd like to add the unsupported protocol back to ActionCable::INTERNAL[:protocols], so we can think of it as a manifest of the negotiation order.",FALSE,FALSE,27,100,225,3,FALSE,TRUE,FALSE,TRUE,0,101
danielrhodes,"The client isn't choosing the protocol, the server is. The client presents the server with a list of protocols it supports, the server chooses the first one which matches its own list of supported protocols, and sends that one (or none) back. If the browser client sees that none are sent back, it disconnects. That is all outside of our control.",FALSE,FALSE,61,101,227,1,TRUE,TRUE,FALSE,TRUE,0,102
danielrhodes,"The problem this is solving is that according to the WebSocket browser standards, the client isn't supposed to say whether that disconnect was due to a network failure or a protocol failure. So the unsupported protocol is a way around that: we know they are always going to agree on a protocol, but at least now we can see that it is the unsupported one.",FALSE,FALSE,65,101,229,3,TRUE,TRUE,FALSE,TRUE,0,102
danielrhodes,"I suppose we could say  if the agreed upon protocol is equal to the last one on the list, then disconnect ... but that would be confusing to the next person who comes along and sees that code.",FALSE,FALSE,37,101,230,4,TRUE,TRUE,FALSE,TRUE,0,102
danielrhodes,"To top it off, I'd like to add the unsupported protocol back to ActionCable::INTERNAL[:protocols], so we can think of it as a manifest of the negotiation order.",FALSE,FALSE,27,102,232,1,TRUE,TRUE,FALSE,TRUE,0,103
danielrhodes,"Sure I can do this. But on the server side, it does not matter which order they are given to the driver. It only matters that the client give the server the protocols with the unsupported protocol last. So I figured I would keep that ordering logic on the client side.",FALSE,FALSE,51,102,234,3,TRUE,TRUE,FALSE,TRUE,0,103
kaspth,"My problem is just that I don't see why we need to insert the extra protocol at runtime. My understanding is that we can do all that upfront. Maybe that's an insufficient understanding of the domain.",FALSE,FALSE,36,103,236,1,FALSE,TRUE,FALSE,TRUE,0,104
kaspth,"I'll try rereading your comments tomorrow, see if my brain is more receptive then ðŸ˜„",FALSE,FALSE,15,103,237,2,FALSE,TRUE,FALSE,TRUE,0,104
kaspth,"Thanks for all your effort on this! This is going to be so cool to have in â?¤ï¸?",FALSE,FALSE,18,103,238,3,FALSE,TRUE,FALSE,TRUE,0,104
danielrhodes,"We don't. I just thought it would be clearer to any future maintainers that this was a special case, but at the same time not get accidentally removed.",FALSE,FALSE,28,104,239,0,TRUE,TRUE,FALSE,TRUE,0,105
danielrhodes,"What's the status of this? Are we good to merge? I think after the reviews, the footprint of the change in terms of behavior/code is now quite low.",FALSE,FALSE,28,105,240,0,TRUE,TRUE,FALSE,TRUE,0,106
maclover7,"@danielrhodes I think this is coming along nicely -- can you try to squash down some of your commits?",FALSE,TRUE,19,106,241,0,FALSE,TRUE,FALSE,TRUE,0,107
danielrhodes,"Yes will do that now. Github actually just added a feature to do this automatically on merge -- something I'm sure you will appreciate!",FALSE,TRUE,24,107,242,0,TRUE,TRUE,FALSE,TRUE,0,108
javan,"Apologies for asking again since I think you explained this already, but it's not clear to me what the purpose of actioncable-unsupported protocol is. Perhaps it could be defined as a separate constant that gets included in this array so it can be documented separately.",FALSE,TRUE,45,108,244,1,FALSE,TRUE,FALSE,TRUE,0,109
javan,"Additionally, now that we have a v1 protocol in place, what kinds of changes warrant bumping the version? (I know the answer, but think it's worth documenting).",FALSE,TRUE,27,108,246,3,FALSE,TRUE,FALSE,TRUE,0,109
maclover7,"Sorry if I've already asked this -- is there any downside to having the protocol version match the current Action Cable version? Any breaking changes with Action Cable's websockets communication infrastructure should theoretically also be a regular-Action Cable breaking change. Having two version numbers seems a bit much...",FALSE,TRUE,48,109,248,1,FALSE,TRUE,TRUE,TRUE,0,110
danielrhodes,"@javan Yeah the reason for this is that the browser side WebSocket client sticks with the bizarre recommended implementation where the client does not tell us why it disconnected, when it could either be a bad disconnect or a protocol mismatch. So the actioncable-unspported protocol is the way to get around this: it will always be the last to be chosen, and if it is, we know for sure there is a mismatch. The alternatives to this are really hacky.",FALSE,TRUE,80,110,250,1,TRUE,TRUE,FALSE,TRUE,0,111
danielrhodes,"@maclover7 I initially asked myself the same thing. However, the protocol version is distinct from the Rails version, and ideally it would be changed quite a bit less often than the Rails version. Also since these protocol changes are almost always breaking changes, semantic versioning is not quite appropriate here.",FALSE,TRUE,50,110,252,3,TRUE,TRUE,FALSE,TRUE,0,111
javan,"protocols (Optional)Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols, so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server to be able to handle different types of interactions depending on the specified protocol). If you don't specify a protocol string, an empty string is assumed.-- https://developer.mozilla.org/en-US/docs/Web/API/WebSocket",FALSE,TRUE,63,111,253,0,FALSE,TRUE,FALSE,TRUE,0,112
javan,"Guess I'm still not clear why the client needs know about actioncable-unsupported. What would happen if we only pass the supported protocol and let the server disconnect if that protocol isn't specified?",FALSE,TRUE,32,111,255,2,FALSE,TRUE,FALSE,TRUE,0,112
javan,"Sorry, that's not right, I know we're not disconnecting server side on protocol mismatch. But can the server set the protocol to actioncable-unsupported if the client doesn't open the WebSocket with a supported protocol?",FALSE,TRUE,34,112,257,1,FALSE,TRUE,FALSE,TRUE,0,113
javan,"For example, client connects with:",FALSE,TRUE,5,112,258,2,FALSE,TRUE,FALSE,TRUE,0,113
javan,"And if the server only knows about actioncable-v2-json then it responds by setting the protocol to actioncable-unsupported.",FALSE,TRUE,17,112,259,3,FALSE,TRUE,FALSE,TRUE,0,113
danielrhodes,"The short answer is no. The server must choose one or none of the protocols the client presents to it. We provide a list of protocols to the Faye-Websocket driver, and we likewise give a list of supported protocols to the browser websocket client. If the server doesn't support any of the protocols, the  correct  way to handle this is to return nothing -- except we get penalized for doing this on the client side because of the implementation recommendations... hence this unsupported stuff.",FALSE,TRUE,84,113,261,1,TRUE,TRUE,FALSE,TRUE,0,114
danielrhodes,"The longer answer is that yes we could fork the Faye-Websocket driver and do this... but my experience with the browser websocket client has been that it is extremely stubborn, so it would probably not like this and throw an error if it received a protocol it did not send.",FALSE,TRUE,50,113,263,3,TRUE,TRUE,FALSE,TRUE,0,114
javan,"Gotcha. Thanks for explaining!",FALSE,TRUE,4,114,264,0,FALSE,TRUE,FALSE,TRUE,0,115
javan,"Move away from dispatching an event here. It's a plain object now.",FALSE,TRUE,12,115,266,1,FALSE,TRUE,FALSE,TRUE,0,116
danielrhodes,"Are you saying name it something different? Any suggestions?",FALSE,TRUE,9,116,267,0,TRUE,TRUE,FALSE,TRUE,0,117
javan,"Yeah, maybe document it as disconnected: ({ willAttemptReconnect: boolean }) ->?",FALSE,TRUE,11,117,268,0,FALSE,FALSE,FALSE,TRUE,0,118
javan,"I just don't want to suggest that it's an Event instance.",FALSE,TRUE,11,118,269,0,FALSE,TRUE,FALSE,TRUE,0,119
danielrhodes,"Yeah makes sense. I just changed it to that.",FALSE,TRUE,9,119,270,0,TRUE,TRUE,FALSE,TRUE,0,120
javan,"Could do @webSocket?.close() if @isActive() and drop the isClosed method entirely. Side note: we intentionally named isActive to not match a connection state and isClosed doesn't follow that pattern.",FALSE,TRUE,29,120,272,1,FALSE,TRUE,FALSE,TRUE,0,121
danielrhodes,"Yep don't see why not. Changed.",FALSE,TRUE,6,121,273,0,TRUE,TRUE,FALSE,TRUE,0,122
javan,"Tracking @disconnected was originally in place because to prevent calling the disconnect method twice since both the error and close handlers called it. Now that disconnect has been removed, I think we can rely on the connection state alone and remove @disconnected.",FALSE,TRUE,42,122,275,1,FALSE,TRUE,FALSE,TRUE,0,123
danielrhodes,"I think that should stay for now. It still seems to prevent some conditions where onClose is called by the websocket even though the websocket is already disconnected, which I think would be confusing to the developer. Personally I like those callbacks to be very definitive: if disconnected is called, it means it really just disconnected. So we shouldn't be making lots of callbacks while we are trying to reestablish a connection in the background.",FALSE,TRUE,75,123,277,1,TRUE,TRUE,TRUE,TRUE,0,124
javan,"ðŸ‘? if that's the case. Strange that close would be dispatched twice though. Can you reproduce?",FALSE,TRUE,16,124,278,0,FALSE,TRUE,FALSE,TRUE,0,125
danielrhodes,"Oh yeah for sure. On every unsuccessful connection this is how the browser says a connection did not happen. I guess it would have made more sense for them to add an event to onError, but what can you do?",FALSE,TRUE,40,125,279,0,TRUE,TRUE,FALSE,TRUE,0,126
javan,"How about splitting the protocols here into usefully named vars:",FALSE,TRUE,10,126,280,0,FALSE,FALSE,FALSE,TRUE,0,127
javan,"Using the suggested changes above, this would change to:",FALSE,TRUE,9,127,281,0,FALSE,FALSE,FALSE,TRUE,0,128
danielrhodes,"I had a back and forth with @kaspth about this... he wanted to minimize the heavy separation I made in the code between the supported and unsupported protocols. However, I don't think your suggestion conflicts with what he was looking for, so I made the change.",FALSE,TRUE,46,128,282,0,TRUE,TRUE,FALSE,TRUE,0,129
javan,"Is there a scenario where messages are received after calling webSocket.close()?",FALSE,TRUE,11,129,284,1,FALSE,TRUE,FALSE,TRUE,0,130
danielrhodes,"Yes the server fires out the welcome message pretty fast after connecting. The server doesn't decide to disconnect on a protocol mismatch, the client does.",FALSE,TRUE,25,130,286,1,TRUE,TRUE,FALSE,TRUE,0,131
javan,"Can we prevent the server from sending messages on protocol mismatch?",FALSE,TRUE,11,131,288,1,FALSE,TRUE,FALSE,TRUE,0,132
danielrhodes,"Yes we could. I ran through some scenarios where we could just tell the server to stop communicating in these cases, but it gets kind of murky and the websocket protocol seems to indicate the onus is on the client to disconnect when it doesn't like the protocol not the server. Also if somebody writes a client in something other than in the browser (that would be me :-P), they might not want that behavior. Specifically, the problem is that when a client is deployed in a mobile app, you want the client to be pretty flexible if the protocol needs to change -- so the server going dark is like the worst thing that could happen!",FALSE,TRUE,117,132,290,1,TRUE,TRUE,FALSE,TRUE,0,133
javan,"Cool. Mostly asking out of curiosity. Adding this guard makes sense.",FALSE,TRUE,11,133,291,0,FALSE,TRUE,FALSE,TRUE,0,134
javan,"Isn't checking @getProtocol() in supportedProtocols enough? If the protocol is in that array then it's not unsupportedProtocol.",FALSE,TRUE,17,134,293,1,FALSE,TRUE,FALSE,TRUE,0,135
danielrhodes,"Sure. It's just extra safety I guess.",FALSE,TRUE,7,135,294,0,TRUE,TRUE,FALSE,TRUE,0,136
javan,"Should we set disconnected = false only if the protocol is supported and remove the disconnected check in the onMessage handler?",FALSE,TRUE,21,136,296,1,FALSE,TRUE,FALSE,TRUE,0,137
danielrhodes,"I tried this before, but that welcome message was coming in and making the connection monitor think it was still online. It doesn't happen when code is as it is.",FALSE,TRUE,30,137,298,1,TRUE,TRUE,FALSE,TRUE,0,138
javan,"Guess that ^ doesn't remove the need to check disconnected in the message handler, but I find it clearer since it consolidates the logging and removes the early return.",FALSE,TRUE,29,139,300,1,FALSE,TRUE,FALSE,TRUE,0,140
danielrhodes,"Yeah I was fooling around with this and was going back and forth, but then I settled on a successful connection means actual server connection and a protocol is chosen. That work we did with the welcome message was actually quite useful in telling the client something was wrong during authentication failure, and we would lose this in the case where a successful connection means just connecting to the server.",FALSE,TRUE,70,140,302,1,TRUE,TRUE,FALSE,TRUE,0,141
danielrhodes,"Also I found a bug that hadn't been caught before which was that subscription requests were fired off immediately on connecting, even if the server had not sent welcome yet. In some scenarios that would produce odd behavior I imagine.",FALSE,TRUE,40,141,303,0,TRUE,TRUE,FALSE,TRUE,0,142
javan,"We've hit sporadic missing subscriptions in Basecamp. Hoping this is the cause! â?¤ï¸?",FALSE,TRUE,13,142,304,0,FALSE,TRUE,FALSE,TRUE,0,143
javan,"I settled on a successful connection means actual server connection and a protocol is chosen.",FALSE,TRUE,15,143,305,0,FALSE,TRUE,FALSE,TRUE,0,144
javan,"ðŸ‘? to that, but you're setting disconnected = false before checking the protocol.",FALSE,TRUE,13,143,306,1,FALSE,FALSE,FALSE,TRUE,0,144
javan,"Reviewing the open handler and where it sets @disconnected is the only thing left to address before this can be merged, IMO.",FALSE,TRUE,22,144,307,0,FALSE,TRUE,FALSE,TRUE,0,145
danielrhodes,"Alright I changed the message handler to check @isActive instead. It works the same. I don't quite understand why it worked with @disconnected even though as you pointed out there could be a race condition -- whatever underlying threading is going on obviously prioritized the close before the message is all I can surmise.",FALSE,TRUE,54,145,308,0,TRUE,TRUE,FALSE,TRUE,0,146
jeremy,"Re. subscription requests before welcome: we buffer incoming messages and process the buffer after welcome, so sending early subscription requests should work as expected.",FALSE,TRUE,24,146,309,0,FALSE,FALSE,TRUE,TRUE,0,147
javan,"Looking great! Any issues deploying the server-side changes while clients still have the previous .js assets running?",FALSE,TRUE,17,147,311,1,FALSE,TRUE,FALSE,TRUE,0,148
danielrhodes,"@javan There shouldn't be. If the client doesn't send any protocols it wants to use, the server won't either.",FALSE,TRUE,19,148,313,1,TRUE,TRUE,TRUE,TRUE,0,149
javan,"Sorry to nitpick, but add a newline after this comment please. Indicates that all methods below are  private , not just the isPorotocolSupported method.",FALSE,TRUE,23,149,314,0,FALSE,TRUE,FALSE,TRUE,0,150
danielrhodes,"Squashed the commits for squashlover7, err I mean @maclover7 :-P",FALSE,TRUE,10,151,316,0,TRUE,TRUE,FALSE,TRUE,0,152
danielrhodes,"P.S. I've actually started to like squashing now too, even if it's a conspiracy to keep everybody's commit numbers low to suppress rankings.",FALSE,TRUE,23,151,317,1,TRUE,TRUE,FALSE,TRUE,0,152
javan,"This isn't right. @isActive is a function, not a property.",FALSE,TRUE,10,152,318,0,FALSE,FALSE,FALSE,TRUE,0,153
javan,"I think we want to check that the WebSocket is using a supported protocol here so messages aren't received during the brief window after successfully connecting using an unsupported protocol.",FALSE,TRUE,30,152,320,2,FALSE,TRUE,FALSE,TRUE,0,153
javan,"Not loving how this method reads now. The early return only guards against logging. I suggest:",FALSE,TRUE,16,154,322,0,FALSE,TRUE,FALSE,TRUE,0,155
javan,"OK to merge as far as I'm concerned. Thanks for sticking with this one @danielrhodes!",FALSE,TRUE,15,156,324,0,FALSE,TRUE,FALSE,TRUE,0,157
jeremy,"Fantastic work @danielrhodes!",FALSE,TRUE,3,157,325,0,FALSE,FALSE,FALSE,TRUE,0,158
kaspth,"Well done! â?¤ï¸?",FALSE,TRUE,3,158,326,0,FALSE,FALSE,FALSE,TRUE,0,159
cdurante,"is this typo?",FALSE,FALSE,3,159,327,0,FALSE,FALSE,FALSE,TRUE,0,160
cdurante,"I see the the function isProtocolSupported, but not isSupportedProtocol",FALSE,FALSE,9,159,328,1,FALSE,TRUE,FALSE,TRUE,0,160
cdurante,"[Error] TypeError: this.isSupportedProtocol is not a function. (In 'this.isSupportedProtocol()', 'this.isSupportedProtocol' is undefined) message (connection.self-7605b1bcff260663a68e0847ec3cfece34a28e2cb3c61fb59bcac2dfab6b6ad7.js:131) (anonymous function)",FALSE,FALSE,16,159,329,2,FALSE,TRUE,FALSE,TRUE,0,160
jeremy,"Sure is. Thanks @cdurante!",FALSE,TRUE,4,160,330,0,FALSE,TRUE,FALSE,TRUE,0,161
