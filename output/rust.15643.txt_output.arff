% Generated by Discussion model rust.15643.txt
% File generated on 2017/08/11 11:55:43

@relation pr1502466943657

@attribute author String
@attribute textual String
@attribute isProjectMember {TRUE, FALSE}
@attribute isInvited {TRUE, FALSE}
@attribute numberOfWords numeric
@attribute commentsSoFar numeric
@attribute allUtterancesSoFar numeric
@attribute utterancesInCommentSoFar numeric
@attribute utteredByOriginalPoster {TRUE, FALSE}
@attribute hasCapitalizedWord {TRUE, FALSE}
@attribute containsShould {TRUE, FALSE}
@attribute hasDecisions {TRUE, FALSE}
@attribute howManyDecisions numeric
@attribute idComment numeric
@attribute idPara numeric

@data
errordeveloper,"This is to improve the interoperability with external C libraries.One should be able to leverage most Rust's standard run-time functionsfor openning and closing files with all the error handling etc, whileonly making C library calls when it's very neccessary.",FALSE,FALSE,39,0,1,1,TRUE,TRUE,TRUE,TRUE,0,1,1
errordeveloper,"it is still missing Windows support... and unit tests. Would be great to hear some feedback before I proceed with more work on this.",FALSE,FALSE,24,1,3,1,TRUE,TRUE,FALSE,TRUE,0,2,1
errordeveloper,"My main question regarding the unit tests is whether I should add it to every implementation of this trait  except from the trait definition, right?",FALSE,FALSE,26,2,5,1,TRUE,TRUE,TRUE,TRUE,0,3,1
errordeveloper,"Regarding Windows, I have no idea, so please do feel free to make some suggestions... Does it even have FDs in the same sense?",FALSE,FALSE,24,3,6,0,TRUE,TRUE,FALSE,TRUE,0,4,1
alexcrichton,"I'm a little wary to do this because of, sadly, windows. I don't quite grok how windows deals with HANDLE values vs file descriptors (there is some correspondence at least). Dealing with a file descriptor manually is also largely not portable, but it is often quite useful!",FALSE,FALSE,47,4,8,1,FALSE,TRUE,FALSE,TRUE,0,5,1
alexcrichton,"I would want to understand better how this works with windows before moving forward, personally.",FALSE,FALSE,15,4,9,2,FALSE,FALSE,FALSE,TRUE,0,5,2
errordeveloper,"I would want to understand better how this works with windows before moving forward, personally.",FALSE,FALSE,15,5,10,0,TRUE,TRUE,FALSE,TRUE,0,6,1
errordeveloper,"@alexcrichton understood.",FALSE,FALSE,2,5,11,1,TRUE,FALSE,FALSE,TRUE,0,6,2
errordeveloper,"Dealing with a file descriptor manually is also largely not portable, but it is often quite useful!",FALSE,FALSE,17,5,12,2,TRUE,FALSE,FALSE,TRUE,0,6,3
errordeveloper,"I have briefly though of doing something along the lines of:",FALSE,FALSE,11,5,13,3,TRUE,FALSE,FALSE,TRUE,0,6,4
errordeveloper,"Although this seems rather useful and makes sense along the side of with_c_str, but in some cases all you really want is to pass that file descriptor along and take the responsibility of closing it yourself. The prosed change certainly makes a lot of sense as the first step.",FALSE,FALSE,49,5,15,5,TRUE,TRUE,FALSE,TRUE,0,6,5
errordeveloper,"To me, the most disapointing bit was finding out that there is fs_from_raw_fd...",FALSE,FALSE,13,5,16,6,TRUE,FALSE,FALSE,TRUE,0,6,6
errordeveloper,"@alexcrichton by looking at libnative/io/file_win32.rs, it doesn't seem like there is a huge difference...",FALSE,FALSE,14,6,18,1,TRUE,FALSE,FALSE,TRUE,0,7,1
errordeveloper,"There is only an additional method:",FALSE,FALSE,6,6,19,2,TRUE,FALSE,FALSE,TRUE,0,7,2
errordeveloper,"So I guess I could provide get_handle in addition to get_fd in the windows version.",FALSE,FALSE,15,6,21,4,TRUE,TRUE,FALSE,TRUE,0,7,3
errordeveloper,"We need to check with libuv also...",FALSE,FALSE,7,6,22,5,TRUE,FALSE,FALSE,TRUE,0,7,4
alexcrichton,"I'm not sure whether a file descriptor is a first-class thing in windows or what relation it has to HANDLE other than there's likely a one-to-one mapping. Most windows apis deal with a HANDLE instead of a file descriptor, so this change would definitely be favoring unix over windows.",FALSE,TRUE,49,7,24,1,FALSE,TRUE,FALSE,TRUE,0,8,1
alexcrichton,"From your example above, however, this is why I've been hesitant to add it in the past. Many methods on these objects won't work if you start manually fiddling with flags on the file descriptor itself.",FALSE,TRUE,36,7,26,3,FALSE,TRUE,FALSE,TRUE,0,8,2
retep998,"Perhaps get_fd should be unsafe to warn you that working with file descriptors is an unsafe thing?",FALSE,FALSE,17,8,28,1,FALSE,TRUE,TRUE,TRUE,0,9,1
errordeveloper,"I have considered this and it's in the doc comment. There is not much youcan do with it apart from passing to a C function, which you will have towrap into  an unsafe block anyway.The FD is not a thing that you would have to keep secure anyway, a user canget all FD to each of the processes running with their UID without a lot ofeffort, if they had to be secure they wouldn't be numeric anyway. This isnot the right place to discuss security anyway, why did I even get started?As far as Rust is concerned, it does not intend to make the resultapplication secure. It can only make it safer. Although, I think insecurityis a side effect of unsafe languages...On 13 Jul 2014 18:30,  Peter Atashian  notifications@github.com wrote:",FALSE,FALSE,131,9,30,1,TRUE,TRUE,FALSE,TRUE,0,10,1
errordeveloper,"Perhaps get_fd should be unsafe to warn you that working with filedescriptors is an unsafe thing?",FALSE,FALSE,16,9,31,2,TRUE,FALSE,TRUE,TRUE,0,10,2
errordeveloper,"Reply to this email directly or view it on GitHub#15643 (comment).",FALSE,FALSE,11,9,32,3,TRUE,TRUE,FALSE,TRUE,0,10,3
alexcrichton,"This is not necessarily a security bug, it has the possibility of becoming a memory safety bug. Functions in libnative (and possibly libuv as well) may be designed assuming complete control of a file descriptor. If this control is broken, the broken assumptions may lead to memory unsafety.",FALSE,TRUE,48,10,34,1,FALSE,TRUE,FALSE,TRUE,0,11,1
alexcrichton,"I don't think we have any examples of this today, but that doesn't mean that it's impossible to have.",FALSE,TRUE,19,10,35,2,FALSE,FALSE,FALSE,TRUE,0,11,2
errordeveloper,"OK, sure. I'm not completely opposing making it an unsafe function. And,perhaps with suggested with_c_fd solution, it may be made somewhat saferwith respect to other functions... I would also propose adding a lockattribute around this and may be also add a guard for ensuring that onlyread-only access is allowed, perhaps. For example, get_fd could fail ifit holds write access. Although it would be less useful that way... I'm notsure whether one can force to reopen the same FD though.",FALSE,FALSE,79,11,37,1,TRUE,TRUE,FALSE,TRUE,0,12,1
errordeveloper,"So best solution would probably be to just simply call those functionsunsafe.On 13 Jul 2014 19:37,  Alex Crichton  notifications@github.com wrote:",FALSE,FALSE,20,11,38,2,TRUE,TRUE,FALSE,TRUE,0,12,2
errordeveloper,"This is not necessarily a security bug, it has the possibility of becominga memory safety bug. Functions in libnative (and possibly libuv as well)may be designed assuming complete control of a file descriptor. If thiscontrol is broken, the broken assumptions may lead to memory unsafety.",FALSE,FALSE,45,11,39,3,TRUE,TRUE,FALSE,TRUE,0,12,3
errordeveloper,"I don't think we have any examples of this today, but that doesn't meanthat it's impossible to have.",FALSE,FALSE,18,11,40,4,TRUE,FALSE,FALSE,TRUE,0,12,4
errordeveloper,"Reply to this email directly or view it on GitHub#15643 (comment).",FALSE,FALSE,11,11,41,5,TRUE,TRUE,FALSE,TRUE,0,12,5
andrew-d,"I'm not sure whether a file descriptor is a first-class thing in windows or what relation it has to HANDLE other than there's likely a one-to-one mapping. Most windows apis deal with a HANDLE instead of a file descriptor, so this change would definitely be favoring unix over windows.",FALSE,FALSE,49,12,42,0,FALSE,TRUE,FALSE,TRUE,0,13,1
andrew-d,"For what it's worth, a HANDLE on Windows is essentially the equivalent of the unix fd - it's what's used by the operating system, stored internally in the handle table of each process, etc..  fds on Windows, on the other hand, are only used by the C runtime library, and I believe there are cases in which a CRT fd doesn't have a backing HANDLE, though some quick googling doesn't provide any information about this.",FALSE,FALSE,76,12,43,1,FALSE,TRUE,FALSE,TRUE,0,13,2
errordeveloper,"So my Stack Overflow post resulted in a solution that will work for what I am doing right now.",FALSE,FALSE,19,13,44,0,TRUE,TRUE,FALSE,TRUE,0,14,1
errordeveloper,"I do still insist on this going forward.",FALSE,FALSE,8,14,45,0,TRUE,TRUE,FALSE,TRUE,0,15,1
errordeveloper,"@alexcrichton you commented earlier:",FALSE,FALSE,4,14,46,1,TRUE,FALSE,FALSE,TRUE,0,15,2
errordeveloper,"This is not necessarily a security bug, it has the possibility of becoming a memory safety bug. Functions in libnative (and possibly libuv as well) may be designed assuming complete control of a file descriptor. If this control is broken, the broken assumptions may lead to memory unsafety.",FALSE,FALSE,48,14,47,2,TRUE,TRUE,FALSE,TRUE,0,15,3
errordeveloper,"So it does occur to me now, based on the solution posted on Stack Overflow, that libnative (and most likelly libuv too) will allow one to call file.fd(), it's just that std::io::fs::File tries to hide it away for some reason.",FALSE,FALSE,40,14,48,3,TRUE,TRUE,FALSE,TRUE,0,15,4
errordeveloper,"Perhaps fd() and my get_fd() should be made unsafe for the reasons that we discussed? Although, personally I do not see those reasons being particularly strong. As I said, if one will be passing this to a C function call, they will need to explicitly say that it's going to be unsafe. In fact, I do think that operation of actually getting the numeric value of the file descriptor is 100% safe as such. It's what you do with it after.",FALSE,FALSE,81,14,50,5,TRUE,TRUE,TRUE,TRUE,0,15,5
errordeveloper,"In fact, one might actually simply use this to could how many files they have opened so far. As far as standard run time goes, it could actually attempt to protect form file descriptor leaks by preventing someone from opening the same file over and over again with the same mode... It would just tell you, that this had already been open and here is the original handle.",FALSE,FALSE,68,14,52,7,TRUE,TRUE,FALSE,TRUE,0,15,6
alexcrichton,"The librustuv and libnative interfaces are likely to always be experimental and not intended for general consumption. They provide their own access to file descriptors out of necessity for the library itself, I wouldn't recommend relying on the native/rustuv interfaces for extracting file descriptors.",FALSE,TRUE,44,15,54,1,FALSE,TRUE,FALSE,TRUE,0,16,1
alexcrichton,"If we were to add this function, I believe that it should be unsafe as we don't know for sure that all backing support is indeed memory safe if a file descriptor is fiddled with. Additionally, it should generally be avoided and not be necessary.",FALSE,TRUE,45,15,56,3,FALSE,TRUE,TRUE,TRUE,0,16,2
alexcrichton,"Also, from what @andrew-d said about file descriptors on windows, this would be tying rust permanently to their C runtime library. I'm not entirely sure if that's desirable or not?",FALSE,TRUE,30,15,58,5,FALSE,TRUE,FALSE,TRUE,0,16,3
errordeveloper,"Another use case for this would when one wants to use std::os::MemoryMap, which takes a file descriptor and does so on windows also. If you look at the source code it calls libc::get_osfhandle(fd) to get the handle...",FALSE,FALSE,37,16,59,0,TRUE,TRUE,FALSE,TRUE,0,17,1
errordeveloper,"Anyhow, right now I need to use native::io::file::open, if I want to use std::os::MemoryMap. Is this okay or I should ideally use std::io::fs::File?",FALSE,FALSE,23,16,61,2,TRUE,TRUE,TRUE,TRUE,0,17,2
alexcrichton,"Ok, after stewing for a bit I think I'd like to move forward with this. @errordeveloper, could you add the following pieces to the pr?",FALSE,TRUE,25,17,62,0,FALSE,TRUE,FALSE,TRUE,0,18,1
alexcrichton,"Add get_fd to all the other I/O primitives in std::io (where applicable). The ones that I can think of are:",FALSE,TRUE,20,17,63,1,FALSE,TRUE,FALSE,TRUE,0,18,2
alexcrichton,"{Tcp, Unix}{Stream, Acceptor, Listener}UdpSocket,FilePipeStreamStd{Reader, Writer}",FALSE,TRUE,5,17,64,2,FALSE,TRUE,FALSE,TRUE,0,18,3
alexcrichton,"All methods can basically point to one other method to look for documentation",FALSE,TRUE,13,17,65,3,FALSE,FALSE,FALSE,TRUE,0,18,4
alexcrichton,"There should be stern documentation about the dangers of using raw file descriptors, I can help with the exact wording",FALSE,TRUE,20,17,66,4,FALSE,TRUE,TRUE,TRUE,0,18,5
alexcrichton,"Windows networking objects should be commented that they are returning a SOCKET, not a file descriptor",FALSE,TRUE,16,17,67,5,FALSE,TRUE,TRUE,TRUE,0,18,6
alexcrichton,"Comments should indicate that file descriptors on windows are C runtime artifacts, not HANDLE values.",FALSE,TRUE,15,17,68,6,FALSE,TRUE,TRUE,TRUE,0,18,7
alexcrichton,"And some unresolved questions I also have:",FALSE,TRUE,7,17,69,7,FALSE,TRUE,FALSE,TRUE,0,18,8
alexcrichton,"Should get_fd be unsafe? (I would vote yes)",FALSE,TRUE,8,17,71,9,FALSE,TRUE,FALSE,TRUE,0,18,9
alexcrichton,"Should get_fd return an int instead of a c_int? This is largely due to SOCKET where it is a c_uint and this also may just vary per-platform. I would tend to lean towards yes to not expose C types, but I don't feel super strongly about this.",FALSE,TRUE,47,17,73,11,FALSE,TRUE,FALSE,TRUE,0,18,10
alexcrichton,"Is get_fd the best name? The sockets on windows definitely aren't file descriptors...",FALSE,TRUE,13,17,75,13,FALSE,TRUE,FALSE,TRUE,0,18,11
alexcrichton,"Should get_fd be a trait method? It's probably too much abstraction for now, so I would vote no. The upside is that you have to explicitly import something to look at the file descriptor.",FALSE,TRUE,34,17,77,15,FALSE,TRUE,FALSE,TRUE,0,18,12
alexcrichton,"Does that sounds ok? We can deal with the questions in time, and I'm around to help out with any questions you have, feel free to reach out on IRC! (I'm acrichto)",FALSE,TRUE,32,17,78,16,FALSE,TRUE,FALSE,TRUE,0,18,13
huonw,"Is get_fd the best name? The sockets on windows definitely aren't file descriptors...",FALSE,FALSE,13,18,79,0,FALSE,TRUE,FALSE,TRUE,0,19,1
huonw,"get_os_identifier? (I guess people will likely be looking for  file descriptor  or  fd  when searching for it, so this may not be the most discoverable name.)",FALSE,FALSE,26,18,81,2,FALSE,FALSE,FALSE,TRUE,0,19,2
chris-morgan,"I do not like this, Sam-I-Am.",FALSE,FALSE,6,19,82,0,FALSE,TRUE,FALSE,TRUE,0,20,1
chris-morgan,"Supposing I wish to use a different runtime that doesn’t use that sort of descriptor at all—a bare metal case might do it, or perhaps an emscripten-specific runtime for running in the browser (I can easily imagine that one having absolutely nothing to do with such magic numbers). I do not believe it is at all reasonable to expect to be able to have such a descriptor, at the language level at least.",FALSE,FALSE,73,19,84,2,FALSE,TRUE,FALSE,TRUE,0,20,2
chris-morgan,"Still, for pragmatism’s sake, it must evidently be exposed somewhere. Given that, I would say very strongly that such functions should be marked unsafe, and probably unstable also. I would think also that having it on a separate trait would be a good thing—could the trait even live in the libc crate to make it absolutely clear that it’s That Sort of Thing?",FALSE,FALSE,63,19,86,4,FALSE,TRUE,TRUE,TRUE,0,20,3
chris-morgan,"A benefit of using a trait for this is that you could then use it as a generic bound, e.g. for exposing a safe interface over ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count).",FALSE,FALSE,35,20,88,1,FALSE,TRUE,FALSE,TRUE,0,21,1
errordeveloper,"I cannot disagree with you, Chris. I do however believe that currentstandard run-time contains plenty of bits that wouldn't work on bare metal.My original diff contains only changes for filesystem access abstractions,and I would argue whether filesystems should exist on certain kinds ofembedded systems. In regards to sockets, nearly all of embedded stacksnumeric descriptors that are quite similar in nature, those that aredifferent in respect to this are, in fact, different in many other ways.On 18 Jul 2014 08:45,  Chris Morgan  notifications@github.com wrote:",FALSE,TRUE,83,21,90,1,TRUE,TRUE,TRUE,TRUE,0,22,1
errordeveloper,"I do not like this, Sam-I-Am.",FALSE,TRUE,6,21,91,2,TRUE,TRUE,FALSE,TRUE,0,22,2
errordeveloper,"Supposing I wish to use a different runtime that doesn't use that sort ofdescriptor at all--a bare metal case might do it, or perhaps anemscripten-specific runtime for running in the browser (I can easilyimagine that one having absolutely nothing to do with such magicnumbers). I do not believe it is at all reasonable to expect to be able tohave such a descriptor, at the language level at least.",FALSE,TRUE,68,21,92,3,TRUE,TRUE,FALSE,TRUE,0,22,3
errordeveloper,"Still, for pragmatism's sake, it must evidently be exposed somewhere.Given that, I would say very strongly that such functions should be markedunsafe, and probably unstable also. I would think also that having it on aseparate trait would be a good thing--could the trait even live in the libccrate to make it absolutely clear that it's That Sort of Thing?",FALSE,TRUE,59,21,93,4,TRUE,TRUE,TRUE,TRUE,0,22,4
errordeveloper,"Reply to this email directly or view it on GitHub#15643 (comment).",FALSE,TRUE,11,21,94,5,TRUE,TRUE,FALSE,TRUE,0,22,5
huonw,"I would think also that having it on a separate trait would be a good thing",FALSE,FALSE,16,22,95,0,FALSE,TRUE,FALSE,TRUE,0,23,1
huonw,"A trait is useless for distiguishing things that only have sensible implementation under certain runtimes, the std::io interfaces are completely opaque to the underlying runtime, meaning an implementation for File would apply to a File objects in any runtimes, exactly the same as a freestanding method.",FALSE,FALSE,46,22,97,2,FALSE,TRUE,FALSE,TRUE,0,23,2
errordeveloper,"@huonw what do you say: add get_fd() to std::io::File or keep it how it is right now, requiring one to use native::io::file::open?",FALSE,TRUE,22,23,99,1,TRUE,FALSE,FALSE,TRUE,0,24,1
errordeveloper,"I have just notice new rust-lang/rfcs#185... If that's to be implemented, I'd hold on with the get_fd() story.",FALSE,TRUE,18,24,100,0,TRUE,TRUE,FALSE,TRUE,0,25,1
errordeveloper,">>>tbu-, Contributor",FALSE,TRUE,2,24,101,1,TRUE,TRUE,FALSE,TRUE,0,25,2
errordeveloper,"I don't see why getting the file descriptor should be unsafe – getting a raw pointer from a & pointer isn't unsafe either, it's only that actually using it is unsafe.",FALSE,TRUE,31,24,103,3,TRUE,TRUE,TRUE,TRUE,0,25,3
errordeveloper,"As per the Rust design documents, reading private values from objects isn't considered unsafe if I remember correctly.",FALSE,TRUE,18,24,104,4,TRUE,TRUE,FALSE,TRUE,0,25,4
l0kod,"First, about the get_fd method, I suggest to use something like the FileDesc struct (with close_on_drop set to true) instead of the c_int result (how should be typed to fd_t anyway).",FALSE,FALSE,31,25,106,1,FALSE,TRUE,TRUE,TRUE,0,26,1
l0kod,"Second, it would be safer to enclose the file descriptor use into a closure. What's unsafe about file descriptor is their lifetime: they can be closed by another piece of code, refer to a different file (i.e. close then open), or passed to an execve (Command close all file descriptor, except 0 to 2, before execve anyway, but some unsafe code could execve too).",FALSE,FALSE,64,25,108,3,FALSE,TRUE,FALSE,TRUE,0,26,2
l0kod,"I don't think we need a close_after parameter, we just can make the file descriptor object live until the C binding close the raw file descriptor.If we really need a persistent file descriptor we can dup it.For MemoryMap-like struct, the Rust libraries should take care of file descriptor transfert/safety. Maybe MapFd should be created from a RtioPipe?",FALSE,FALSE,57,25,111,6,FALSE,TRUE,TRUE,TRUE,0,26,3
l0kod,"We could use a with_fd method inspired from the with_c_str but for the RtioPipe trait:",FALSE,FALSE,15,25,113,8,FALSE,TRUE,FALSE,TRUE,0,26,4
l0kod,"I used Option hack because it's maybe not possible to get fd_t from any RtioPipe (libuv, special architecture?).",FALSE,FALSE,18,25,114,9,FALSE,TRUE,FALSE,TRUE,0,26,5
l0kod,"The problem is that we get error: cannot call a generic method through an object…",FALSE,FALSE,15,25,115,10,FALSE,FALSE,FALSE,TRUE,0,26,6
l0kod,"By the way, is there plan to support generic method call through trait?",FALSE,FALSE,13,25,117,12,FALSE,TRUE,FALSE,TRUE,0,26,7
l0kod,"First, about the get_fd method, I suggest to use something like the FileDesc struct (with close_on_drop set to true) instead of the c_int result (how should be typed to fd_t anyway).",FALSE,FALSE,31,26,118,0,FALSE,TRUE,TRUE,TRUE,0,27,1
l0kod,"Not the right choice, prefer to return &fd_t to let the RtioPipe handle the file descriptor closing, but it sound unsafe anyway because the RtioPipe can read/write/lseek/close the same file descriptor.The with_fd method definitely seems to be a better choice.",FALSE,FALSE,40,26,120,2,FALSE,TRUE,FALSE,TRUE,0,27,2
l0kod,"To properly handle file descriptor lifetime in bindings, the right thing to do is to wrap the bindings in a Rust object who handle the file descriptor closing.",FALSE,FALSE,28,26,122,4,FALSE,TRUE,FALSE,TRUE,0,27,3
l0kod,">>>tbu-, Contributor",FALSE,FALSE,2,26,123,5,FALSE,TRUE,FALSE,TRUE,0,27,4
l0kod,"Second, it would be safer to enclose the file descriptor use into a closure. What's unsafe about file descriptor is their lifetime: they can be closed by another piece of code, refer to a different file (i.e. close then open), or passed to an execve (Command close all file descriptor, except 0 to 2, before execve anyway, but some unsafe code could execve too).",FALSE,FALSE,64,26,124,6,FALSE,TRUE,FALSE,TRUE,0,27,5
l0kod,"I don't see how reading the file descriptor is unsafe in any way – only using them to construct other things should be unsafe. Compare",FALSE,FALSE,25,26,126,8,FALSE,TRUE,TRUE,TRUE,0,27,6
l0kod,"(which is safe) to",FALSE,FALSE,4,26,127,9,FALSE,FALSE,FALSE,TRUE,0,27,7
l0kod,"(which is unsafe). Getting the raw value of a pointer is not unsafe at all, while actually using it is. This is how it should be handled with file descriptors IMO, getting them out of a structure is no problem at al – only using them to construct other things should be unsafe.",FALSE,FALSE,53,26,129,11,FALSE,TRUE,TRUE,TRUE,0,27,8
l0kod,"I don't see how reading the file descriptor is unsafe in any way – only using them to construct other things should be unsafe.",FALSE,FALSE,24,27,130,0,FALSE,TRUE,TRUE,TRUE,0,28,1
l0kod,"For example, the read or lseek syscalls modify the file descriptor representation (in the kernel): it change the file offset where the initial owner could read or write. A file descriptor value can not really be  read-only  because interacting with it will update the kernel structure for this file descriptor.",FALSE,FALSE,50,27,132,2,FALSE,TRUE,FALSE,TRUE,0,28,2
l0kod,"Getting the raw value of a pointer is not unsafe at all, while actually using it is.",FALSE,FALSE,17,27,133,3,FALSE,FALSE,FALSE,TRUE,0,28,3
l0kod,"This is true for pointer but there is no relation with file descriptor. Your example is only about memory.Rust understand memory management and can control it but file descriptors are managed by the kernel. So Rust should take care not to allow uncontrolled behavior with file descriptor value.",FALSE,FALSE,48,27,135,5,FALSE,TRUE,TRUE,TRUE,0,28,4
l0kod,"This is why I used the  lifetime  word. It's the same problem as memory management (i.e. to control the usage) but it's not the same way to prevent unsafe behavior.",FALSE,FALSE,30,27,136,6,FALSE,TRUE,FALSE,TRUE,0,28,5
retep998,"A file descriptor on its own still can't be used as anything more than an integer value unless you use unsafe code. I'm really not seeing the difference between file descriptors and raw pointers since both are nothing more than integers until you use some unsafe code. And since you'll have to use unsafe code anyway to use the file descriptor, you could easily sidestep any imposed safety of a with_fd method. If having with_fd is seen as a good idea, then why not have with_raw_ptr for &ptr?",FALSE,FALSE,88,28,138,1,FALSE,TRUE,FALSE,TRUE,0,29,1
retep998,">>>tbu-, Contributor",FALSE,FALSE,2,28,139,2,FALSE,TRUE,FALSE,TRUE,0,29,2
retep998,"For example, the read or lseek syscalls modify the file descriptor representation (in the kernel): it change the file offset where the initial owner could read or write. A file descriptor value can not really be  read-only  because interacting with it will update the kernel structure for this file descriptor.",FALSE,FALSE,50,28,140,3,FALSE,TRUE,FALSE,TRUE,0,29,3
retep998,"Well, read also modifies a raw pointer's content, e. g.:",FALSE,FALSE,10,28,141,4,FALSE,FALSE,FALSE,TRUE,0,29,4
retep998,"This is true for pointer but there is no relation with file descriptor. Your example is only about memory.Rust understand memory management and can control it but file descriptors are managed by the kernel. So Rust should take care not to allow uncontrolled behavior with file descriptor value.",FALSE,FALSE,48,28,142,5,FALSE,TRUE,TRUE,TRUE,0,29,5
retep998,"The kernel also manages the underlying memory, and as shown above will happily write to any raw pointers I hand it.",FALSE,FALSE,21,28,143,6,FALSE,TRUE,FALSE,TRUE,0,29,6
retep998,"So I think the solution should be that the syscalls are unsafe, as long as they take raw filedescriptors or raw pointers.",FALSE,FALSE,22,28,145,8,FALSE,TRUE,TRUE,TRUE,0,29,7
retep998,"On a related note, there might be some useful way to wrap a file descriptor in a safe way, so it can be lended to different objects or moved into them without a whole File wrapping it.",FALSE,FALSE,37,28,147,10,FALSE,TRUE,FALSE,TRUE,0,29,8
l0kod,"since you'll have to use unsafe code anyway to use the file descriptor, you could easily sidestep any imposed safety of a with_fd method.",FALSE,FALSE,24,29,148,0,FALSE,FALSE,FALSE,TRUE,0,30,1
l0kod,"Well, the with_fd is not to  impose  safety but to avoid unsafe (distracted) use.",FALSE,FALSE,14,29,150,2,FALSE,TRUE,FALSE,TRUE,0,30,2
l0kod,"The with_c_str is useful to use a C string while being assured that this string exist: it allow Rust to know the pointer (use) lifetime. That way we can have a guaranty that the (binding) code using it does something meaningful (and the Rust runtime can cleanup the mess afterwards).",FALSE,FALSE,50,29,151,3,FALSE,TRUE,FALSE,TRUE,0,30,3
l0kod,"If having with_fd is seen as a good idea, then why not have with_raw_ptr for &ptr?",FALSE,FALSE,16,29,152,4,FALSE,FALSE,FALSE,TRUE,0,30,4
l0kod,"Why not? :)",FALSE,FALSE,3,29,153,5,FALSE,FALSE,FALSE,TRUE,0,30,5
l0kod,"Well, read also modifies a raw pointer's content",FALSE,FALSE,8,29,154,6,FALSE,FALSE,FALSE,TRUE,0,30,6
l0kod,"That's the purpose of read to write to memory, but it also change the file descriptor metadata.",FALSE,FALSE,17,29,155,7,FALSE,FALSE,FALSE,TRUE,0,30,7
l0kod,"On a related note, there might be some useful way to wrap a file descriptor in a safe way, so it can be lended to different objects or moved into them without a whole File wrapping it.",FALSE,FALSE,37,29,156,8,FALSE,TRUE,FALSE,TRUE,0,30,8
l0kod,"This is partially the purpose of the with_fd: to allow bindings to use file descriptor (in the safer way).",FALSE,FALSE,19,29,158,10,FALSE,TRUE,FALSE,TRUE,0,30,9
l0kod,">>>tbu-, Contributor",FALSE,FALSE,2,29,159,11,FALSE,TRUE,FALSE,TRUE,0,30,10
l0kod,"Well, the with_fd is not to  impose  safety but to avoid unsafe (distracted) use.",FALSE,FALSE,14,29,160,12,FALSE,FALSE,FALSE,TRUE,0,30,11
l0kod,"So does the solution that I propose and is currently being implemented for raw pointers.",FALSE,FALSE,15,29,161,13,FALSE,TRUE,FALSE,TRUE,0,30,12
l0kod,"I don't see how raw pointers and file descriptors are different here.",FALSE,FALSE,12,29,163,15,FALSE,TRUE,FALSE,TRUE,0,30,13
l0kod,"For raw pointers, the usual (safe) way to handle them correctly is to keep the pointed Rust object (e.g. Vec)  alive  (stay in scope) while manipulating the pointer (e.g. .as_ptr()).So the programmer must manually check that this rule is respected.",FALSE,FALSE,40,30,164,0,FALSE,TRUE,FALSE,TRUE,0,31,1
l0kod,"The with_fd goal is to remove the manual check but let Rust handle it.",FALSE,FALSE,14,30,166,2,FALSE,TRUE,FALSE,TRUE,0,31,2
l0kod,"I don't see why getting the file descriptor should be unsafe – getting a raw pointer from a & pointer isn't unsafe either, it's only that actually using it is unsafe.",FALSE,FALSE,31,30,167,3,FALSE,FALSE,TRUE,TRUE,0,31,3
l0kod,"I don't think getting a file descriptor should be unsafe. However Rust doesn't know that the raw file descriptor use is unsafe (and some people don't either).",FALSE,FALSE,27,30,169,5,FALSE,TRUE,TRUE,TRUE,0,31,4
l0kod,"So I think the solution should be that the syscalls are unsafe, as long as they take raw filedescriptors or raw pointers.",FALSE,FALSE,22,30,170,6,FALSE,TRUE,TRUE,TRUE,0,31,5
l0kod,"Raw syscalls are unsafe but they are usually wrapped in  safe  functions.",FALSE,FALSE,12,30,172,8,FALSE,TRUE,FALSE,TRUE,0,31,6
l0kod,"I don't see how raw pointers and file descriptors are different here.",FALSE,FALSE,12,30,173,9,FALSE,FALSE,FALSE,TRUE,0,31,7
l0kod,"Rust know how to handle memory and that raw pointers are unsafe because their use is not checked by the compiler but by the programmer.File descriptors are handled by the kernel and Rust doesn't know about their unsafety: there is no file descriptor dereferencing.",FALSE,FALSE,44,30,175,11,FALSE,TRUE,FALSE,TRUE,0,31,8
l0kod,">>>tbu-, Contributor",FALSE,FALSE,2,30,176,12,FALSE,TRUE,FALSE,TRUE,0,31,9
l0kod,"Raw syscalls are unsafe but they are usually wrapped in  safe  functions.",FALSE,FALSE,12,30,177,13,FALSE,FALSE,FALSE,TRUE,0,31,10
l0kod,"-- quote break --",FALSE,FALSE,4,30,178,14,FALSE,FALSE,FALSE,TRUE,0,31,11
l0kod,"I don't think getting a file descriptor should be unsafe. However Rust doesn't know that the raw file descriptor use is unsafe (and some people don't either).",FALSE,FALSE,27,30,179,15,FALSE,TRUE,TRUE,TRUE,0,31,12
l0kod,"The library should totally do this, isn't it doing that already? All functions taking a raw file descriptor and using it should be unsafe. Then add a type for an owned file descriptor FileDesc and provide a safe interface for it. Then you get borrowed file descriptors (&mut FileDesc) and shared file descriptors RefCell<FileDesc> for free.",FALSE,FALSE,56,30,181,17,FALSE,TRUE,TRUE,TRUE,0,31,13
l0kod,"I believe that you think that what I propose is impossible. If that's the case, please say so, because I'm very sure that this is very possible. If you think what I'm proposing is impractical, please say so.",FALSE,FALSE,38,30,182,18,FALSE,TRUE,FALSE,TRUE,0,31,14
l0kod,">>>tbu-, Contributor",FALSE,FALSE,2,30,183,19,FALSE,TRUE,FALSE,TRUE,0,31,15
l0kod,"The with_fd goal is to remove the manual check but let Rust handle it.",FALSE,FALSE,14,30,184,20,FALSE,TRUE,FALSE,TRUE,0,31,16
l0kod,"This would be the &mut FileDesc in my case.",FALSE,FALSE,9,30,185,21,FALSE,TRUE,FALSE,TRUE,0,31,17
l0kod,"I believe that you think that what I propose is impossible.",FALSE,FALSE,11,31,186,0,FALSE,TRUE,FALSE,TRUE,0,32,1
l0kod,"No, I only want the safer way to deal with file descriptor :)",FALSE,FALSE,13,31,187,1,FALSE,TRUE,FALSE,TRUE,0,32,2
l0kod,"The FileDesc thing is quite close to my first proposition and the RefCell<FileDesc> looks like a winner if it's implemented in all syscalls and functions wrappers who deal with file descriptors and would require a mutable FileDesc (not a mutable internal fd_t) with borrow_mut to (exclusively) use the file descriptor, even for read-only call.The interesting (and dangerous) thing is the shared/locked file descriptor wrapper.",FALSE,FALSE,64,31,189,3,FALSE,TRUE,FALSE,TRUE,0,32,3
l0kod,"would require a mutable FileDesc (not a mutable internal fd_t) with borrow_mut to (exclusively) use the file descriptor, even for read-only call.",FALSE,FALSE,22,32,190,0,FALSE,TRUE,FALSE,TRUE,0,33,1
l0kod,"We can't force some code to use borrow_mut to read a variable.I think the RefCell<FileDesc> should be wrapped into it's own struct to be able to control the borrow_mut behavior for any use (read or write) or maybe use a simple Mutex internally.",FALSE,FALSE,43,32,192,2,FALSE,TRUE,TRUE,TRUE,0,33,2
l0kod,">>>tbu-, Contributor",FALSE,FALSE,2,32,193,3,FALSE,TRUE,FALSE,TRUE,0,33,3
l0kod,"even for read-only call.",FALSE,FALSE,4,32,194,4,FALSE,FALSE,FALSE,TRUE,0,33,4
l0kod,"Of course – it's a write access, as it modifies the underlying stream (it moves the cursor position).",FALSE,FALSE,18,32,195,5,FALSE,FALSE,FALSE,TRUE,0,33,5
l0kod,"We can't force some code to use borrow_mut to read a variable.",FALSE,FALSE,12,32,196,6,FALSE,FALSE,FALSE,TRUE,0,33,6
l0kod,"We can, by letting all the functions modifying underlying structure (like moving the cursor, etc.) take a &mut FileDesc.",FALSE,FALSE,19,32,198,8,FALSE,TRUE,FALSE,TRUE,0,33,7
l0kod,"The good thing is, using my partially described FileDesc type, all the usual pattern will automagically work, safely. I'm talking about bare FileDesc passing, mutable borrowing &mut FileDesc, run-time borrowing RefCell<FileDesc>, sharing Arc<RefCell<FileDesc>> etc.",FALSE,FALSE,34,32,200,10,FALSE,TRUE,FALSE,TRUE,0,33,8
l0kod,"We can, by letting all the functions modifying underlying structure (like moving the cursor, etc.) take a &mut FileDesc.",FALSE,FALSE,19,33,201,0,FALSE,TRUE,FALSE,TRUE,0,34,1
l0kod,"It's a bit artificial and it imply all functions using file descriptor anyway (except for printing or duplicating file descriptor maybe).",FALSE,FALSE,21,33,203,2,FALSE,TRUE,FALSE,TRUE,0,34,2
l0kod,"I think it should affect a lot of code but it's worth a try.",FALSE,FALSE,14,33,204,3,FALSE,FALSE,TRUE,TRUE,0,34,3
l0kod,"The methods would probably looks like get_ref_fd, get_mut_ref_fd and get_fd (preferably less verbose).",FALSE,FALSE,13,33,206,5,FALSE,TRUE,FALSE,TRUE,0,34,4
errordeveloper,"@l0kod @tbu-, thank you for joining this, it certainly starts to make much more sense now.",FALSE,TRUE,16,34,207,0,TRUE,FALSE,FALSE,TRUE,0,35,1
l0kod,"Some additional reflections about the FileDesc object:",FALSE,TRUE,7,35,208,0,FALSE,TRUE,FALSE,TRUE,0,36,1
l0kod,"About the name, does it make sense to use  file descriptor  instead of  handle  for Windows?",FALSE,TRUE,16,35,210,2,FALSE,TRUE,FALSE,TRUE,0,36,2
l0kod,"If implemented, a clone should do the same as calling dup on the raw file descriptor.",FALSE,TRUE,16,35,212,4,FALSE,TRUE,TRUE,TRUE,0,36,3
l0kod,"Probably for a dedicated issue but, I think it would make sense (for the next step) to extend FileDesc methods with std::os functions (e.g. openat, linkat, dup, fstat…). And, if so, what about Path and File methods (i.e. rename, copy, open…)?",FALSE,TRUE,41,35,214,6,FALSE,TRUE,FALSE,TRUE,0,36,4
l0kod,"What about declaring FileDesc in std::os or std::fs?",FALSE,TRUE,8,35,216,8,FALSE,TRUE,FALSE,TRUE,0,36,5
l0kod,"Do we need a FileDesc trait and multiple file descriptor types (e.g. RegFileDesc, PipeFileDesc, SockFileDesc… found with fstat) to follow the Rust typing style and add appropriate methods (e.g. only mkdirat for DirFileDesc type)?",FALSE,TRUE,34,35,218,10,FALSE,TRUE,FALSE,TRUE,0,36,6
petrochenkov,"About the name, does it make sense to use  file descriptor  instead of  handle  for Windows?",FALSE,FALSE,16,36,219,0,FALSE,TRUE,FALSE,TRUE,0,37,1
petrochenkov,"Yes, file descriptors in Windows are very similar to file descriptors in posix, use similar API and usually the most useful. (Example: http://msdn.microsoft.com/en-us/library/5fzwd5ss.aspx)File handles are lower level mechanism, deal with WinAPI directly and are rarely touched by programmers. (Example: http://msdn.microsoft.com/en-us/library/windows/desktop/ms724211(v=vs.85).aspx)",FALSE,FALSE,40,36,220,1,FALSE,TRUE,FALSE,TRUE,0,37,2
petrochenkov,"this would be tying rust permanently to their C runtime library. I'm not entirely sure if that's desirable or not?",FALSE,FALSE,20,36,221,2,FALSE,TRUE,FALSE,TRUE,0,37,3
petrochenkov,"Isn't it a necessary evil similar to  tying rust permanently to glibc ?",FALSE,FALSE,12,36,223,4,FALSE,TRUE,FALSE,TRUE,0,37,4
petrochenkov,"I actually found this issue after I couldn't get anything lower level from std::io::fs::File to do some file locking. fs::File definitely should expose its underlying descriptor even if it implies safety issues. Otherwise if you have to access some specific OS mechanism in just one place, you will have to fall back to using libc all over the place.As for naming, C++ calls such escape hatches  native_handle s and leaves their meaning fully implementation defined and platform specific (for example, they can always be 0 if  it's necessary). I'd do the same and specify their meaning for each platform separately.",FALSE,FALSE,100,36,226,7,FALSE,TRUE,TRUE,TRUE,0,37,5
retep998,"I personally prefer HANDLE over a posix file descriptor while on Windows because it lets me use the full range of WinAPI methods which do significantly more than the equivalent posix functions, and sometimes your only option is the WinAPI versions (are there any posix methods that operate on file descriptors without an equivalent HANDLE version?). Granted you can always convert the two kinds of handles back and forth, but it just feels ugly that way.",FALSE,FALSE,76,37,228,1,FALSE,TRUE,FALSE,TRUE,0,38,1
retep998,">>>tbu-, Contributor",FALSE,FALSE,2,37,229,2,FALSE,TRUE,FALSE,TRUE,0,38,2
retep998,"What are file descriptors supposed to be on Windows? I only know of HANDLEs (and would have assumed that Rust will return these as FileDesc on Windows.)",FALSE,FALSE,27,37,231,4,FALSE,TRUE,FALSE,TRUE,0,38,3
thestinger,"It has numeric file descriptors in the C runtime, which can be converted to and from a HANDLE. It would be best to just use HANDLE on Windows and have a different type on different platforms. It could trigger a portability lint or whatever.",FALSE,FALSE,44,38,233,1,FALSE,TRUE,FALSE,TRUE,0,39,1
thestinger,"Anyway, it would be nice to expose a proper FileDesc type with the reference counting ownership semantics of POSIX file descriptors and Windows HANDLEs.",FALSE,FALSE,24,39,235,1,FALSE,TRUE,FALSE,TRUE,0,40,1
thestinger,"An important thing to keep in mind is that all files should be atomically O_CLOEXEC by default, so using dup, dup2, etc. rather than fcntl is wrong.",FALSE,FALSE,27,39,237,3,FALSE,TRUE,TRUE,TRUE,0,40,2
l0kod,"fd: c_inc",FALSE,TRUE,2,40,238,0,FALSE,FALSE,FALSE,TRUE,0,41,1
l0kod,"Preferable to use a dedicated fd_t type instead of c_int.",FALSE,TRUE,10,40,240,2,FALSE,TRUE,FALSE,TRUE,0,41,2
l0kod,"impl FileDesc {…pub fn read(&self, buffer: &mut [u8]) -> IoResult<uint> { ... }",FALSE,TRUE,13,40,241,3,FALSE,TRUE,FALSE,TRUE,0,41,3
l0kod,"Like I said previously, we should probably take care of file descriptor type (e.g. regular file, socket, directory) and their capabilities: it should not be possible to attempt a read on a directory file descriptor.",FALSE,TRUE,35,40,243,5,FALSE,TRUE,TRUE,TRUE,0,41,4
l0kod,"To avoid this, FileDesc should be a trait and an enum. Something like this:",FALSE,TRUE,14,40,245,7,FALSE,TRUE,TRUE,TRUE,0,41,5
l0kod,"E.g. the native::io::file::open should then return the previously defined IoResult<FileDesc>.",FALSE,TRUE,10,40,246,8,FALSE,TRUE,TRUE,TRUE,0,41,6
l0kod,"An important thing to keep in mind is that all files should be atomically O_CLOEXEC by default, so using dup, dup2, etc. rather than fcntl is wrong.",FALSE,TRUE,27,40,247,9,FALSE,TRUE,TRUE,TRUE,0,41,7
l0kod,"Right, dup3 can also do it but is a bit more newer.",FALSE,TRUE,12,40,249,11,FALSE,TRUE,FALSE,TRUE,0,41,8
thestinger,"@l0kod: F_DUPFD_CLOEXEC for fcntl is part of POSIX, and equivalent to dup with CLOEXEC. I don't think there's a standard equivalent for dup2, but yes, dup3 can be used on Linux.",FALSE,FALSE,31,41,251,1,FALSE,TRUE,FALSE,TRUE,0,42,1
thestinger,"If you do this with an enum, you're responsible for including every kind of file descriptor / handle. On Linux, that includes signalfd, eventfd, timerfd, epoll and more. It's not unsafe to call read on a file descriptor that's not readable, and a low-level type shouldn't be adding checks that aren't necessary for safety. There can be higher level abstractions, but that doesn't preclude having useful low-level functionality that it's built on.",FALSE,FALSE,72,42,253,1,FALSE,TRUE,TRUE,TRUE,0,43,1
thestinger,">>>tbu-, Contributor",FALSE,FALSE,2,42,254,2,FALSE,TRUE,FALSE,TRUE,0,43,2
thestinger,"Indeed, the whole point we wanted to achieve with this was compatiblity with low-level libraries in other languages – so wrapping it up as such an enum would have the wrong effect in my opinion.",FALSE,FALSE,35,42,256,4,FALSE,TRUE,FALSE,TRUE,0,43,3
l0kod,"OK, I missed some file descriptor types ;) but It's probably why fstat can return an unknown type.All 7 types (plus the unknown) are defined by POSIX.",FALSE,TRUE,27,43,257,0,FALSE,TRUE,FALSE,TRUE,0,44,1
l0kod,"wrapping it up as such an enum would have the wrong effect in my opinion.",FALSE,TRUE,15,44,258,0,FALSE,FALSE,FALSE,TRUE,0,45,1
l0kod,"Doesn't it one of the goal of static typing: to avoid confusion between different things?",FALSE,TRUE,15,44,259,1,FALSE,FALSE,FALSE,TRUE,0,45,2
l0kod,"I don't see why it would be a problem for binding with low-level library.",FALSE,TRUE,14,44,261,3,FALSE,TRUE,FALSE,TRUE,0,45,3
l0kod,">>>tbu-, Contributor",FALSE,TRUE,2,44,262,4,FALSE,TRUE,FALSE,TRUE,0,45,4
l0kod,"Because C doesn't understand these enums, it only  understands  the raw FileDesc type.",FALSE,TRUE,13,44,264,6,FALSE,TRUE,FALSE,TRUE,0,45,5
l0kod,"Yes, C understand the raw fd_t but the FFI goal is to wrap unsafe functions in safe ones. High level typing is not a problem.",FALSE,TRUE,25,45,266,1,FALSE,TRUE,FALSE,TRUE,0,46,1
thestinger,"By adding abstraction and typing restrictions, it's no longer a low-level library and can no longer express everything that you can in C. Exposing low-level functionality does not preclude having high-level abstractions built on top of them. It shouldn't go beyond what is necessary to achieve safety unless it's not making any use cases more difficult.",FALSE,FALSE,56,46,268,1,FALSE,TRUE,TRUE,TRUE,0,47,1
l0kod,"By adding abstraction and typing restrictions, it's no longer a low-level library and can no longer express everything that you can in C.",FALSE,TRUE,23,47,269,0,FALSE,TRUE,FALSE,TRUE,0,48,1
l0kod,"Yes, that's the goal of proper wrapping, to avoid errors :)",FALSE,TRUE,11,47,270,1,FALSE,FALSE,FALSE,TRUE,0,48,2
l0kod,"I don't see the difference of use between a single FileDesc and multiple ones with traits for low-level binding. The enum thing is not a problem if you use it for return value and take a trait for function argument.",FALSE,TRUE,40,47,272,3,FALSE,TRUE,FALSE,TRUE,0,48,3
l0kod,"The idea is that bindings who return file descriptors (e.g. open(2)) can tighten file descriptor type with fstat. Functions taking file descriptor as argument should use traits. Moreover, I don't see any problem if UnknownFd implement all traits. Am I missing something?",FALSE,TRUE,42,47,274,5,FALSE,TRUE,TRUE,TRUE,0,48,4
petrochenkov,"Plus to thestinger, I feel the primary goal is a possibility to use an operating system API in its entirety.And after that anybody can add, refine and discuss whatever abstractions and wrappers he wants.",FALSE,FALSE,34,48,276,1,FALSE,TRUE,FALSE,TRUE,0,49,1
l0kod,"Good news! libuv now support file descriptors: joyent/libuv#1435.",FALSE,TRUE,8,49,277,0,FALSE,TRUE,FALSE,TRUE,0,50,1
retep998,"Of particular note is that libuv provides HANDLE on Windows while Rust provides c_int file descriptors instead.",FALSE,FALSE,17,50,278,0,FALSE,TRUE,FALSE,TRUE,0,51,1
alexcrichton,"Closing due to inactivity. There are many changes planned to the I/O libraries, especially libnative. While these changes settle down over the coming weeks, something like this will definitely be included. I would recommend holding off to see how the new design of libnative works out.",FALSE,TRUE,46,51,279,0,FALSE,TRUE,FALSE,TRUE,0,52,1
alexcrichton,"The plan is to have high-level primitives in libstd which provide access to lower-level primitives in libnative which in turn provide access to the raw file descriptor/handle objects.",FALSE,TRUE,28,51,281,2,FALSE,TRUE,FALSE,TRUE,0,52,2
errordeveloper,"@alexcrichton I am definitely looking forward to see those changes. Is there a tracking issues for it?",FALSE,TRUE,17,52,282,0,TRUE,TRUE,FALSE,TRUE,0,53,1
alexcrichton,"I'd follow rust-lang/rfcs#219 which, although closed, will be updated with the next course of action.",FALSE,TRUE,15,53,283,0,FALSE,TRUE,FALSE,TRUE,0,54,1
aturon,"See (and please comment on!) this new RFC.",FALSE,FALSE,8,54,284,0,FALSE,TRUE,FALSE,TRUE,0,55,1
l0kod,"Merged RFC: https://github.com/rust-lang/rfcs/blob/master/text/0230-remove-runtime.md",FALSE,TRUE,3,55,285,0,FALSE,TRUE,FALSE,TRUE,0,56,1
l0kod,"Related issue: #17325.",FALSE,TRUE,3,55,286,1,FALSE,FALSE,FALSE,TRUE,0,56,2
l0kod,"New PR: #19169",FALSE,TRUE,3,56,287,0,FALSE,TRUE,FALSE,TRUE,0,57,1
