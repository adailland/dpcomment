% Generated by Discussion model rust.17583.txt
% File generated on 2017/08/02 15:59:32

@relation pr1501703972846

@attribute author String
@attribute textual String
@attribute isProjectMember {TRUE, FALSE}
@attribute isInvited {TRUE, FALSE}
@attribute numberOfWords numeric
@attribute commentsSoFar numeric
@attribute allUtterancesSoFar numeric
@attribute utterancesInCommentSoFar numeric
@attribute utteredByOriginalPoster {TRUE, FALSE}
@attribute hasCapitalizedWord {TRUE, FALSE}
@attribute containsShould {TRUE, FALSE}
@attribute hasDecisions {TRUE, FALSE}
@attribute howManyDecisions numeric
@attribute idComment numeric

@data
thestinger,"This begins the work towards a new TLS implementation. It will be usefulto have the initial work in-tree for test coverage across variousplatforms and to allow for collaborative work on the API. The currentfast implementation using #[thread_local] is expected to work onLinux, Windows (with #17563), OS X, FreeBSD and the current Androidversion (but not the bot).",FALSE,FALSE,56,0,0,0,TRUE,TRUE,FALSE,TRUE,0,1
thestinger,"Coming up with a good API will need to wait until there's a fullimplementation with destructor support (#17572) and a fallback path(#17579) for platforms like iOS and old versions of Android. A set of 6macros is probably not the ideal API... but it's an obvious way ofcovering all of the use cases with minimal overhead.",FALSE,FALSE,55,0,2,2,TRUE,TRUE,FALSE,TRUE,0,1
thestinger,"Closes #17569",FALSE,FALSE,2,0,3,3,TRUE,FALSE,FALSE,TRUE,0,1
rust-highfive,"These commits modify unsafe code. Please review it carefully!",FALSE,FALSE,9,1,5,1,FALSE,TRUE,FALSE,TRUE,0,2
thestinger,"cc @aturon, @alexcrichton, @brson",FALSE,FALSE,4,2,6,0,TRUE,FALSE,FALSE,TRUE,0,3
thestinger,"I do have a working implementation of destructors for recent Linux and OS X platforms, but I've left it out for now because I haven't written a slow fallback implementation or a way to deal with differences between platform versions via cfg. It looks like this at the moment:",FALSE,FALSE,49,3,7,0,TRUE,TRUE,FALSE,TRUE,0,4
thestinger,"The memory allocation is necessary due to lack of support for uninitialized mutable global variables and lack of a way to have global variables for types with destructors. The compiler wouldn't need to actually call the destructor, it would just need to ignore it. I think allowing that with a lint warning about it would make sense. Most types with destructors don't provide a constant initializer anyway.",FALSE,FALSE,67,3,8,1,TRUE,TRUE,FALSE,TRUE,0,4
pcwalton,"r? @alexcrichton",FALSE,FALSE,2,4,9,0,FALSE,FALSE,FALSE,TRUE,0,5
alexcrichton,"I'll take a closer look at this tomorrow when I have some more time, but as a high-level comment I'm a little wary about including bits in the standard distribution which don't really work across all platforms. We don't have much of a precedent for this beyond liblibc and some internal details of libnative, and I'd personally like to see the fallback implementation for platforms like android fleshed out before landing (but can certainly discuss this beforehand).",FALSE,TRUE,77,5,11,1,FALSE,TRUE,FALSE,TRUE,0,6
alexcrichton,"Another thing that I'm wary of is that the destructors for these values aren't ever run, and it's not super clear to me where they would be run. Opening an issue (#17572) about this is a great way to track it, but it's not immediately clear to me whether the proposed methods in the issue are feasible ways forward. I'd want to investigate scenarios like printing, failing, blocking, etc in destructors of TLS values in order to mark this api as safe.",FALSE,TRUE,82,5,12,2,FALSE,TRUE,FALSE,TRUE,0,6
alexcrichton,"At the last work week we also talked about a TLS implementation which did not take ownership of the value, but rather it was a sort of scope-based API where a value was only inserted into TLS for the scope of the lifetime of the object. That has a convenient side effect of not needing global initialization and destruction, which I found quite convenient! I'm not sure we took fantastic notes, but you can see what we did take.",FALSE,TRUE,79,5,13,3,FALSE,TRUE,FALSE,TRUE,0,6
alexcrichton,"As a final point, the distribution continues to officially support libgreen for the time being, and we want to consider other particular threading models when looking forward into the future. Currently these apis are not safe when used with libgreen, and it's unclear how they can be safe with any threading model other than 1:1 threads. This is largely just a point of whether these apis should be marked unsafe or not, but it is certainly something to consider.",FALSE,TRUE,79,5,15,5,FALSE,TRUE,TRUE,TRUE,0,6
alexcrichton,"Anyway, I'll review in detail tomorrow!",FALSE,TRUE,6,5,16,6,FALSE,TRUE,FALSE,TRUE,0,6
thestinger,"I'll take a closer look at this tomorrow when I have some more time, but as a high-level comment I'm a little wary about including bits in the standard distribution which don't really work across all platforms. We don't have much of a precedent for this beyond liblibc and some internal details of libnative, and I'd personally like to see the fallback implementation for platforms like android fleshed out before landing (but can certainly discuss this beforehand).",FALSE,FALSE,77,6,17,0,TRUE,TRUE,FALSE,TRUE,0,7
thestinger,"Android does actually support static TLS and I've verified that C++11 thread_local works on the tablet I have access to (Android 4.4.4). 64-bit iOS supports it too, so the problem is going to fade away. Since it's part of C11 and C++11, it can be expected that all future hosted platforms provide it.",FALSE,FALSE,53,6,19,2,TRUE,TRUE,FALSE,TRUE,0,7
thestinger,"I'll write the slow path for platforms without static TLS support (iOS, old Android versions) after the basics are in-tree and the API has been bikeshedded. There's nothing preventing an implementation of the current API on top of dynamic TLS, but the code is going to depend heavily on the API that's exposed. It's #[experimental] code so there is no backwards compatibility risk. There's no point in writing a bunch of low-level code for niche platforms that's likely going to need a complete rewrite. It will hold back improvements to the API.",FALSE,FALSE,92,6,20,3,TRUE,TRUE,FALSE,TRUE,0,7
thestinger,"Another thing that I'm wary of is that the destructors for these values aren't ever run, and it's not super clear to me where they would be run. Opening an issue (#17572) about this is a great way to track it, but it's not immediately clear to me whether the proposed methods in the issue are feasible ways forward. I'd want to investigate scenarios like printing, failing, blocking, etc in destructors of TLS values in order to mark this api as safe.",FALSE,FALSE,82,6,21,4,TRUE,TRUE,FALSE,TRUE,0,7
thestinger,"Types with destructors are not permitted in static mut variables so the API is entirely safe. C++11 implements static destruction for global and thread local variables in the compiler. Rust's compiler does not, so it would need to be done with separate macros using a dynamic allocation to hold the data and making use of dynamic TLS or lighter platform specific mechanisms (mentioned in the issue). I will implement destructor support in a follow-up pull request and it won't be hard to demonstrate that it is safe. As the issue states, support for TLS variables with destructors isn't implemented. It is not broken, although Rust's old local_data API is broken - it doesn't have memory safe destruction and there are other holes.",FALSE,FALSE,122,6,23,6,TRUE,TRUE,FALSE,TRUE,0,7
thestinger,"At the last work week we also talked about a TLS implementation which did not take ownership of the value, but rather it was a sort of scope-based API where a value was only inserted into TLS for the scope of the lifetime of the object. That has a convenient side effect of not needing global initialization and destruction, which I found quite convenient! I'm not sure we took fantastic notes, but you can see what we did take.",FALSE,FALSE,79,6,24,7,TRUE,TRUE,FALSE,TRUE,0,7
thestinger,"That may or may not be useful but it's not a replacement for this feature. Static thread-local storage is a hard requirement of a fast general purpose allocator and other library code reliant on thread caches for performance. A scoped implementation is an entirely different feature.",FALSE,FALSE,46,6,25,8,TRUE,TRUE,FALSE,TRUE,0,7
thestinger,"As a final point, the distribution continues to officially support libgreen for the time being, and we want to consider other particular threading models when looking forward into the future. Currently these apis are not safe when used with libgreen, and it's unclear how they can be safe with any threading model other than 1:1 threads. This is largely just a point of whether these apis should be marked unsafe or not, but it is certainly something to consider.",FALSE,FALSE,79,6,26,9,TRUE,TRUE,TRUE,TRUE,0,7
thestinger,"Setting up registers correctly on context switches and implementing dynamic TLS support is the responsibility of the green threading library. Not setting up the thread-local storage register is not the only problem with how libgreen implements context switches. It's missing support for other registers too but we still enable passes like auto-vectorization and allow work on SIMD. It's entirely possible for it to handle this stuff just like the C standard library does for native threads. To quote RFC 62, which was accepted:",FALSE,FALSE,83,6,28,11,TRUE,TRUE,FALSE,TRUE,0,7
thestinger,"Finally, a guiding principle for the above work is uncompromising support for native system APIs, in terms of both functionality and performance. For example, it must be possible to use thread-local storage without significant overhead, which is very much not the case today. Any abstractions to support M:N threading models -- including the now-external libgreen package -- must respect this constraint.",FALSE,FALSE,61,6,29,12,TRUE,TRUE,FALSE,TRUE,0,7
thestinger,"It's no longer the responsibility of the standard library to hold back progress for libgreen. The memory unsafety is caused by fixable implementation issues in that library, not this one. Even if it wasn't possible for these to co-exist (it is), the RFC permits moving forwards regardless.",FALSE,FALSE,47,6,30,13,TRUE,TRUE,FALSE,TRUE,0,7
alexcrichton,"Is it true that absolutely nothing is needed from a system libc to make this crate work? I would have expected LLVM to inject some silent dependencies, but that's pretty awesome if it works standalone!",FALSE,TRUE,35,7,32,1,FALSE,TRUE,FALSE,TRUE,0,8
thestinger,"It depends on a function provided by the linker in a dynamic library. In a static executable there are no external dependencies. Due to undefined behaviour in the standard library, Rust currently doesn't tell LLVM that it's not building a library so the linker call overhead isn't optimized out without -C dynamic-no-pic.",FALSE,FALSE,52,8,34,1,TRUE,TRUE,FALSE,TRUE,0,9
thestinger,"The fallback code for iOS / Android will add a dependency on libc though.",FALSE,FALSE,14,9,36,1,TRUE,TRUE,FALSE,TRUE,0,10
alexcrichton,"In general I'm not a huge fan of having a huge amount of code generated by macros, it's got downsides like being difficult to document, exposing implementation details, various hygiene issues, surprising access patterns, lack of macro import/export, etc.",FALSE,TRUE,39,10,38,1,FALSE,TRUE,FALSE,TRUE,0,11
alexcrichton,"I'm not sure if we currently have a better way of doing this, but it may be worth exploring possibilities like generating a static struct which has methods, or similar. If we have limitations which prevent that today, I'm curious what the minimum would be to get over that (if possible).",FALSE,TRUE,51,10,40,3,FALSE,TRUE,FALSE,TRUE,0,11
thestinger,"It could use a type but then it would end up defining both a type name and the variable name.",FALSE,FALSE,20,11,42,1,TRUE,TRUE,FALSE,TRUE,0,12
alexcrichton,"I was thinking something more along the lines of this library exports a type T which the macro crates static instances of T<U>, that way you can easily see what to do with a static via the documentation of libtls (where one might expect the documentation to live).",FALSE,TRUE,48,12,44,1,FALSE,TRUE,FALSE,TRUE,0,13
thestinger,"Rust isn't capable of doing it that way. It has no way to create a static from a generic type parameter.",FALSE,FALSE,21,13,46,1,TRUE,TRUE,FALSE,TRUE,0,14
alexcrichton,"These macros will probably need a pub variant as well to allow exporting the module. The syntax may also be more intuitive with something like:",FALSE,TRUE,25,14,48,1,FALSE,TRUE,FALSE,TRUE,0,15
thestinger,"Using pub tls_cell!(...) works, although that's a bit weird.",FALSE,FALSE,9,15,49,0,TRUE,TRUE,FALSE,TRUE,0,16
alexcrichton,"We don't currently have unsafe hygiene, so can this evaluate $init outside of an unsafe block? This also has some surprising semantics which aren't necessarily backwards compatible to change. By evaluating the expression in an inner module, it means that all paths have to be referenced with super:: which can sometimes be a little unfortunate.",FALSE,TRUE,55,16,51,1,FALSE,TRUE,FALSE,TRUE,0,17
thestinger,"I'll move it outside of the unsafe block and will try switching to a type-based definition to avoid a new module scope. If glob imports weren't broken, that would work :P.",FALSE,FALSE,31,17,53,1,TRUE,TRUE,FALSE,TRUE,0,18
alexcrichton,"Due to the compiler being able to re-order struct fields, I don't think that this is a valid cast.",FALSE,TRUE,19,18,54,0,FALSE,TRUE,FALSE,TRUE,0,19
thestinger,"The same thing applies to all of the types in core::raw. There are missing features making it impossible to avoid relying on an implementation detail like this.",FALSE,FALSE,27,19,55,0,TRUE,TRUE,FALSE,TRUE,0,20
alexcrichton,"The types in core::raw likely need #[repr(C)], but no matter what this is still a problem with this code, right?",FALSE,TRUE,20,20,56,0,FALSE,TRUE,FALSE,TRUE,0,21
thestinger,"The problem is the lack of a way to initialize RefCell in a static variable. This code is working around that problem by doing something that's currently perfectly safe - assuming that while the struct representation is not defined, it will not vary for a type defined a certain way. It's hardly the only unsafe code relying on guarantees that are not explicitly stated anywhere. If someone wants to add a feature like field randomization, then they need to improve the compiler implementation to avoid needing hacks like this. Support for unsafe fields would do it, as would the ability to override privacy in unsafe code - we already allow overriding privacy in safe code via {:?}.",FALSE,FALSE,117,21,58,1,TRUE,TRUE,FALSE,TRUE,0,22
alexcrichton,"If the intention of this is to be the lowest-level cross-platform implementation of a TLS value, then it may be worth having an unsafe primitive from which to build the other primitives on top of. It may not work out, but we've benefited in the past from stripping away all layers of abstraction (even Cell and RefCell) and exposing the underlying unsafe internals for manipulation. It may also help reduce duplication between these macros, provide an easy entrypoint for a non-#[thread_local] implementation, etc.",FALSE,TRUE,83,22,60,1,FALSE,TRUE,FALSE,TRUE,0,23
alexcrichton,"What was the reasoning behind moving this to a separate crate? Was it because of the macros-in-prelude issues with the standard library?",FALSE,TRUE,22,22,62,3,FALSE,TRUE,FALSE,TRUE,0,23
alexcrichton,"From an API point of view, it would be nice to unify all these macro invocations and rationalize them with the existing statics. I would personally think that declaring a TLS static would be very similar to the declaration of a normal static (or static mut). Considering rust-lang/rfcs#246:",FALSE,TRUE,48,22,64,5,FALSE,TRUE,FALSE,TRUE,0,23
alexcrichton,"That's kinda just a sketch, it's more of conceptually what I might expect out of the TLS implementation from the standard distribution. I'm not sure how far along that tangent this can go, but it's also kinda just along the lines of an absolute bare-bones implementation which imposes 0 overhead, but may be unsafe still. From that perhaps we could build up a tls_cell/tls_refcell macro?",FALSE,TRUE,65,22,65,6,FALSE,TRUE,FALSE,TRUE,0,23
alexcrichton,"Just some ideas, I'm curious what you think about them. Also, in general I don't really want to consider the standard distribution to be a ground where  anything goes if it's experimental . We're trying to cut down in scope for a 1.0 release, and most things currently marked as experimental are either  not triaged  or  triaged, and we'd really like to find a replacement, but we just can't remove this . I suspect that a TLS implementation is in the category of  we'd really like to have this , but as long as it's backwards compatible to add it's not super urgent that it land now.",FALSE,TRUE,104,22,67,8,FALSE,TRUE,FALSE,TRUE,0,23
Valloric,"You may want to reword the PR title to make it clear that this is about Thread Local Storage, not Transport Layer Security. It had me going for a minute.",FALSE,FALSE,30,23,68,0,FALSE,TRUE,FALSE,TRUE,0,24
thestinger,"What was the reasoning behind moving this to a separate crate? Was it because of the macros-in-prelude issues with the standard library?",FALSE,FALSE,22,24,69,0,TRUE,TRUE,FALSE,TRUE,0,25
thestinger,"Yes, it's to work around not being able to mark macros as experimental. Instead, the crate as a whole can be marked experimental and then deprecated with the functionality moved to the standard library when it's finished.",FALSE,FALSE,37,24,71,2,TRUE,TRUE,FALSE,TRUE,0,25
thestinger,"That's kinda just a sketch, it's more of conceptually what I might expect out of the TLS implementation from the standard distribution. I'm not sure how far along that tangent this can go, but it's also kinda just along the lines of an absolute bare-bones implementation which imposes 0 overhead, but may be unsafe still. From that perhaps we could build up a tls_cell/tls_refcell macro?",FALSE,FALSE,65,25,72,0,TRUE,TRUE,FALSE,TRUE,0,26
thestinger,"It would make sense to factor out the portability shim for iOS / old Android like that. Since I hadn't started on it I didn't bother trying. The details of the portable implementation won't impact the higher-level safe wrappers but it would play into the design of the unsafe API.",FALSE,FALSE,50,25,74,2,TRUE,TRUE,FALSE,TRUE,0,26
thestinger,"Just some ideas, I'm curious what you think about them. Also, in general I don't really want to consider the standard distribution to be a ground where  anything goes if it's experimental . We're trying to cut down in scope for a 1.0 release, and most things currently marked as experimental are either  not triaged  or  triaged, and we'd really like to find a replacement, but we just can't remove this . I suspect that a TLS implementation is in the category of  we'd really like to have this , but as long as it's backwards compatible to add it's not super urgent that it land now.",FALSE,FALSE,104,25,75,3,TRUE,TRUE,FALSE,TRUE,0,26
thestinger,"Rust is going to need thread-local storage, and developing it in-tree means the tests will be run to prevent regressions and it won't bitrot. It also makes it sane for more than one person to put work into it because it won't be getting rebased over and over.",FALSE,FALSE,48,25,77,5,TRUE,TRUE,FALSE,TRUE,0,26
thestinger,"From an API point of view, it would be nice to unify all these macro invocations and rationalize them with the existing statics. I would personally think that declaring a TLS static would be very similar to the declaration of a normal static (or static mut). Considering rust-lang/rfcs#246:",FALSE,FALSE,48,26,78,0,TRUE,TRUE,FALSE,TRUE,0,27
thestinger,"If having static X: RefCell<TypeWithDestructor> where you are allowed to store a type with a destructor is actually possible, then it could work. It can't be implemented that way right now though. The low-level shim will need to support implementing thread-local destructors on top, and ideally with minimal overhead like C++11 (no indirection via raw pointers).",FALSE,FALSE,56,26,80,2,TRUE,TRUE,FALSE,TRUE,0,27
alexcrichton,"With C++, you also have global initialization and destruction of statics, and I don't believe that we don't expose this for technical reasons, but moreso safety/engineering/etc reasons. I view this as similar to TLS statics in that where it is definitely possible, we may choose to not expose it at this time (to keep the two in sync).",FALSE,TRUE,58,27,82,1,FALSE,TRUE,FALSE,TRUE,0,28
thestinger,"@alexcrichton: There are no safety or engineering reasons to avoid exposing destructors for TLS. It would make the API crippled relative to C++. It would be unusable for something like a general purpose allocator without a way to clean up the data. I don't see why Rust should settle for a lower quality TLS implementation than C++11.",FALSE,FALSE,57,28,84,1,TRUE,TRUE,TRUE,TRUE,0,29
thestinger,"Current Android versions and 64-bit iOS (iPhone 5S / iOS7 and later) support TLS so I don't consider the lack of a fallback to be a pressing issue. The only relevant versions of iOS for Rust will be 64-bit, so the only loss would be not working within legacy 32-bit software targeting a 64-bit OS.",FALSE,FALSE,55,29,86,1,TRUE,TRUE,FALSE,TRUE,0,30
thestinger,"I fixed the one soundness issue involving lack of unsafe hygiene. It's already a useful, safe API and I plan on continuing to expand / improve it once it's in-tree. Any further work on it is blocked on having an assurance that it won't be rejected or it being in-tree so I can iterate via new pull requests. I don't enjoy waiting weeks to progress anywhere on any non-trivial work.",FALSE,FALSE,70,30,87,0,TRUE,TRUE,FALSE,TRUE,0,31
vhbit,"Currently the only supported iOS version is 32 bit and I think atleast till the next year it MUST be supported as 4S is still widelyused",FALSE,FALSE,26,31,89,1,FALSE,TRUE,FALSE,TRUE,0,32
vhbit,"But since 32bit is fading away - I can suggest unsafe option, we had adiscussion about it with Alex before merging - there is a faster TLS,undocumented method extracted from libc sources, definitely unsafe,but considering timeframe of 32bit OS - it might be worth trying.",FALSE,FALSE,45,31,90,2,FALSE,TRUE,FALSE,TRUE,0,32
thestinger,"I could implement this API for it, but I have no way to test it because there is no Rust bot. Someone with access to iOS can do it after this lands. In-tree development means people can collaborate. It seems that privilege is reserved for people who work for Mozilla though.",FALSE,FALSE,51,32,91,0,TRUE,TRUE,FALSE,TRUE,0,33
vhbit,"I can test it on iOS 32 and I can do it out of tree - as I maintain iOS onworking state for internal projects and build it anyway.",FALSE,FALSE,29,33,92,0,FALSE,TRUE,FALSE,TRUE,0,34
eddyb,"@alexcrichton @aturon Is there anything blocking this, or can it be merged as a first step?",FALSE,FALSE,16,34,93,0,FALSE,TRUE,FALSE,TRUE,0,35
alexcrichton,"@eddyb, I'd like to point out again that as part of library stabilization we're trying to cut down on the surface area of the standard distribution. I, however, also believe that everyone is in alignment that we'd like to have a nice TLS implementation.",FALSE,TRUE,44,35,95,1,FALSE,TRUE,FALSE,TRUE,0,36
alexcrichton,"I would also like to point out that there is nothing stopping this from being a cargo package which could be quickly iterated on. The benefit of being a cargo package is also that quicker iteration is allowed (bors isn't exactly speedy), versioning is independent from Rust itself, and other implementations can have more interoperability. The downsides, of course, of being a cargo package are that it is not updated automatically when breaking changes are made and discoverability is currently difficult. The breaking changes part will alleviate as Rust becomes more stable, and the discoverability will alleviate once we have a central Registry (working quite hard on it right now!).",FALSE,TRUE,110,35,97,3,FALSE,TRUE,FALSE,TRUE,0,36
alexcrichton,"I'm not saying that this shouldn't be in the standard distribution, I'd just like to point out that this implementation is not dead in the water if we don't merge it at this time.",FALSE,TRUE,34,35,98,4,FALSE,TRUE,TRUE,TRUE,0,36
alexcrichton,"Specifically speaking, I don't think any of my concerns have been addressed, I'll reiterate them below for clarity. I hope this answers your question about what is blocking this PR.",FALSE,TRUE,30,35,99,5,FALSE,TRUE,FALSE,TRUE,0,36
alexcrichton,"Leveraging macros for generating the entire implementation",FALSE,TRUE,7,35,101,7,FALSE,TRUE,FALSE,TRUE,0,36
alexcrichton,"In general I'm not a huge fan of having a huge amount of code generated by macros, it's got downsides like being difficult to document, exposing implementation details, various hygiene issues, surprising access patterns, lack of macro import/export, etc.",FALSE,TRUE,39,35,102,8,FALSE,TRUE,FALSE,TRUE,0,36
alexcrichton,"Incorrect casting",FALSE,TRUE,2,35,104,10,FALSE,TRUE,FALSE,TRUE,0,36
alexcrichton,"Due to the compiler being able to re-order struct fields, I don't think that this is a valid cast.",FALSE,TRUE,19,35,105,11,FALSE,TRUE,FALSE,TRUE,0,36
alexcrichton,"Inconsistency with existing statics today",FALSE,TRUE,5,35,106,12,FALSE,TRUE,FALSE,TRUE,0,36
alexcrichton,"From an API point of view, it would be nice to unify all these macro invocations and rationalize them with the existing statics.",FALSE,TRUE,23,35,107,13,FALSE,TRUE,FALSE,TRUE,0,36
alexcrichton,"There are also some broader concerns which I was going to bring up once some of the above concerns were addressed:",FALSE,TRUE,21,35,108,14,FALSE,TRUE,FALSE,TRUE,0,36
alexcrichton,"There is no documentation as part of this PR",FALSE,TRUE,9,35,110,16,FALSE,TRUE,FALSE,TRUE,0,36
alexcrichton,"This is currently not cross-platform to all of Rust's supported platforms",FALSE,TRUE,11,35,112,18,FALSE,TRUE,FALSE,TRUE,0,36
alexcrichton,"Both of these points, while somewhat minor, are important in terms of being integrated with the standard distribution. There are also precisely where a cargo package may also help because arbitrary cargo packages don't have the same restriction requirements as the standard library.",FALSE,TRUE,43,35,113,19,FALSE,TRUE,FALSE,TRUE,0,36
alexcrichton,"As-is, I would be uneasy to merge this mostly because of the inconsistency with existing statics today. This is duplicating exactly how Cell and RefCell work, but in statics. In the past when we've had duplicate functionality we have always found the need to consolidate it (such as MutexArc and Arc, for example). This seems like a pretty clear location where the storage (TLS) should be separated from the type itself (Cell/RefCell).",FALSE,TRUE,72,35,115,21,FALSE,TRUE,TRUE,TRUE,0,36
alexcrichton,"If there are technical problems blocking this goal, then those seem like challenges to overcome rather than to start officially supporting an API we would just wish to change later. Note that this is also precisely where a Cargo package helps because the package could have an entirely separate interface and be slowly deprecated over time if language changes elsewhere enable a better API.",FALSE,TRUE,64,35,116,22,FALSE,TRUE,FALSE,TRUE,0,36
alexcrichton,"That may sound all quite vague, so I would like to give an outline of an api which I think would address my concerns:",FALSE,TRUE,24,35,117,23,FALSE,TRUE,FALSE,TRUE,0,36
alexcrichton,"This addresses these concerns:",FALSE,TRUE,4,35,118,24,FALSE,TRUE,FALSE,TRUE,0,36
alexcrichton,"The interface is easily documentable. The documentation is placed on the Tls struct as well as the get method, and then there are examples showing how the Tls struct may only be constructed via the macro. Also, bounds can be placed on T to ensure that it's Copy or doesn't have destructors, etc.",FALSE,TRUE,53,35,120,26,FALSE,TRUE,FALSE,TRUE,0,36
alexcrichton,"There is no longer a macro generating a wad of code in a different namespace. All expressions are evaluated in the namespace they're declared in.",FALSE,TRUE,25,35,122,28,FALSE,TRUE,FALSE,TRUE,0,36
alexcrichton,"This is composable with existing types. For example you can have a tls UnsafeCell, or you can have a totally unsafe static mut with tls. You're not forced into Cell or RefCell if you don't want to. The purpose of Tls is to provide a bare bones abstraction over the platform's best TLS solution, be that #[thread_local], pthreads, or TlsGetValue.",FALSE,TRUE,60,35,124,30,FALSE,TRUE,FALSE,TRUE,0,36
alexcrichton,"This continues (as does the current design) to provide a way to fall back to an OS-based TLS implementation.",FALSE,TRUE,19,35,125,31,FALSE,TRUE,FALSE,FALSE,1,36
alexcrichton,"The current story for stability of macros at 1.0 is somewhat in flux, and a type/struct-based solution (instead of a 100% macro-based solution) is more likely to be available than the macro-based version.",FALSE,TRUE,33,35,126,32,FALSE,FALSE,FALSE,TRUE,0,36
alexcrichton,"There are a number of tweaks which would have to be made to the compiler to make this work, however:",FALSE,TRUE,20,35,127,33,FALSE,FALSE,FALSE,TRUE,0,36
alexcrichton,"Privacy hygiene with respect to static initialization would have to be implemented. This is wanted regardless for UnsafeCell<T>, and it would provide a nice way to provide static constructors of generic items. For example there could be a static constructor of Mutex<T> through a macro. In general this is solve much better through CTFE (or something similar), but we may be able to settle for a macro-based solution for now.",FALSE,TRUE,70,35,129,35,FALSE,TRUE,FALSE,TRUE,0,36
alexcrichton,"Safe access to a non-Sync #[thread_local] static would have to be allowed, this is fairly trivial to do.",FALSE,TRUE,18,35,130,36,FALSE,FALSE,FALSE,TRUE,0,36
alexcrichton,"And, of course, there are a number of cons to this solution:",FALSE,TRUE,12,35,131,37,FALSE,FALSE,FALSE,TRUE,0,36
alexcrichton,"This does not allow dynamic initialization or construction. Note, however, that this is consistent with the rest of Rust globals today. It is certainly an extension that can be added in the future, but I think we should add it to both static and thread local globals at the same time. Singling one out as special seems odd.",FALSE,TRUE,58,35,133,39,FALSE,TRUE,TRUE,TRUE,0,36
alexcrichton,"In general I would like to reiterate that no one doesn't want a good TLS interface. The practice which we've been encouraging for new functionality in the standard library is for it to be developed out of tree, and then migrate it in-tree if possible. This helps us promote faster iteration of libraries such as this along with reducing the surface area of the standard library that needs to be stable for 1.0 (which is quite soon!).",FALSE,TRUE,77,35,135,41,FALSE,TRUE,FALSE,TRUE,0,36
alexcrichton,"Also, @thestinger, after re-reading many of the comments in this thread I've noticed that you've added to them in many cases. Would you be ok pinging the issue when you update a comment? Github doesn't send out any notifications, so I won't know to check back on this thread if you update a past comment. I was, for example, completely unaware that you pasted bits and pieces about construction/destruction.",FALSE,TRUE,69,35,136,42,FALSE,TRUE,FALSE,TRUE,0,36
wycats,"@thestinger docs and support for all supported platforms seem like blockers. Any reason not to iterate on this as a Cargo package?",FALSE,FALSE,22,36,138,1,FALSE,TRUE,FALSE,TRUE,0,37
wycats,"You mentioned mandatory compiler support. Can you say more about that? Maybe you can get what you need on that front without having to do all the design and iteration on master.",FALSE,FALSE,32,36,139,2,FALSE,TRUE,FALSE,TRUE,0,37
thestinger,"@wycats: The current TLS implementation in the repository needs to be replaced or removed. It's used throughout the implementation despite being incredibly slow and bloated. This does cover all officially supported platforms already - it works on Windows, OS X, Linux, and Android. It does not work on 32-bit iOS but that has never been officially supported / tested.",FALSE,TRUE,59,37,141,1,TRUE,TRUE,FALSE,TRUE,0,38
wycats,"@thestinger did you test it on Linux 2.6.18 and glibc 2.5 (the oldest supported platforms)?",FALSE,TRUE,15,38,142,0,FALSE,TRUE,FALSE,TRUE,0,39
thestinger,"@wycats: It passed tests on the Linux builder and __thread has been solid for years on Linux.",FALSE,TRUE,17,39,143,0,TRUE,TRUE,FALSE,TRUE,0,40
thestinger,"Static TLS on Linux dates back to 2001-2003. It is a standard feature in C11 and C++11 implemented on all major platforms. This is not bleeding edge stuff. It is a basic feature expected of a systems language, and Rust is falling far short of the competitors here.",FALSE,TRUE,48,40,145,1,TRUE,TRUE,FALSE,TRUE,0,41
wycats,"@thestinger also, it would be really helpful (at least to me) if you responded to @alexcrichton's specific questions. He did a pretty thorough review and your reply is pretty dismissive of what seems like a good-faith effort to have a discussion about your patch.",FALSE,TRUE,44,41,146,0,FALSE,TRUE,FALSE,TRUE,0,42
thestinger,"@wycats: Can you please quote this reply you're calling  dismissive ?",FALSE,TRUE,10,42,147,0,TRUE,TRUE,FALSE,TRUE,0,43
wycats,"@thestinger maybe  dismissive  means something stronger to you than I meant.",FALSE,TRUE,11,43,148,0,FALSE,TRUE,FALSE,TRUE,0,44
wycats,"What I meant was that @alexcrichton wrote a long, thoughtful and detailed review of your patch, and your response reiterated what everyone already knows: that the current implementation is not very good and needs to be replaced.",FALSE,TRUE,37,43,149,1,FALSE,TRUE,FALSE,TRUE,0,44
wycats,"I would honestly really appreciate responses to his specific review.",FALSE,TRUE,10,43,150,2,FALSE,FALSE,FALSE,TRUE,0,44
thestinger,"@wycats: You haven't given me time to respond. I opened this thread and was going to respond to @alexcrichton until you started throwing accusations around.",FALSE,TRUE,25,44,151,0,TRUE,TRUE,FALSE,TRUE,0,45
alexcrichton,"Sadly our auto/try bots are not CentOS 5.10 (the old linux we test on), just the snapshot builders are. I have manually verified, however, that #[thread_local] at least passes a smoke test on CentOS 5.10 on both 32/64 bit. That should address @wycats's concern about 2.6.18",FALSE,TRUE,46,45,152,0,FALSE,TRUE,TRUE,TRUE,0,46
alexcrichton,"@thestinger I know we've had trouble with #[thread_local] in the past on windows, so I tested this locally with the most recently night. A smoke test (thread local static mut, just prints it), ran fine on 64-bit windows, but it segfaulted on 32-bit windows. Did you verify both architectures? If so, perhaps my install of msys/msys2 is broken? If we need to tweak our mingw/msys requirements that's probably fine, but we just need to be prepared to do so ahead of time.",FALSE,TRUE,82,45,154,2,FALSE,TRUE,FALSE,TRUE,0,46
alexcrichton,"I'd also like to point out that std::local_data is #[experimental] today, and it's highly unlikely that that will ever change (other than to become #[deprecated]). The continued usage of it is purely historical, and one of the current plans about the release channel of rust is to make it impossible to reach #[experimental] code, which would make it impossible to use std::local_data in stable code. Note, however, that these plans are developing over time.",FALSE,TRUE,74,45,156,4,FALSE,TRUE,FALSE,TRUE,0,46
wycats,"@thestinger apologies if something I said looked accusatory. I was just making an observation that @alexcrichton wrote a fairly long review of the patch, and your reply to his comments seemed curt. It sounds like you didn't mean it that way, though!",FALSE,TRUE,42,46,157,0,FALSE,TRUE,FALSE,TRUE,0,47
wycats,"Looking forward to a fuller response. Like you, I would like to see a better TLS implementation in libstd.",FALSE,TRUE,19,46,158,1,FALSE,TRUE,FALSE,TRUE,0,47
alexcrichton,"I also just tested this out on the android toolchain that I had lying around, it's the same smoke test of thread local static mut followed by a print, and I got this error:",FALSE,TRUE,34,47,160,1,FALSE,TRUE,FALSE,TRUE,0,48
alexcrichton,"The key part of the error I think being: undefined reference to '__tls_get_addr'. This seems quite similar to #10842! We could take two courses of action here:",FALSE,TRUE,27,47,162,3,FALSE,TRUE,FALSE,TRUE,0,48
alexcrichton,"Raise the minimum required android version. This would require figuring out precisely what version of android enabled #[thread_local] globals and making the decision from there (I know very little about android).",FALSE,TRUE,31,47,163,4,FALSE,TRUE,FALSE,TRUE,0,48
alexcrichton,"Implement the fallback path",FALSE,TRUE,4,47,164,5,FALSE,FALSE,FALSE,TRUE,0,48
alexcrichton,"I suspect the sub-question in in route 1 will give us more information and will help guide this decision. @thestinger, would you be ok figuring out what the minimum version of android is to implement TLS in this fashion?",FALSE,TRUE,39,47,165,6,FALSE,TRUE,FALSE,TRUE,0,48
thestinger,"@wycats: I didn't reply to his comments, I was replying to you.",FALSE,TRUE,12,48,166,0,TRUE,TRUE,FALSE,TRUE,0,49
thestinger,"I'd like to point out again that as part of library stabilization we're trying to cut down on the surface area of the standard distribution. I, however, also believe that everyone is in alignment that we'd like to have a nice TLS implementation.",FALSE,TRUE,43,49,167,0,TRUE,TRUE,FALSE,TRUE,0,50
thestinger,"It's far smaller than the surface area of the existing TLS implementation and will be able to replace it. It needs support for destructors to replace it and that's a bit tricky to do correctly - the existing implementation does it unsoundly. It deserves to be landed separately, and then there will be platform-specific optimizations to leverage features like _tlv_atexit on OS X that were added for C++11 support. This will certainly require compiler support because it's not currently possible to detect these features.",FALSE,TRUE,84,49,169,2,TRUE,TRUE,FALSE,TRUE,0,50
thestinger,"I would also like to point out that there is nothing stopping this from being a cargo package which could be quickly iterated on. The benefit of being a cargo package is also that quicker iteration is allowed (bors isn't exactly speedy), versioning is independent from Rust itself, and other implementations can have more interoperability. The downsides, of course, of being a cargo package are that it is not updated automatically when breaking changes are made and discoverability is currently difficult. The breaking changes part will alleviate as Rust becomes more stable, and the discoverability will alleviate once we have a central Registry (working quite hard on it right now!).",FALSE,TRUE,110,50,170,0,TRUE,TRUE,FALSE,TRUE,0,51
thestinger,"TLS is used within the standard libraries (task-local RNG) and compiler. A replacement of the old TLS implementation needs to be done in-tree.",FALSE,TRUE,23,50,172,2,TRUE,TRUE,FALSE,TRUE,0,51
thestinger,"I'm not saying that this shouldn't be in the standard distribution, I'd just like to point out that this implementation is not dead in the water if we don't merge it at this time.",FALSE,TRUE,34,51,173,0,TRUE,TRUE,TRUE,TRUE,0,52
thestinger,"It's already in the standard distribution as local_data_key!, local_ptr and more. It's a replacement of the old implementation as part of removing the dynamic runtime and fixing unsoundness / performance issues, not a new feature.",FALSE,TRUE,35,51,175,2,TRUE,TRUE,FALSE,TRUE,0,52
thestinger,"Specifically speaking, I don't think any of my concerns have been addressed, I'll reiterate them below for clarity. I hope this answers your question about what is blocking this PR.",FALSE,TRUE,30,52,176,0,TRUE,TRUE,FALSE,TRUE,0,53
thestinger,"I did address your concerns. Perhaps you weren't satisfied with the replies, but I'm not convinced that these are serious / blocking issues.",FALSE,TRUE,23,52,177,1,TRUE,TRUE,FALSE,TRUE,0,53
thestinger,"Leveraging macros for generating the entire implementation",FALSE,TRUE,7,53,178,0,TRUE,TRUE,FALSE,TRUE,0,54
thestinger,"There isn't a proposed alternative with the same flexibility and performance. Using macros makes it possible to sanely support destructors and implement a fallback path. It's an #[experimental] API meant to be a step towards replacing the old TLS implementation, not a finalized / stable API based on lessons learned during implementation and usage.",FALSE,TRUE,54,53,180,2,TRUE,TRUE,FALSE,TRUE,0,54
thestinger,"Incorrect casting",FALSE,TRUE,2,54,181,0,TRUE,TRUE,FALSE,TRUE,0,55
thestinger,"I guess you weren't satisfied with my answer? As I pointed out, this is not incorrect with the current implementation of the compiler. It would not be incorrect if fields were reordered based on size and aligned. It's a workaround that's used throughout the standard libraries already and I think it would be unreasonable to change the compiler implementation in a way that would prevent working around issues like the inability to statically initialize a RefCell.",FALSE,TRUE,76,54,183,2,TRUE,TRUE,FALSE,TRUE,0,55
thestinger,"Inconsistency with existing statics today",FALSE,TRUE,5,55,184,0,TRUE,TRUE,FALSE,TRUE,0,56
thestinger,"The ultimate solution is a fully working #[thread_local]. It's provided by C, C++, D and other systems languages that Rust is competing with. It's a stopgap until that is possible (if it ever is) and could be reimplemented on top of it. You've proposed possible improvements but you need to take the destructor handling and other issues like efficiency into account. It's not possible to do things like creating an uninitialized global variable or statically initializing types from other modules with private fields so workarounds are necessary.",FALSE,TRUE,87,55,186,2,TRUE,TRUE,FALSE,TRUE,0,56
thestinger,"If there are technical problems blocking this goal, then those seem like challenges to overcome rather than to start officially supporting an API we would just wish to change later. Note that this is also precisely where a Cargo package helps because the package could have an entirely separate interface and be slowly deprecated over time if language changes elsewhere enable a better API.",FALSE,TRUE,64,56,187,0,TRUE,TRUE,FALSE,TRUE,0,57
thestinger,"There is already a TLS implementation in-tree and it needs to be replaced. It would be better to stabilize this API than the one we already have that's unsound and incredibly slow. However, this is explicitly marked as #[experimental] and I have stated that it is not the finalized API but rather a base to build on in the subsequent pull requests I already have lined up. I have destructor support and other improvements ready but it's too difficult to land it all at once.",FALSE,TRUE,85,56,189,2,TRUE,TRUE,FALSE,TRUE,0,57
thestinger,"This does not allow dynamic initialization or construction. Note, however, that this is consistent with the rest of Rust globals today. It is certainly an extension that can be added in the future, but I think we should add it to both static and thread local globals at the same time. Singling one out as special seems odd.",FALSE,TRUE,58,57,190,0,TRUE,TRUE,TRUE,TRUE,0,58
thestinger,"TLS needs support for dynamic initialization and destruction to be usable. It is completely unrelated to those features in globals because the implementation and semantics are much different. There are no safety or ordering issues with it. It is required to replace the current TLS implementation which already supports those features. Why are my pull requests singled out for the application of all of these strict double standards?",FALSE,TRUE,68,57,192,2,TRUE,TRUE,FALSE,TRUE,0,58
thestinger,"In general I would like to reiterate that no one doesn't want a good TLS interface. The practice which we've been encouraging for new functionality in the standard library is for it to be developed out of tree, and then migrate it in-tree if possible. This helps us promote faster iteration of libraries such as this along with reducing the surface area of the standard library that needs to be stable for 1.0 (which is quite soon!).",FALSE,TRUE,77,58,193,0,TRUE,TRUE,FALSE,TRUE,0,59
thestinger,"TLS is already a feature that's in-tree and replacing the implementation was accepted in an RFC. I went ahead with a simplistic initial implementation to iterate on in-tree because I had already put substantial thought and effort into it. The surface area claim doesn't make any sense because it's going to replace a far larger unsound TLS implementation.",FALSE,TRUE,58,58,195,2,TRUE,TRUE,FALSE,TRUE,0,59
thestinger,"The API is marked #[experimental] and I've explicitly stated that there are improvements I want to make to this after it lands. It's the base I am going to build on in the follow-up commits I had lined up to submit after this landed (destructor support, portability to old Android).",FALSE,TRUE,50,58,196,3,TRUE,TRUE,FALSE,TRUE,0,59
thestinger,"Most possible improvements are blocked on fixing compiler bugs and compiler / language limitations such as the lack of a way to make an uninitialized global variable, inability to store a type with a destructor directly in a static mut (calling the destructor is unnecessary, just allowing Option<T> initialized to None where T has a destructor) and various other issues.",FALSE,TRUE,60,58,198,5,TRUE,TRUE,FALSE,TRUE,0,59
thestinger,"@thestinger I know we've had trouble with #[thread_local] in the past on windows, so I tested this locally with the most recently night. A smoke test (thread local static mut, just prints it), ran fine on 64-bit windows, but it segfaulted on 32-bit windows. Did you verify both architectures? If so, perhaps my install of msys/msys2 is broken? If we need to tweak our mingw/msys requirements that's probably fine, but we just need to be prepared to do so ahead of time.",FALSE,TRUE,82,59,199,0,TRUE,TRUE,FALSE,TRUE,0,60
thestinger,"I identified the problem on Windows and fixed it in 6bb648f. The problem was just that the MinGW-w64 linker's implementation of ASLR is thoroughly broken. It seems to work fine on 32-bit too...",FALSE,TRUE,33,59,201,2,TRUE,TRUE,FALSE,TRUE,0,60
thestinger,"@alexcrichton: I don't know which version of Android started having working TLS. I do know that the __tls_get_addr problem would be solved for TLS in executables and static libraries by telling LLVM when we are building an executable. It is not currently possible because the existing TLS implementation and libgreen depend on undefined behaviour that's broken by the optimizations LLVM uses when it's informed of that. If the existing TLS implementation was removed, my pull request changing that could land and you wouldn't get that error.",FALSE,TRUE,86,60,203,1,TRUE,TRUE,FALSE,TRUE,0,61
thestinger,"@alexcrichton: __tls_get_addr is now limited dynamically linked Rust libraries. We could easily provide an implementation on top of POSIX TLS in that case for old versions of Android and legacy 32-bit iOS. AFAIK, #[thread_local] with static linking will now work even on old versions of Android.",FALSE,TRUE,46,61,205,1,TRUE,TRUE,FALSE,TRUE,0,62
thestinger,"Closing for now. I've filed #18004 about this and will submit the same changes in a different order than I planned.",FALSE,TRUE,21,62,206,0,TRUE,TRUE,FALSE,TRUE,0,63
alexcrichton,"It's far smaller than the surface area of the existing TLS implementation and will be able to replace it.",FALSE,TRUE,19,63,207,0,FALSE,TRUE,FALSE,TRUE,0,64
alexcrichton,"I'd love to be able to replace the current std::local_data! I wouldn't exactly classify the API as large though, it's largely just a macro and two functions (replace/get).",FALSE,TRUE,28,63,208,1,FALSE,TRUE,FALSE,TRUE,0,64
alexcrichton,"It needs support for destructors to replace it and that's a bit tricky to do correctly.",FALSE,TRUE,16,63,209,2,FALSE,FALSE,FALSE,TRUE,0,64
alexcrichton,"I agree! We may be able to get by without implementing destructor support, however, by using the scoped-approach that we laid out in the work week. The  unsafe building block  could serve as the foundation for that strategy of TLS. The compiler is essentially entirely scoped, and the other major use case I know about is the task-local RNG which could probably be implemented specially.",FALSE,TRUE,65,63,211,4,FALSE,TRUE,FALSE,TRUE,0,64
alexcrichton,"the existing implementation does it unsoundly",FALSE,TRUE,6,63,212,5,FALSE,FALSE,FALSE,TRUE,0,64
alexcrichton,"That's not good! Can you open a bug on this?",FALSE,TRUE,10,63,213,6,FALSE,TRUE,FALSE,TRUE,0,64
alexcrichton,"There isn't a proposed alternative with the same flexibility and performance.",FALSE,TRUE,11,63,214,7,FALSE,FALSE,FALSE,TRUE,0,64
alexcrichton,"Can you explain to me why you didn't think my example would provide either the flexibility or performance?",FALSE,TRUE,18,63,215,8,FALSE,FALSE,FALSE,TRUE,0,64
alexcrichton,"I guess you weren't satisfied with my answer? As I pointed out, this is not incorrect with the current implementation of the compiler.",FALSE,TRUE,23,63,216,9,FALSE,TRUE,FALSE,TRUE,0,64
alexcrichton,"I didn't really see  it's not a worry  as an answer to the fact that struct layout is undefined. We are reserving the right to reorder struct fields at will, not only for performance but perhaps randomly for security. Today a Vec is also three words, but we're also not encouraging transmuting from a Vec to three words and back. It was tough for me to see how we could not rely the field orderings of the two structs being the same, so I was worried about coming to rely on this fact and being unable to pursue various optimizations in the future with struct field orderings.",FALSE,TRUE,107,63,217,10,FALSE,TRUE,FALSE,TRUE,0,64
alexcrichton,"You've proposed possible improvements but you need to take the destructor handling and other issues like efficiency into account",FALSE,TRUE,19,63,218,11,FALSE,FALSE,FALSE,TRUE,0,64
alexcrichton,"Can you explain a little more about how a bare-bones layer over #[thread_local] and os-based TLS wouldn't provide the ability to support constructors/destructors in the future? I would expect this bare-bones layer to be present in basically any cross-platform implementation, so putting it at the base of the stack seems natural to me.",FALSE,TRUE,53,63,220,13,FALSE,TRUE,FALSE,TRUE,0,64
alexcrichton,"Could you also explain how the example I gave was less efficient than the module-expansions you proposed here? I was under the impression that it's just a few pointers lying around and would optimize away completely.",FALSE,TRUE,36,63,222,15,FALSE,TRUE,FALSE,TRUE,0,64
alexcrichton,"However, this is explicitly marked as #[experimental] and I have stated that it is not the finalized API but rather a base to build on in the subsequent pull requests I already have lined up",FALSE,TRUE,35,63,223,16,FALSE,TRUE,FALSE,TRUE,0,64
alexcrichton,"I'd like to note that while I personally do not feel that #[experimental] is the threshold for accepting code to std, others may feel differently. I'm just expressing my own personal opinion, I don't speak for everyone as a whole.",FALSE,TRUE,40,63,224,17,FALSE,TRUE,FALSE,TRUE,0,64
alexcrichton,"TLS needs support for dynamic initialization and destruction to be usable.",FALSE,TRUE,11,63,225,18,FALSE,FALSE,FALSE,TRUE,0,64
alexcrichton,"Remember though that I'm not proposing an end-all be-all interface, this was just the bare bones interface to the rest of the TLS subsystem, it's likely that other abstractions, such as those with dynamic initialization/destruction are built on top.",FALSE,TRUE,39,63,226,19,FALSE,TRUE,FALSE,TRUE,0,64
alexcrichton,"It is required to replace the current TLS implementation which already supports those features.",FALSE,TRUE,14,63,227,20,FALSE,TRUE,FALSE,TRUE,0,64
alexcrichton,"I do agree that to be a drop-in replacement it needs to support these features, but I think we may be able to get by with some unsafe code perhaps in the meantime and scoped TLS (which doesn't require dynamics). Long term, we definitely need to support this though!",FALSE,TRUE,49,63,229,22,FALSE,TRUE,FALSE,TRUE,0,64
alexcrichton,"Why are my pull requests singled out for the application of all of these strict double standards?",FALSE,TRUE,17,63,230,23,FALSE,FALSE,FALSE,TRUE,0,64
alexcrichton,"I'm sorry you feel this way, and I apologize if any of my comments have led you to believe this. It is certainly not what I intended to convey. I may be a little more nitpickity at reviews, but I do not at all intend to single you out and apply a double standard.",FALSE,TRUE,54,63,231,24,FALSE,TRUE,FALSE,TRUE,0,64
alexcrichton,"It's the base I am going to build on in the follow-up commits I had lined up to submit after this landed (destructor support, portability to old Android).",FALSE,TRUE,28,63,232,25,FALSE,TRUE,FALSE,TRUE,0,64
alexcrichton,"Currently almost everything we provide in the standard distribution, apart from liblibc, is cross-platform, so I would consider the portability fallback to be required for a first-pass implementation.",FALSE,TRUE,28,63,234,27,FALSE,TRUE,FALSE,TRUE,0,64
alexcrichton,"inability to store a type with a destructor directly in a static mut (calling the destructor is unnecessary, just allowing Option initialized to None where T has a destructor) and various other issues.",FALSE,TRUE,33,63,235,28,FALSE,TRUE,FALSE,TRUE,0,64
alexcrichton,"Could you elaborate some more on these issues? Currently this code compiles:",FALSE,TRUE,12,63,236,29,FALSE,TRUE,FALSE,TRUE,0,64
alexcrichton,"I identified the problem on Windows and fixed it in 6bb648f. The problem was just that the MinGW-w64 linker's implementation of ASLR is thoroughly broken. It seems to work fine on 32-bit too...",FALSE,TRUE,33,63,237,30,FALSE,TRUE,FALSE,TRUE,0,64
alexcrichton,"I think Saturday's nightly (the one I tested) had that commit. Have you tested recently on 32-bit?",FALSE,TRUE,17,63,238,31,FALSE,TRUE,FALSE,TRUE,0,64
alexcrichton,"Closing for now. I've filed #18004 about this and will submit the same changes in a different order than I planned.",FALSE,TRUE,21,63,239,32,FALSE,TRUE,FALSE,TRUE,0,64
alexcrichton,"Ok, I'm also fine if you want to leave this open! I wanted to talk more with others about this today and get their thoughts on this approach.",FALSE,TRUE,28,63,240,33,FALSE,TRUE,FALSE,TRUE,0,64
thestinger,"@alexcrichton: I'll start with an unsafe API providing a portable fallback for #[thread_local].",FALSE,TRUE,13,64,241,0,TRUE,TRUE,FALSE,TRUE,0,65
joakim-noah,"Android does actually support static TLS and I've verified that C++11 thread_local works on the tablet I have access to (Android 4.4.4).",FALSE,FALSE,22,65,242,0,FALSE,TRUE,FALSE,TRUE,0,66
joakim-noah,"Hello, I was curious about the state of rust on Android and I stumbled across this thread.  Since D was mentioned earlier, I've been working on getting D on Android, hence my interest. :)",FALSE,FALSE,35,65,243,1,FALSE,TRUE,FALSE,TRUE,0,66
joakim-noah,"@thestinger, I don't believe Android supports native TLS for apps even today.  They're still storing the pointers for bionic's pthread TLS implementation in native TLS, so that's going to write over any data that apps put in there.  It is true that purely static TLS without any relocations will sometimes randomly work, which is why it might have worked for you when doing small tests with C++, but when I went over 4K in TLS data on Android/x86 it started to break.  That's because they did not take native TLS support for C/C++ out of their lightly patched gcc/clang/binutils/gold native toolchain in the NDK, but it's unsupported by bionic and the dynamic linker so native TLS won't work beyond such random corner cases.  I had to wrap pthread_getspecific/setspecific to get TLS to work for D, sounds like you have a similar fallback in mind.",FALSE,FALSE,148,65,245,3,FALSE,TRUE,FALSE,TRUE,0,66
