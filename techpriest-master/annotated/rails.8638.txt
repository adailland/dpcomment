>>>bogdan, Contributor


Example:





Old result:





See that it is impossible to detect which Employment object is error related to.
In order to fix that propose to use an index(as Employment could be new - we can not use an id).
Only applied to collection associations.


New result





Live demo:
http://rails-ajax-validation.herokuapp.com


>>>senny, Owner



;##D1 The error message should be on the employment instances
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU
;##D2 What's the benefit of th aggregation?
;##ROLE PM
;##INV F
;##BCOM T
;##FORM OPQ
;##REL GEN D1
;##SEN NEU

The error messages should be available on the individual Employment instances. What is the benefit of aggregating them all on the containing object?


>>>bogdan, Contributor



;##D3 It allows to provide errors on an JSON api call and send them to a oblivious server
;##ROLE OP
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D2
;##SEN NEU

The benefit is that we can provide errors as the result of JSON api call and send them to a different server that doesn't know about objects we have.


When you can render a form using active record models and form_for helper it is not required. But when the generation context is different and you can only pass a data in between this is problem.


>>>senny, Owner



;##D4 It would be simpler to aggregate errors and then convert them
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D3
;##SEN NEU
;##D5 Duplicate errors is not a good idea
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D4
;##SEN NEU

I see but I guess you could write the logic to aggregate the errors and then convert them to JSON. I'm not sure we should duplicate errors, that are already accessible through the object graph. To completely implement this feature (aggregating all child errors on the parent) you would also need to modify other validators. For example AssociatedValidator, which currently only adds ":invalid" but not the individual errors from the child.


@rafaelfranca @carlosantoniodasilva what do you think?


>>>bogdan, Contributor


@senny  Errors aggregation code is only related to autosafe associations not specific validators. If you are using any validator including AssociatedValidator but not using autosafe associations this change won't affect you.


Follow though the source code: https://github.com/rails/rails/blob/master/activerecord/lib/active_record/autosave_association.rb#L286


>>>rafaelfranca, Owner



;##D6 SHowing errors to users is not a good diea
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

I'm not sure. I understand the reason to add those errors messages, but I don't like the idea to show more errors messages for the users.


@josevalim thoughts?


>>>bogdan, Contributor


@rafaelfranca As you can see Rails already adds error messages from associated models and doing it wrongly:
Merging together errors from different models under same has_many association.





And this is wrong.
I am not trying to make rails do something new, I am trying to fix already existing feature:


>>>kmerz, Other


I have been waiting for a solution for this quite a while now. But I can't see how this commit will improve the situation.


After getting the hash with indexed error messages I still can't relate them to the records listed in my form, because the order of the records might differ with every request.



;##D7 Using the id of the object would also not work
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

I see that using the id of the object can't be the solution either, because it does not exist for new records.


>>>bogdan, Contributor


@kmerz according to html spec fields with same name are passed to backend with the same order they appear in DOM. I know this for sure because made a lot of features depending on this behavior that is compatible with every browser.


Rails itself already relies on this behavior, example of html generated by rails form builder:



;##D8 Order is the only information needed
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

See that nested attributes fields here has no index, but rails always know how to group them by models without mixing them up.
So basically order is the only one thing we need to know when getting errors from collection association models.
In the example above we can do the following to identify them: .education{:'data-error-key' => "educations[#{index}]"}


>>>jalada, Other


I agree with @bogdan here. It seems broken to me to merge errors together and make it impossible to know which instance caused the validation to fail.



;##D9 Can we do better than the square bracket
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

The only thing I'm not sure about is the square bracket notation in the key for the hash, but I'm can't think of another way. "employments" => [{"company" => ["can't be blank"]}] ? Problem with that is if the first one doesn't have an error but the second one does you end up with "employments" => [[], {"company" => ["can't be blank"]}] instead and that feels nasty too.


And I guess the square bracket notation matches the way the parameters are passed from the browser to the app.


>>>bogdan, Contributor


@jalada yeah, this is another way of solving this. I believe you mean empty hash instead of empty array here: "employments" => [{}, {"company" => ["can't be blank"]}].

;##D10 Besting the hash is another way, but less compatible
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D9
;##SEN NEU
I would prefer  flat hash without nesting as it is in current PR. Maybe because of a way how I am using it.
Also the way you suggested is less compatible with current implementation. It will require more code to change for apps that relies on this functionality already.


>>>bogdan, Contributor


Spent some time to bring up a live demo of what this patch allows to do:


http://rails-ajax-validation.herokuapp.com


>>>vitorbal, Contributor


+1, this is awesome and a much needed fix. Would love for this to be merged!


>>>crosebrugh, Other


This is great patch, thanks.


Interesting side issue is that, for an existing parent record, validate_collection_association only checks (via its call to associated_records_to_validate_or_save) records that are deemed changed_for_autosave (or new records if autosave is false on the has_many).


This means that if I add a new validation to the association model that causes existing records to not be valid, those records are not checked.


Granted, this is a general issue in rails not in this patch, but it is of a similar flavor (issues with nested errors).


As a workaround I changed:




to




>>>wrystr, Other


Hi I'm a beginner, in which version of rails is this pull available?


>>>dmathieu, Contributor


@wiryasastra: this PR hasn't been merged yet. It's not in any version of rails.
If it were merged right now, it wouldn't be available until 4.1 though.


>>>wrystr, Other


This is a VERY IMPORTANT pull and should come to any version of rails, at least to 3.2!!


>>>dmathieu, Contributor





There is a release process. The rails team tries to follow semver.
Therefore, this being a new feature, it won't ever be released in a minor release. It can't be released in 3.2.


>>>dredozubov, Contributor


+1 on this, i think it should be merged


>>>sobrinho, Contributor


Random thought:




Is better than:




The former is more easy to parse.



;##D11 items.0 is better than items[0], even though is not JSON notation
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

We could argue that items[0] is a JSON notation and items.0 not but in fact it is a string and not a full JSON object.


>>>codesnik, Contributor


latter is also a "JSON Path" notation. But all implementations of JSON Path I've seen also parse "items.0.product" without any problems. We use "items.0.product" notation in our project already.


>>>sobrinho, Contributor


@codesnik that's even better, I was thinking it was invalid syntax! :)


Another random thought...



;##D12 We could dump a complete object instead of keys
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

Instead of dumping keys like that, we could dump a more complete object:




So instead of parsing the keys, we just iterate over it.


>>>bogdan, Contributor


This is a "json <=> keyvalue" conversion pseudo standard, one direction implemented in jQuery.param. Other direction live somewhere in Rack.


The need of it comes from a fact that form inputs can only be represented as keyvalue where name attribute is key and value attribute is value. While forms can represent a complicated objects structure.


In case of demo here: http://rails-ajax-validation.herokuapp.com
There is no need to parse errors.

;##D13 The conversion needs to be standard
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU
But I understand the need of it.
"json <=> keyvalue" conversion have to be a standard implemented in both frameworks - jQuery and Rack.

;##D14  A json format could sovle it, but might create incompatibility
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D13
;##SEN NEU
I like a json format idea but it will cause more serious incompatibilities with current implementation.
keyvalue format is a compromise.


There is 3rd party parsers available in case you need them:
https://www.google.com.ua/search?q=jquery+param+reverse&client=ubuntu&channel=cs&oq=jquery+para&aqs=chrome.0.69i59j69i57j69i62l2.2507j0&sourceid=chrome&ie=UTF-8


>>>danteoh, Other


@bogdan  have you heard anything from the core team on whether they're going to pull this in?


I'm currently just passing my models into a validator that effectively builds the same thing... but it doesn't rely on the existing nested validation framework


>>>bogdan, Contributor


@danteoh no other discussion than here.


>>>viniciuscb, Other


+1 to this feature. It is so much needed.


>>>johnsinco, Other


+1.  We're facing the same problems with how to return JSON API error responses on dependent has_many relations.


>>>pedromartinez, Other


+1


>>>alexspeller, Other


ðŸ‘ definitely needed.


>>>codezomb, Other


ðŸ‘


>>>kenelliott, Other


ðŸ‘


>>>axelguiloff, Other


ðŸ‘


>>>davidtrogers, Contributor


ðŸ‘


>>>georgeismike, Other


ðŸ‘


>>>rafaelfranca, Owner



;##D15 How would we handle backward compatibility?
;##ROLE PM
;##INV T
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

Still think we should not show more errors to users. Other thing to think about, how to handle backward compatibility with code that expects the old behavior?


>>>bogdan, Contributor


@rafaelfranca it depends on who do you call  "users".



;##D16 Displaying errors to developers is not much of an issue
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL REFR D6
;##SEN NEU

If it is a Rails developer than I wouldn't agree. As a developer I want to see what is going on with my models and which one is invalid.



;##D17 Devs shoudl decided themselves how to display errors
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELABD 16
;##SEN NEU

If it is a user of a rails application that see error after form submit than you would use full_messages method that merges all errors to array. Maybe after this patch we can add uniq to this method but I would not do it, rails developer should decide himself how errors should be displayed.

;##D18 It's possible to add a config option to use old behaviour
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D15
;##SEN NEU

Regarding backward compatibility:
I would introduce a configuration option that bring back old behaviour so that people can move to new behaviour more smoothly. We will remove this option a few versions later.


>>>pjmorse, Other


ðŸ‘


It's not "showing more errors to users" so much as it's allowing the front end to tell the user accurately where the error lies.


>>>rafaelfranca, Owner




I would introduce a configuration option that bring back old behaviour so that people can move to new behaviour more smoothly. We will remove this option a few versions later.




I really don't want to introduce another hidden configuration, but this would may be the only way to make this work.




@rafaelfranca it depends on who do you call "users".





;##D19 Giving devs a bad default for erros visualization is concerning
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL REFR D17
;##SEN NEU

It is the users of a Rails application. I agree developers should decide that but I'm concerned we may giving developers a bad default where every error is presented to the application users


>>>sobrinho, Contributor


I don't see why it would be a bad default, we are exposing the nested errors which makes sense for me.


>>>alexspeller, Other




It is the users of a Rails application. I agree developers should decide that but I'm concerned we may giving developers a bad default where every error is presented to the application users




@rafaelfranca I think you may be misunderstanding the need for this patch - it is to allow highlighting the invalid field in  forms where there are nested objects. For example:





(Assuming an Order object that accepts nested attributes for each Item object)



;##D20 It's missing a way to determine wich item caused the error
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL REFR D19
;##SEN NEU

Without this patch, there is no way, using a json api returning the errors object, to determine which Item had the validation error and display the error in the correct place like this. I don't think you could argue that this is a bad UI decision, and it's currently not possible to achieve because the errors object loses this information by munging all of the errors for nested objects together.


>>>rafaelfranca, Owner


Think in a generated scaffold page. How would the errors look like on that page?


>>>alexspeller, Other


@rafaelfranca it shouldn't change the generated scaffold page - if it does the patch should be changed to not affect that (i.e. full_messages should not be affected by that)


>>>alexspeller, Other




Other thing to think about, how to handle backward compatibility with code that expects the old behavior?





;##D21 ANother solution is to apply this change only to record.errors.to_json
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D15
;##SEN NEU

This is a legitimate concern. My suggestion would be to make this change only for record.errors.to_json - so that it will only affect users where it is relevant - in a json api


>>>sobrinho, Contributor


I would suggest what @bogdan suggested, we may implement it as opted-out for existing applications and make it opted-in for newer applications.


And we may remove this toggle on 5.0, if it has to take so long.


>>>sobrinho, Contributor


For who is not on rubyonrails-core list, I posted a topic about that: https://groups.google.com/forum/#!topic/rubyonrails-core/hxgX6D9s2uM


I have implemented a more robust, but backwards incompatible, output: https://gist.github.com/sobrinho/f634f52a4ab7d47588f5


>>>azuby, Other


ðŸ‘


>>>uberllama, Contributor


Given the increased pattern of SPAs hitting Rails APIs (not to mention plain old json-based apps), this is definitely required.
ðŸ‘


>>>turizoft, Other


+1, I found myself facing the same problem when working on a SPA with Backbone.


>>>sobrinho, Contributor


@rafaelfranca please take a look this comment: railsgsoc/actionform#10 (comment)


>>>dmitry, Contributor


Anyone is going to work on it?



;##D22 The errors should follow an object convation, not jsut be an hashmap
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL GEN D13
;##SEN NEU

I agree that the errors should follow an object convention, not flat hashmap that should be additionally parsed afterwards.


I've implemented 3 years ago almost the same functionality in Rails 3.2: https://gist.github.com/dmitry/3238745 (ugly, but works perfectly)


I would like to participate in development of this feature if it's possible.


>>>bogdan, Contributor


Sum up discussion above:


There is currently open question regarding migration plan, here are the options:




No backward compatibility - yew


Ability to have a single configuration option to change the behaviour for entire project


Configure per accepts_nested_attributes_for call with index_errors: true/false option (with further deprecation or may be support forever)




Also there is an open discussion regarding errors format:

Use flat key/value errors format like in current PR

Use nested hashes structure







My personal choice is:
compatibility - 3 - this is the most smooth way allowing to migrate usages one by one
format - 1 - it is more backward compatible and json <-> keyvalue conversion algorithm is already implemented on many platforms including Rails and jQuery.


@dmitry you can help by putting us your arguments on choices.


>>>tsun1215, Contributor


@bogdan I've actually got something working for this, but I've been trying to figure out creating models and test cases for it (new to contributing). Here's what I have (work in progress): tsun1215@68bb7e7; With the manual testing I did, it should be working. (Also, the puts statement will be removed when I actually submit a request).


I have yet to do the global configuration option for this.


>>>bogdan, Contributor


@tsun1215 yes I saw your work, that is why I've mansion this variant here. Thanks for showing me it.


>>>sobrinho, Contributor


In our side we ended making a errors presenter:





And using a custom reponder:





It's working perfectly fine on production but we are still expecting this feature to be on core since it's a common need.


If not, we are going to pack this as gem and publish :)


>>>dmitry, Contributor


There are actually 3 types of error formats possible:




flat: {"educations[1].company" =â‰¥ "can not be blank"}


nested with array index: {"educations": [{}, {"company" =â‰¥ "can not be blank"}]}


nested with hash index: {"educations": {"1": {"company" =â‰¥ "can not be blank"}}}




I prefer nested with hash index (3). It's more universal and can be used in any languages, sometimes can be faster.


Flat




can be faster in some languages/environemnts (like javascript)


must be parsed before it can be applied to (not all the languages have the parsing feature, they should be implemented)




Nested with array index




not possible to have index with high value (sometimes it's may be required for the values objects)


can be parsed in any languages that have hashmap and array types




Nested with hash index




pros from nested with array index


only hash/object is used


possible to have any index, including string




>>>sobrinho, Contributor


Please, be aware that we must support this structure:






;##D25 The index, not being sequential, needs to be an hashe
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

First the index is not always sequential that is there is an error on first record and third record, so, it must be always a hash instead of an array.



;##D26 We must provide the subitems record_errors
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

Second we must provide the subitems record_errors which contains the nested record errors and relation_errors which are the errors on the relation itself.

;##D27 Plain hash will always be worse than nested hashes
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

And honestly I think that the plain hash will be always worse since we will need to parse the keys everywhere and in every language (we don't always use this return on browser, it may be a mobile app or another program in Go/Python/Scala/etc) and returning nested hashes will avoid that.


>>>dmitry, Contributor



;##D28 For subitems we can simply follow indexes coventions
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL REFR D26
;##SEN NEU

@sobrinho ðŸ‘ with small exception: subitems, because we can follow convention to use indexes of the records as numbers, and general errors with index as strings (normally it's just base index string). Plus base can be an array of strings.


>>>alexspeller, Other


Surely all errors can be arrays of strings, as there can be multiple errors on any field


>>>sobrinho, Contributor


I sent a wrong hash, sorry. The correct one would be:





Note that in a case of a has one association, the hash would be different:





But still we must have record_errors and relation_errors to represent the association/children association errors and the errors on the association itself.



;##D29 It would also be helpful to have emssages always as an array
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

Note that I'm also proposing the messages to be always an array now, it caused some trouble to us to have sometimes a string and sometimes an array, keeping it always as array make the front-end logic simpler.


>>>bogdan, Contributor


I am not sure what kind of architecture changes will be under all these relation errors.
Current code is hardly tided on a fact that errors model structure is flat. The Errors#add method itself is not designed to accept hash argument.



;##D30 If nested errors is supported, it should be done at a different layer
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

If the nested errors should be supported, it should be done at a different layer for example custom ARBase method like #errors_with_associations_as_json (better name welcome).


Allow AM::Errors to act like a hash with possibly infinite nesting is very very radical change.


>>>sobrinho, Contributor


Errors#add wouldn't change, I'm generating this proposed hash with the current hash using this presenter:





So, the Errors object wouldn't change, only the presentation of it.


>>>bogdan, Contributor


@sobrinho probably you didn't but others(including myself) made me think that this is proposed.
I agree with you that it should be decoupled from AM::Errors.


I don't feel like it is related with this PR as it only cares about how errors are added to Errors object.
as I said before: Rails is not doing it the right way.


Presenters like yours can live beside this PR in Rails Core or outside of it.


>>>sobrinho, Contributor


@bogdan not sure if I'm following you but the suggestion above is one solution for the problem of this pull request.


People seems to agree, everyone on this pull request at least, that we must have a way to deal with it on active record natively.


A presenter may or may not be the best solution but thinking in backwards compatibility it seems to be the way.


Are we saying the same thing or I did not understood you?


My suggestion is:



;##D31 We should keep acrivemodel::errors to avoid breaking
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

Keep ActiveModel::Errors as it is today to not break anything

;##D31 impelment a errorspresenter that computed the hash
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM ELAB D31
;##REL NEW
;##SEN NEU
Implement a ActiveModel::ErrorsPresenter which computes a hash like I suggested or like you suggested first







I'm suspect to say that but the hash which I proposed is working perfectly on at least 5 large applications here.


Our front-end architecture is made by 4 javascript packages (private but will be open sourced in a couple of weeks):


backbone.relation: Handles the concept of associations in backbone models (similar to Backbone.Relational)


backbone.errors: Handle the errors hash on failure and distributes the errors through associations (using a small reflection implemented on backbone.relation)


nested-errors-presenter: Handle the errors receiving the attribute name and the error and render it on DOM (assuming that you use bootstrap markup but it accepts any strategy)


backbone.nested-errors-presenter: Basically knows how to receive the errors from a backbone.relation model and iterate through them and send it to nested-errors-presenter.


Basically using these 4 packages the back-ends validations are totally painless to integrate on backbone and render them to DOM.


We started working with React.JS right now and we are going to create React components/libraries which will knows how to deal with this hash too.


