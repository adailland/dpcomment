>>>TimNN, Contributor

Since nobody has done this yet, I decided to get things started:

Todo:

 push the relevant commits to rust-lang/llvm and rust-lang/compiler-rt

 cleanup .gitmodules

 Verify if there are any other commits from rust-lang/llvm which need backporting

 Investigate / fix debuginfo ("<optimized out>") failures

 Use correct emscripten version in docker image

Closes #37609.

Test results:

Everything is green ðŸŽ‰

>>>rust-highfive, Collaborator

r? @brson

(rust_highfive has picked a reviewer for you, use r? to override)

>>>alexcrichton, Owner

@TimNN you can probably work faster than going through @bors by selectively adding ALLOW_PR=1 to various entries in .travis.yml, that'll run the tests on the PR itself before we hit @bors.

I'd recommend doing that for a couple of the cross targets at least and then probably some of the other builders as well (such as emscripten)

My guess is that AppVeyor will be one of the most difficult pieces to update as part of this upgrade. Unfortunately we don't have any extra capacity there for running tests so it may be difficult to do so on the PR before bors :(

>>>TimNN, Contributor

The debuginfo failures all occur because static muts are optimized out. (I verified that no optimisation flags were passed to rustc).

I'm unsure what the best fix would be here (something like the #[used] attribute from #39987 would probably work).

>>>rkruppe, Contributor

static muts getting optimized out sounds like an issue with the IR/debug info we generate. Perhaps one of the debug info-related changes was incomplete and we don't emit everything we need to emit for globals? (#39528 looks very related.) To clarify, does this:

static muts are optimized out

;##D1 Did you ckec the object files and the sysmbol? or does the gdb outputs optimized?
;##ROLE ETC
;##INV F
;##FORM SOL
;##REL NEW
;##SEN NEU

mean that gdb outputs <optimized out>, or did you check the object files and the symbols for the globals were missing?

;##D2 Requiring #[used] on static muts would be regression
;##ROLE ETC
;##INV F
;##FORM SOL
;##REL NEW
;##SEN NEU

In any case, requiring #[used] on static muts to enable debugging would be a serious regression, not to mention that #[used] doesn't exist yet and I'm not even sure it would fix this (see above).

>>>petrochenkov, Contributor

;##D3 One assigned was needed to maintain the static
;##ROLE ETC
;##INV F
;##FORM SOL
;##REL NEW
;##SEN NEU

I vaguely remember about statics being optimized away the last summer already, when I wrote debuginfo tests for unions (one of the failing tests in this PR).
So I had to add at least an assignment for the static to be kept.
Maybe the LLVM optimizer become better and now sees that the optimization is still possible?

>>>TimNN, Contributor

To clarify, does this:

static muts are optimized out

;##D4 Did you ckec the object files and the sysmbol? or does the gdb outputs optimized?
;##ROLE OP
;##INV F
;##FORM SOL
;##REL NEW
;##SEN NEU

mean that gdb outputs <optimized out>, or did you check the object files and the symbols for the globals were missing?

It means that gdb prints <optimized out>

Apparently I made some assumptions that weren't quite correct.

The symbols exist (output of nm from the simple-struct test:

Since this is apparently indeed debuginfo related I guess cc @michaelwoerister, @dylanmckay

>>>TimNN, Contributor

The generated IR, in case that helps anyone: https://gist.github.com/TimNN/92152a2f8062909805657d1bb4131998

>>>TimNN, Contributor

The failed build of the IMAGE=cross seems to be qemu related, one of the failed tests:

I saw the following panics:

Do they ring a bell for anyone?

>>>TimNN, Contributor

The emscripten failure are mainly of the kind Invalid record (Producer: 'LLVM4.0.0' Reader: 'LLVM 3.9.0'), although there are some assertion failures as well. (I would fix the llvm version mismatch first, maybe that fixes the assertion failures as well).

>>>TimNN, Contributor

The android image fails with an LLVM assertion:

There are also some warnings (see below for an example), of which I am unsure how relevant / important they are.

>>>alexcrichton, Owner

@TimNN the former may be a bug in LLVM? (or just something we've never exposed ourselves before). The latter is normal, I believe it's happening on builds today.

>>>alexcrichton, Owner

Oh we've also got ~10 extra capacity on Travis so feel free to test more than one row at a time if you'd like :)

>>>TimNN, Contributor

@alexcrichton: Have you ever seen something like the qemu failures in #40123 (comment) before?

Oh we've also got ~10 extra capacity on Travis so feel free to test more than one row at a time if you'd like :)

Ah, ok. I've been doing 3 at a time (when not debugging emscripten), but I guess I can run a few more :)

>>>TimNN, Contributor

The dist-s390x-linux-netbsd build fails while cross compiling llvm due to missing std::thread support:

;##D5 It could be fixed by bakcporting this
;##ROLE OP
;##INV F
;##FORM SOL
;##REL NEW
;##SEN NEU

I guess the fix here is to backport (part of?) rust-lang/llvm@58731be as well.

>>>TimNN, Contributor

I've been investigating the emscripten failures, see below for the findings. The one thing that both test have in common is that they use fixed sized arrays ([constexpr; len]) although if that is related / the problem, I don't know.

run-pass/packed-struct-vec.rs IR:

The #[repr(packed)] seems to be just broken, printing instead of asserting for equality gives the following results:

(with this code:)

run-pass/issue-29663.rs IR:

The write_volatile in the following snippet is apparently not executed correctly:

The output:

If line 61 is commented:

Note that other write_volatile / read_volatile pairs work correctly.

>>>alexcrichton, Owner

@TimNN

The QEMU failures don't look familiar but are perhaps indicative of the program segfaulting or otherwise exiting un-cleanly. Do you have the full logs I could help take a look at?

;##D6 Deleting code using std::thread will not work int he long term
;##ROLE PM
;##INV F
;##FORM SOL
;##REL NEW
;##SEN NEU

The missing std::thread business may be related to how we compile compilers. It may be that one of our compilers is too old or something like that. I know that MinGW C++ compilers, at least, do not have std::thread (at least if I'm remembering correctly). Historically we've "dealt" with this by just deleting code that uses std::thread, but it's clearly getting harder over time! This also isn't scalable into the future really. Unfortunately I don't know of a great solution here.

>>>TimNN, Contributor

The QEMU failures don't look familiar but are perhaps indicative of the program segfaulting or otherwise exiting un-cleanly. Do you have the full logs I could help take a look at?

Ah, sorry, I linked the logs only from the original post, here they are: https://travis-ci.org/rust-lang/rust/jobs/205860539

>>>alexcrichton, Owner

Fascinating! Unfortunately I may not be of much help. Also thanks for the links, I should have looked around for them! Of the failures so far:

armhf - this is really suspicious. In theory if qemu-test-server panics in any way we'd see it in the logs (as it doesn't daemonize that much or anything), but I'm not seeing anything. The errors mean that the server is prematurely closing the connection, but I'm not sure how that's possible without otherwise printing error information! It may be a bug in LLVM or related to the assertion failures, but it may also require more debugging the qemu instance itself :(

emscripten - looks like you're on top of these (maybe fastcomp regressions? maybe llvm regression? unsure myself...)

android - yeah looks like an LLVM bug? Although I wouldn't rule out invalid codegen on our side just yet.

;##D7 Is it possible that gcc disabled std::thread?
;##ROLE PM
;##INV F
;##FORM SOL
;##REL ELAB D6
;##SEN NEU

s390x-netbsd - Ok so this specifically failed to compiled LLVM for NetBSD. This is our script to compile NetBSD gcc and I don't see anything immediately wrong that should compile the wrong C++. I wonder if the gcc options accidentally disable std::thread? Or maybe it's disabled somewhere else on NetBSD by default? Not sure why that happened :(

Some other tips I'd have is:

You can run docker images locally via ./src/ci/docker/run.sh $image_name which can help with debugging (e.g. avoiding going through Travis). That should in theory use the precise same environment as Travis modulo kernel and hardware.

For suspected LLVM bugs the best way (although certainly not the fastest way) that I know to work with them is to (a) get it to reproduce with a manual rustc invocation then (b) get it to reproduce with an opt invocation by using rustc to generate LLVM IR then switching to LLVM's tools and then (c) minimizing that IR as much as possible. If it's small enough then reporting a bug on LLVM's issue tracker is usually good for getting the issue fixed in a timely fashion.

>>>TimNN, Contributor

You can run docker images locally via ./src/ci/docker/run.sh $image_name which can help with debugging (e.g. avoiding going through Travis). That should in theory use the precise same environment as Travis modulo kernel and hardware.

Yeah, I'm doing that right now :)

s390x-netbsd

Alright, so the problem is, I think, that the following ./configure check fails when compiling: checking for gthreads library... no

>>>alexcrichton, Owner

@TimNN heh yeah that'd do it! I wonder if some more headers need to be copied from the NetBSD base system or something like that? Unfortunately I forget now at this point where I got those instructions from to build a NetBSD cross-compiler...

>>>mattico, Contributor

Those warnings aren't new. I forget the cause.
Edit: meaning the compiler-rt function signature warnings which seem to have disappeared...

>>>TimNN, Contributor

Some notes on the armhf-gnu image:

I (once) got the same LLVM assertion as on android, this went away when retrying the build. I'll try to get this to reliably reproduce.

The qemu connection errors happen non deterministically, as far as I can tell, example: run-pass ran successfully, incremental failed afterwards, after a retry all ofrun-pass failed.

Now I got a segfault... and no idea what actually segfaulted...

>>>alexcrichton, Owner

Odd! I wouldn't entirely rule out a bug in qemu-test-{client,server} FWIW

>>>TimNN, Contributor

First of all a small progress update: Of the 25 Docker based builds, 16 build without problems, 2 required (small) fixes, 2 timed out on travis but succeeded locally and 5 are currently broken. I'll investigate the broken images over the next days when I have the time.

Some notes on the android failure:

The arm-android image causes an llvm assertion:

This happens while compiling the coretest crate:

While running llvm passes, full backtrace:

I will attempt to build llvm / rustc with debug info tomorrow to get some more information on what is going on.

>>>alexcrichton, Owner

@TimNN FWIW timing out on travis may be fixed by re-running. If travis has a cold cache for both the docker image and LLVM it's likely to fail, but with sccache you'll likely cache LLVM the first time so the second build will have it cached (just a guess). If it passes locally though I'd be pretty confident that it'll pass on Travis.

Also thank you so much again for taking this on!

>>>TimNN, Contributor

I have (somewhat) minified the android assertion, compiling the generated llvm IR with llc triggers the same assertion. The assertion only triggers when compiling with optimizations. IR and the minified example: https://gist.github.com/52fcea6426c872869269114c47f96e1f

>>>TimNN, Contributor

Bugpoint minified IR: https://gist.github.com/fa2cdcabaa481d619277d1c2ea9d04b4

>>>alexcrichton, Owner

Nice! Want to submit that upstream?

>>>TimNN, Contributor

Yeah, I'll just try to reproduce with an official llvm 4.0 build first.

>>>TimNN, Contributor

Upstream bug: https://bugs.llvm.org/show_bug.cgi?id=32130

>>>bors, Contributor

â˜”ï¸ The latest upstream changes (presumably #40207) made this pull request unmergeable. Please resolve the merge conflicts.

>>>TimNN, Contributor

;##D8 THe write_volatile might be unoptimized for the rust source
;##ROLE OP
;##INV F
;##FORM SOL
;##REL NEW
;##SEN NEU

I've been investigating the volatile emscripten failure a bit: It appears that the write_volatile (or the reading during verification) is miss optimized, see https://gist.github.com/TimNN/a43fc1376888e1d39ea5e9b93c099478 for the rust source, compilation options as well as optimized and unoptimized IR.

cc @kripken -- maybe you could take a look? The IR is sadly not freestanding (and depends on some rust libraries) but maybe you can see something anyway? I'm not sure how to debug this further -- if you have something I should try / do feel free to ping me here or on irc.

>>>kripken, Other

;##D9 The problem seems to be in the expandstructregs
;##ROLE ETC
;##INV T
;##FORM SOL
;##REL ELAB D8
;##SEN NEU

@TimNN: looks like the ExpandStructRegs pass is doing something wrong. It translates a bunch of insertvalues + a store volatile of their result into a bunch of store volatiles of undef. So it's losing the actual data, and only 0s will be stored.

That pass is originally from NaCl, and I'm not that familiar with its internals. So first thing that could help is to know if this is a new pattern of IR being generated? Is this a new test in 4.0, or is Rust in 4.0 generating something it didn't use to?

In particular, the relevant type here is %E = type { [32 x i64] }, that's what that pass is trying to legalize. Perhaps the pass can't handle arrays inside structs.

>>>kripken, Other

Here's a before and after of the important part. The store volatile i64 undefs are what is wrong in the after.

>>>TimNN, Contributor

;##D10 Is this a new pattern being generated?
;##ROLE OP
;##INV F
;##FORM OPQ
;##REL NEW
;##SEN NEU

;##D11 Is it a new test or is rust doing something new?
;##ROLE OP
;##INV F
;##FORM OPQ
;##REL ELAB D10
;##SEN NEU

So first thing that could help is to know if this is a new pattern of IR being generated? Is this a new test in 4.0, or is Rust in 4.0 generating something it didn't use to?

The test is not new and the generated IR is exactly the same before and after the llvm upgrade. So it is my believe that something in LLVM / emscripten changed for 4.0 causing this failure (although I don't currently have a way to test that).

>>>TimNN, Contributor

;##D12 The error doesn't seem to appear if the the array is not wrapped
;##ROLE OP
;##INV F
;##FORM SOL
;##REL ELAB D11
;##SEN NEU

Another note: Things work fine if the array is not wrapped in a struct, see https://gist.github.com/TimNN/419a598a0c5795dc2a83657ae684539f for source code and IR.

>>>kripken, Other

;##D13 The cause is either LLVM is optimized differently, or emspscripten compiles it differently
;##ROLE ETC
;##INV T
;##FORM ENU
;##REL ELAB D12
;##SEN NEU

;##D14 How is the optimized code generated?
;##ROLE ETC
;##INV T
;##FORM OPQ
;##REL ELAB D13
;##SEN NEU

Ok, if it's the same IR as before, then either LLVM is optimizing it differently, or emscripten is compiling it differently. Running opt -O3 on the unoptimized ll from your gist results in the same output in both LLVM versions (well, minus a new nonnull attr). And running emscripten on that gives me the same results as well. However, when I opt -O3 your unoptimized code, I don't get the same optimized code - so perhaps the optimization flags matter. How are you generating the optimized code?

>>>TimNN, Contributor

Running opt -O3 on the unoptimized ll from your gist results in the same output in both LLVM versions

However, when I opt -O3 your unoptimized code, I don't get the same optimized code

I guess one of those should be optimized? (Which one?)

How are you generating the optimized code?

The optimized code is generated using opt -S -O1 vol.ll -o vol-opt.ll

>>>TimNN, Contributor

By the way -- I don't need to run opt again, just compiling the -opt.ll files with emcc (-O0) is enough to trigger the bad code. See https://gist.github.com/TimNN/76ca254f3ad4105dd83d39721a02e118 for the complete emcc command.

>>>kripken, Other

No typo, both of those were meant to be "unoptimized". What I see is that starting from your unoptimized IR, I end up with bad results in old llvm+emscripten as well as new.

;##D15 The error could be caused by legacy unoptimized input
;##ROLE ETC
;##INV T
;##FORM SOL
;##REL NEW
;##SEN NEU

Ok, looking at -O1 now, I also see both old and new llvm+emscripten emit the same bad code (with tiny unrelated differences like the new nonnull stuff). So the issue seems to be that if this test worked in the past, it had different unoptimized input IR to begin with.

>>>kripken, Other

;##D16 Could be that odler rust did the wrapping
;##ROLE ETC
;##INV T
;##FORM SOL
;##REL ELAB D12 
;##SEN NEU

And yes, wrapping an array in a struct seems to be the issue - so if older rust didn't do that wrapping, it could explain this. (But not assign blame, of course, the problem is in that legalization pass, not rust.)

>>>TimNN, Contributor

No typo, both of those were meant to be "unoptimized".

Ah, I originally misunderstood what you were saying.

Interesting. I'll be building a full rustc + LLVM 3.9 now and run that test manually, to see what happens.

>>>TimNN, Contributor

Alright, manually running the test on rust with llvm 3.9 does fail as well... Now to find out why this is not picked up during normal testing... / occurs in my update builds.

>>>TimNN, Contributor

So the mystery why the test passes with rustc + llvm 4.0 is solved, consider the following table and that rust compiles tests with -O2:

Results of the test case with different LLVM version / optimization levels (the -O flag was given directly to rustc):

LLVM 3.9
LLVM 4.0

-O0
ok
ok

-O1
fail
fail

-O2
ok
fail

-O3
ok
fail

I'm unsure how this relates to your observation that the generated IR is the same for LLVM 3.9 / 4.0 however this at least explains why the test passes on rust pre 4.0.

I have uploaded some more IR at https://gist.github.com/86c800a71b4654912626ad6e13105d90:

the llvm-X.X prefix specifies the llvm used to generate the IR.

the -rust-OX files where generated directly using rustc -Copt-level=X --emit=llvm-ir -o *.ll

the -opt-OX files where generated from the -O0 rust IR: opt -S -OX *-rust-O0.ll -o *.ll

>>>kripken, Other

;##D17 Likely the problem is something that changed int he llvm update
;##ROLE ETC
;##INV T
;##FORM SOL
;##REL NEW
;##SEN NEU

Ok, likely what's going on is that emscripten updated llvm since last rust did, and I am using that newer llvm in between the old one and the new one for this PR, since on current emscripten, -O2 fails on 3.9 as well from those IRs, while it doesn't for you with that older llvm. Which indicates that something in the llvm optimizer changed in that first range - likely more aggressive used of insertelement etc.

;##D18 We will need to fix the legalization pass
;##ROLE ETC
;##INV T
;##FORM SOl
;##REL ELAB D17
;##SEN NEU

In any case, the result is almost certainly that that legalization pass needs to be fixed. Does that block this PR? Might be worth just disabling that test for now if it's the last thing.

>>>TimNN, Contributor

Does that block this PR?

Not (yet), there are still some other things which need to be fixed. Among them is one other emscripten failure (related to packed structs, I think), however I have not yet had the time to investigate that.

Thanks a lot for the help so far!

By the way, rust uses the 1.37.1 tag of emscripten IIRC, however I don't know which exact llvm version is used by rust itself.

>>>pftbest, Contributor

Rust is using llvm revision 282753. It is somewhere between 3.9 and 3.9.1 release.

>>>TimNN, Contributor

So the second emscripten failure is actually due to #27060 I believe: rustc emits loads to unaligned pointers (to contents of a #[repr(packed)] struct) without marking them as unaligned. The test passed previously when compiled with -O2 (which is what the test runner uses) put not with -O0.

Here is a small sample program which demonstrates the problem (with -O0):

IR:

>>>arielb1, Contributor

@TimNN

;##D19 Can we fix the UB instead?
;##ROLE ETC
;##INV F
;##FORM OPQ
;##REL NEW
;##SEN NEu

Can you instead fix the test to not UB?

>>>TimNN, Contributor

@arielb1: Probably, I'll take a look.

>>>pftbest, Contributor

@arielb1 Are you sure there is UB in this test?

>>>arielb1, Contributor

@pftbest

Sure enough. The derive(PartialEq) impl of packed structs exploits a known soundness bug to create and dereference references to unaligned values. Writing the derive impls manually should fix that.

>>>pftbest, Contributor

@arielb1 Can you please give me the issue number?

>>>arielb1, Contributor

#27060

>>>pftbest, Contributor

@arielb1 Sorry, I didn't notice it in TimNN's message. Thank you very much.

>>>TimNN, Contributor

I've been investigating some of the failures some more:

I currently can't reproduce the powerpc failure (locally). I'll try travis again at some point.

The qemu-test-server segfaults, which causes the armhf-gnu failure. I don't know yet why or where.

>>>TimNN, Contributor

After lots of printf debugging (anyone know how to easily use gdb with qemu?) I've identified and (somewhat) minified the segfault.

As far as I can tell three things are required for the segfault to occur:

A function returning a u32

Which is immediately cast to a u64 and assigned to a variable

That variable is printed (which probably means a reference is taken and then dereferenced)

Edit: Nevermind that, the problem seems to be somewhere else.

To reproduce use this code as the qemu-test-client and send any four bytes. Sending any four bytes to the server should show @@EXIT@@: 11 in the output.

I'll try to reduce this a bit further and submit an upstream bug report.

>>>TimNN, Contributor

Edit: Never mind this post, see the next post.

Further minified:

This crashes on -O0 as well.

The IR looks good to me, see this gist.

>>>TimNN, Contributor

I apparently made some wrong assumptions in the previous two posts, the actual issue seems to be with the Display implementation of u64, at least that's where the segfault occurs in the following reduced test case: 0xFFFFFFFFu64.to_string();.

Which raises another question: The original qemu-test-server never calls that method (at least not directly), so where does it segfault?

Anyway, I got the following backtrace from a core dump (qemu has so far resisted all my attempts to directly debug it):

>>>TimNN, Contributor

The segfault only occurs if std is compiled with optimizations. configureing with --disable-optimize makes that segfault from the reduced test cases go away and the qemu-test-server seems to be stable so far. Lets see how the the actual tests go...

... so I just got a rather interesting failure of the qemu-test-server:

Running with RUST_BACKTRACE=1 produces this:

Don't ask me where the negative line numbers come from, some of the others seem to be incorrect as well.

Running with RUST_BACKTRACE=full causes the following output (and then hangs):

I'm not sure if I messed something up along the road but something seems to be seriously broken here.

>>>alexcrichton, Owner

Oh dear sounds like something is definitely going seriously wrong :(

My guess would be a miscompile or a misoptimization, although historically LLVM upgrades have uncovered existing bugs in the compiler which were only exploited by the newer LLVM version, so this may very well also be a bug in our own codegen.

>>>pftbest, Contributor

I see debuginfo-lldb/union-smoke.rs test failing on x86_64-apple-darwin
Is it ok? full log

>>>TimNN, Contributor

@pftbest: It's not ok, however a known issue -- there's a problem with debuginfo for globals (I have ignored the affected tests on gdb for now, until I get around to fixing the issue). I would actually have expected more lldb test failures.

>>>bors, Contributor

â˜”ï¸ The latest upstream changes (presumably #40257) made this pull request unmergeable. Please resolve the merge conflicts.

>>>TimNN, Contributor

Well, I'm not sure I'm happy about finding this, but it seems that we are (once again) having problems with compiler-rt, consider:

An info locals from the coredump reveals:

>>>TimNN, Contributor

So the problem is apparently with __udivsi3 (which comes from libgcc_s.so.1!!): The arguments are passed in r0 and r1, but then the returned value is 15 in r0.

I now checked with the current nightly: Here, __udivsi3 originates from the compiled binary -- so apparently our compiler-rt is used.

;##D20 What change made us fall back on gcc_s?
;##ROLE OP
;##INV F
;##FORM OPQ
;##REL NEW
;##SEN NEU

Which now brings up the question what changed to make us fall back on gcc_s with LLVM 4.0? The only thing I can think of is the compiler-rt submodule update, I'll investigate what changed there.

On another note, I noticed that binaries compiled with LLVM 4.0 take significantly longer to start than those generate with a current rust nightly -- I don't know yet why or if this is even relevant.

>>>alexcrichton, Owner

@TimNN holy cow you are crazy deep in "debug everything" land, but nice find! It's odd that compiler-rt is often the last suspect and more commonly than not the actual suspect...

cc @japaric, you may have thoughts here as well.

>>>TimNN, Contributor

One thing I noticed while poking around at things is in the output of readelf on the generated binaries (grepped for udivsi3):

I know that there have been discussions of marking functions as hidden, so maybe the above tells someone something?

Edit: Note that in the libcompiler_builtins.rlib, the symbol is marked as GLOBAL HIDDEN in both cases.

>>>alexcrichton, Owner

Hm that seems unusual. We try to compile that symbol as a hidden symbol, but that's just a flag we pass to the compiler when compiling compiler-rt. I'm not sure how that would change here... Unless the symbol was dropped/moved in the compiler-rt upgrade?

>>>TimNN, Contributor

And things are getting interesting again: The interesting symbol is __aeabi_uidiv (which is, of course, an alias for __udivsi3...): Now checking the libcomiler_builtins.rlib files for that symbol gives the following results:

>>>alexcrichton, Owner

Looks like a bunch of thumb related changes happened to what I believe is the relevant file during the last upgrade.

llvm-mirror/compiler-rt@b11de00 also looks suspicious maybe? (just guessing here)

>>>TimNN, Contributor

llvm-mirror/compiler-rt@b11de00 also looks suspicious maybe? (just guessing here)

Indeed, I'll see what happens if I revert that.

>>>TimNN, Contributor

llvm-mirror/compiler-rt@b11de00 also looks suspicious maybe? (just guessing here)

Indeed, I'll see what happens if I revert that.

Well, that didn't work. On the other hand, I discovered that GDB was being annoying and the whole visibility thing was entirely the wrong direction:

In the disassembly of my test program, gdb showed bl 0xf6fddee8 <__udivsi3>

Checking info symbol __udivsi3 says the symbol came from libgcc_s.so.1

Checking info symbol 0xf6fddee8 says the symbol comes from my binary

ðŸ˜«

So we are apparently miscompiling comiler-rt -- which does seem more reasonable than libgcc_s being broken.

>>>TimNN, Contributor

So, reverting llvm-mirror/compiler-rt@2fb759f seems to fix my small __udivsi3 test case, however I'm still getting the raw_cap overflow panic, let's try to revert another of the thumb commits.

>>>alexcrichton, Owner

;##D21 Doing a manual compilation might give insights
;##ROLE PM
;##INV F
;##FORM SOL
;##REL NEW
;##SEN NEU

It may be worth running a compilation by hand using cmake (compiler-rt's build system) and comparing the flags passed, they may be passing a crucial flag that we're missing :(

>>>TimNN, Contributor

Progress! With a second commit reverted and a clean rebuild of the arm stuff (not sure if the second revert was necessary) some tests seem to be running now!

However some tests (not all) are failing because we get a undefined reference to core::panicking::panic::h6e43017a4193bfc4 while linking (with -Cprefer-dynamic). Lets investigate...

So, if I understand the output of nm libstd.so correctly, then the core::panicking::panic::h6e43017a4193bfc4 symbol is "local", which could be a problem?

>>>alexcrichton, Owner

;##D22 Is __arm_arch_isa_thumb defined by compiler_rt's cmake build?
;##ROLE PM
;##INV F
;##FORM OPQ
;##REL NEW
;##SEN NEU

I wonder if __ARM_ARCH_ISA_THUMB introduced in that commit is defined by compiler-rt's cmake build? Nothing jumped out to me but I'm not sure... We may just not be compiling with the right flags as well (or be targetting something completely different). I've never gotten a good handle on what appears to be a myriad of ARM targets...

That symbol in theory should be public yeah, although I've also never been able to decipher the output of nm so I'm not sure if that's the right visibility or not (have I mentioned that I've also never been able to keep the myriad of visibility/linkage settings straight in my head either?).

@TimNN does it print out where that undefined reference is coming from? It may be related to #40254 if you haven't picked that up yet maybe. Or it may also be somewhere else in libcompiler_builtins which is accidentally wanting to unwind when it shouldn't want to be.

>>>TimNN, Contributor

@alexcrichton: I have #40254 in my branch, the undefined references are in the main code, examples:

By the way, these are the failing tests:

I can also reproduce with a program that simply panic!()s in main:

>>>alexcrichton, Owner

Ok yeah that seems entirely unrelated to compiler-rt.

Can you check the IR generated for libcore? It may be helpful to take a look at the function definition for this symbol to see what we're telling LLVM. (hint: it shouldn't be internal)

>>>TimNN, Contributor

;##D23 We should avoid using __arm_arch_isa_thumb
;##ROLE OP
;##INV F
;##FORM SOL
;##REL REFR D22
;##SEN NEU

Re: __ARM_ARCH_ISA_THUMB: I think we don't want that flag to be defined (to keep the old implementation), however compiling the following small test program with my cross compiler, reveals that __ARM_ARCH_ISA_THUMB is automatically defined...

>>>TimNN, Contributor

Can you check the IR generated for libcore?

I can do so momentarily, however at least the libcore rlib seems to have the symbol publicly defined:

How are the shared libraries generated?

;##D24 We should not avoid using __arm_arch_isa_thumb
;##ROLE OP
;##INV F
;##FORM SOL
;##REL REFR D23
;##SEN NEU

By the way, forget the __ARM_ARCH_ISA_THUMB: I think we don't want that flag to be defined (to keep the old implementation) from the previous comment, I don't think that is correct.

>>>TimNN, Contributor

For the record my cross compiler uses:

>>>alexcrichton, Owner

We should just run basically:

(e.g. nothing fancy or LLVM dependent there)

>>>TimNN, Contributor

I get the following function definition:

>>>TimNN, Contributor

Alright, so I think I know some of what is going on, however how that is different from LLVM 3.9, I don't know (yet):

As it turns out, libcompiler_builtins has references to core::panicking::panic! And if it is linked into the .so after libcore, the symbol gets hidden (I've only checked the nm, not yet a test compilation).

For the record, the following functions call core::panicking::panic (if I'm reading the output of readelf correctly):

cc @nagisa You fixed this (or something similar) in #40254, could you maybe take a look?

>>>TimNN, Contributor

So, apparently, the problem with the panic references is that compiler_builtins was compiled without optimizations. Whether this is ARM specific or caused by LLVM 4.0, I don't know yet, we'll see.

>>>alexcrichton, Owner

Oh dear, that sounds bad! Note that with or without optimizations, the compiler builtins crate shouldn't reference any panic symbols...

>>>nagisa, Contributor

The panicking is introduced by overflowing_sh* which has implementation that looks like this:

That shift over there is a checked shift and does not get optimised in no-opt mode. wrapping_sh* are implemented in terms of this overflowing_sh*. These could be fixed with some intrinsics, maybe?

;##D25 Can we disable debug-assertions on a per-function basis?
;##ROLE ETC
;##INV T
;##FORM OPQ
;##REL NEW
;##SEN NEU

Alternatively, is there maybe a way to disable debug-assertions on a per-function basis?

>>>alexcrichton, Owner

;##D26 Can we try out converting the wrapping versions?
;##ROLE PM
;##INV F
;##FORM OPQ
;##REL EALBD 25
;##SEN NEU

@TimNN want to try out conversion to the wrapping versions and see what happens?

>>>TimNN, Contributor

;##D27 It would probably lead to infinite loops
;##ROLE OP
;##INV F
;##FORM SOL
;##REL REFR D26
;##SEN NEU

@alexcrichton: I don't think that would work, we would have infinite recursion then, according to @nagisa.

>>>nagisa, Contributor

;##D28 It would require an intrinsic at least
;##ROLE ETC
;##INV T
;##FORM SOL
;##REL ELAB D27
;##SEN NEU

Wrapping shifts are implemented in terms of the overflowing_sh*. At the
very least an intrinsic will be necessary.

â€¦

;##D29 It would probably lead to infinite loops
;##ROLE OP
;##INV F
;##FORM SOL
;##REL REFR D26
;##SEN NEU

On Mar 14, 2017 07:31, "Tim Neumann" ***@***.***> wrote:
 @alexcrichton <https://github.com/alexcrichton>: I don't think that would
 work, we would have infinite recursion then, according to @nagisa
 <https://github.com/nagisa>.

 â€”
 You are receiving this because you were mentioned.
 Reply to this email directly, view it on GitHub
 <#40123 (comment)>, or mute
 the thread
 <https://github.com/notifications/unsubscribe-auth/AApc0hbDZGtt9B08ROSTuBx4V4SAqcJ-ks5rliY0gaJpZM4MNOAe>
 .

>>>TimNN, Contributor

I opened #40508 for the ARM / panic failure.

>>>TimNN, Contributor

So some (mostly good, I guess) news: A (once again) optimized ARM build with the two commits mentioned previously reverted leads to almost all run-pass tests passing, with three (issue-28950.rs, run-pass/panic-runtime/abort.rs and run-pass/panic-runtime/abort-link-to-unwinding-crates.rs) hanging... somewhere. I'll investigate those as well as a "proper" fix for the reverted commits.

>>>TimNN, Contributor

Investigation results (on a Raspberry Pi 2):

issue-28950.rs: segfault injemalloc::arena_run_split_remove -> std::sys::imp::stack_overflow::imp::signal_handler -> thread local cleanup / atexit -> jemalloc -> deadlock

abort.rs: Runs fine without RUST_BACKTRACE, with =1 it hangs somewhere during unwinding (although I don't think we set RUST_BACKTRACE by default when running tests?), potentially a dead lock as well

abort-link-to-unwinding-crates.rs: Same as abort.rs

>>>alexcrichton, Owner

@TimNN we're still running into jemalloc dealocks?!

:( :( :( :( :(

>>>TimNN, Contributor

@alexcrichton: Apparently :( Although it only happened after a segfault, so it's probably not that bad? Here is the backtrace, in case you are interested: https://gist.github.com/0b02e3fae217490cd004ea8a58b22f83

>>>TimNN, Contributor

Regarding the issue-28950.rs segfault / deadlock:

I can only assume that somehow jemalloc is miscompiled: The failures happens in the newly started thread, before any user code is run.

Now consider these three lines from the gdb stacktrace:

The relevant jemalloc code.

Notice how arena is 0x766011c0 in arena_run_alloc_large, but when it is passed to arena_run_alloc_large_helper, it is NULL (and then later dereferenced in a probably inlined function?).

I'm not sure if these symptoms are indicative of a stackoverflow or not, however the test seems to deliberately test something in that regard.

>>>alexcrichton, Owner

Note that I would at least personally have no problem jettisoning jemalloc further, especially if there's problems. If disabling jemalloc solves the issue, I say do that.

>>>TimNN, Contributor

@alexcrichton: Yeah, I was planning to try a --disable-jeamlloc build next.

>>>brson, Contributor

Here's some updates on the emscripten LLVM upgrade: https://internals.rust-lang.org/t/need-help-with-emscripten-port/3154/142

>>>TimNN, Contributor

I have tracked down the issue with the llvm IR that causes globals to show as <optimzed out> in GDB, the details can be found in #40580.

>>>TimNN, Contributor

I have opened #40612 which updates the NetBSD compiler to one which can compiler LLVM 4.0. That will hopefully lead to a successful dist-s390x-linux-netbsd build.

On another note, I was happily surprised that a build of dist-fuchsia was successful out of the box.

>>>alexcrichton, Owner

Awesome work @TimNN (I really can't tell you that enough)

Out of curiosity have you tested this yet on Windows/OSX? Unfortunately those are harder to get testing on this PR (there's some bug for OSX on Travis and we don't have capacity to do so on AppVeyor), but I can start running builds and reporting back locally if that'd help.

>>>TimNN, Contributor

@alexcrichton: Not yet, however I think someone commented that they had at least gotten until the debuginfo tests on macOS. I can also test macOS locally however I don't have easy access to a windows machine. So if you (or someone else) wants to test those (especially windows), that would be helpful.

>>>alexcrichton, Owner

Unfortunately MSVC failed pretty quickly in stage1 :(

>>>alexcrichton, Owner

These run-pass tests all fail with the same error, and are likely smaller than all of libsyntax

>>>TimNN, Contributor

I have submitted a fix for the android assertion to LLVM: https://reviews.llvm.org/D31116

>>>bors, Contributor

â˜”ï¸ The latest upstream changes (presumably #40659) made this pull request unmergeable. Please resolve the merge conflicts.

>>>TimNN, Contributor

@alexcrichton: FYI, x86_64-pc-windows-msvc and x86_64-pc-windows-gnu were successful for me. Were your failures for one of those targets?

(Note that I ran my llvm40-tmp branch, which however should only be a cleaned up version of this branch (and rebased on rust master)).

>>>alexcrichton, Owner

Odd! I tested a523fba with x86_64-pc-windows-msvc, but maybe I botched something? If it works for you locally I'd trust that.

I thought windows-gnu was in general an awful hurdle to overcome, but if x86_64 already works I didn't think it was i686 specific, but it may be worth double checking if you've got the cycles.

>>>TimNN, Contributor

@alexcrichton: Yeah, I'll try i686 tomorrow. (I saw an ad for the microsoft azure free trial yesterday, and decided, why use that for something useful ;)

>>>TimNN, Contributor

More windows updates:

i686-pc-windows-msvc fails run-pass\backtrace.rs it seems to work with may work if RUST_BACKTRACE=full is used for the failing test case.

i686-pc-windows-gnu: I use the msys2 mingw, which apparently uses pthreads instead of win32 threads, I'll see if I can't get another build environment set up.

>>>alexcrichton, Owner

Ah OK so on the backtrace business I have a backport to reenable full and there's ongoing discussion of how to work with it. In any case working around locally or setting full should be fine for now.

For the latter I'd recommend downloading the literal toolchain used on the bots (downloaded in appveyor.yml) to ensure it's the same, although we can certainly update that whenever we need to as well (we just haven't ever had impetus to do so).

>>>TimNN, Contributor

;##D30 Adding RUST_BACKTRACE=1 seems to solve the problem
;##ROLE OP
;##INV F
;##FORM SOL
;##REL NEW
;##SEN NEU

Regarding the backtrace test: cherry-picking @alexcrichton's backport did not fix the test. However adding an explicit RUST_BACKTRACE=1 (no full required) here fixed the test. I'm not entirely sure what that part of the test is testing and if the missing RUST_BACKTRACE=1 is an actual bug which just magically doesn't manifest on other platforms.

I'll try i686-pc-windows-gnu again tomorrow.

>>>TimNN, Contributor

I've been experimenting with i686-pc-windows-gnu and the toolchains specified in appveyor.yml: If I understand the situation correctly, we want mingw builds which use win32 threads. This causes problems when compiling llvm, since those toolchains don't have support for std::thread. (I also tried newer versions of those toolchains, same result). (This also means that my success with x86_64-pc-windows-gnu is probably invalid).

As far as I can see we have three options:

;##D31 An option is to remove std::threat
;##ROLE OP
;##INV F
;##FORM SOL
;##REL ELAB D30
;##SEN NEU

Remove all mention of std::thread and related things from llvm -- I believe this was done last time and tried / started to do this when testing freebsd in the beginning. From my impression / memories, I believe that this is not as easily done as last time.

;##D32 Or switch to mingw
;##ROLE OP
;##INV F
;##FORM SOL
;##REL ELAB D31
;##SEN NEU

Switch to pthread based mingw -- I'm not sure what the advantages / disadvantages are here. There are apparently reasons for not wanting to do this. Also, I previously tried a build with a pthread based mingw and got some link failures which would need to be debugged.

;##D33 or experiment with headers
;##ROLE OP
;##INV F
;##FORM SOL
;##REL ELAB D32
;##SEN NEU

We could experiment with some hacky? headers which apparently provide the necessary std::threads implementation however lack other things (futures / async / packaged_task or something).

>>>nagisa, Contributor

;##D34 WHat if we drop i686-pc-windows-gnu
;##ROLE ETC
;##INV T
;##FORM SOL
;##REL REFR D33
;##SEN NEU

Iâ€™d be inclined to just drop i686-pc-windows-gnu rustc builds altogether if its that troublesome. Except its a Tier 1 platform :/

Also, IIRC pthreads on 32 bit mingw are plain broken anyway.

>>>petrochenkov, Contributor

;##D35 mingw is a good solutio
;##ROLE ETC
;##INV F
;##FORM SOL
;##REL ELAB D32
;##SEN NEU

meganz/mingw-std-threads seems to be a commonly advised solution and the way to go in the short term (if it works).
It's not as crucial change as switching to pthread model, not so blatantly non-future proof as removing uses of std::thread from LLVM code, and it unblocks the progress towards 4.0.
Worths trying at least.

>>>vadimcn, Contributor

@TimNN: There were basically two reasons we've avoided pthread-based mingw-w64 toolchain:

;##D36 mingw caused problem with dependencies
;##ROLE ETC
;##INV F
;##FORM SOL
;##REL REFR D35
;##SEN NUE

It added a dependency on pthreads dll to all Rust programs compiled with this toolchain (mainly because Rust heavily relied on libc, which, in turn, used pthreads' sync primitives).

Back then it was found to be very slow, though it seems this may have been fixed since.

;##D37 We could swithc to phtread-based toolchain
;##ROLE ETC
;##INV F
;##FORM SOL
;##REL ELAB D36
;##SEN NEU

I wouldn't mind switching to pthread-based toolchain for building rustc itself, as long as 1. were still true.
I don't remember all the details at the moment, but it should be possible - these days libstd directly calls into native Windows API most of the time.

I'll try to find time to look into this in the next few days.

>>>alexcrichton, Owner

Yeah unfortunately this may end up being one of the more difficult parts of the LLVM upgrade (not that the parts leading up to this have been easy ...). @vadimcn is right in that we intentionally have not used the pthread toolchain yet for various reasons. The landscape is very different today though from way-back-when, notably MSVC is a thing that is also tier 1.

My thoughts on this are in order of preference (but not in order of feasibility):

;##D38 We should stop shipping i686-pc-windows-gnu
;##ROLE PM
;##INV F
;##FORM SOL
;##REL ELAB D34
;##SEN NEU

Ideally we stop shipping i686-pc-windows-gnu targets. MinGW just flat out is not supported by LLVM afaik, and yet we keep trying to get it to work. This is unfortunately a pretty invasive change though. While possible I think this is a last resort style option due to the work involved to implement this.

;##D39 Or we switch to pthread toolchain
;##ROLE PM
;##INV F
;##FORM SOL
;##REL ELAB D38
;##SEN NEU

Otherwise ideally I like @vadimcn's idea of compiling the compiler with a pthread toolchain. The hard constraint here is that a user-compiled program should not depend on the pthread dll and should be compatible with the win32 toolchain. Note that I think the dependency on the pthread dll arises from the unwinder, not Rust code nowadays. AFAIK libstd uses nothing fro the mingw runtime other than the unwinder (which is a pretty big piece ...)

I hadn't heard of the compiler @petrochenkov mentioned, but sounds plausible! I'm slightly wary of switching to a semi-random compiler to compile all our builds, but we may not have many other options.

;##D40 We could remove threading support for llvm
;##ROLE PM
;##INV F
;##FORM SOL
;##REL NEW
;##SEN NEU

Finally, we can look again to ripping out threading support from LLVM. We don't want LLVM to spawn threads anyway, and I believe most synchronization primitives at least are implemented in the i686-pc-windows-gnu win32 toolchain. This is obviously the most distasteful approach though.

Mostly I'm up for anything here. My only real hard constraint is that we can't impact users of the i686-pc-windows-gnu toolchain (e.g. the binaries they generate), but other than that I think we can pick whatever works first.

>>>TimNN, Contributor

The meganz/mingw-std-threads @petrochenkov Is the same thing I linked above -- basically just three headers, which provide thread, mutex and condition_variable. However LLVM uses other stuff as well, such as futures, async and packaged_task which are provided neither by mingw nor by these additional headers.

>>>TimNN, Contributor

I did a quick check on the x86_64-pc-windows-gnu which was compiled by msys2/mingw, which is the pthread/seh version as far as I can tell: According to dependency walker, rustc has a transitive dependency on winpthread through librustc_llvm -> libstc++6 -> winpthreads. libstd and a program compiled by that toolchain seem to be winpthread free.

Edit: Note that this was without statically linking libstdc++ into llvm.

>>>alexcrichton, Owner

Ah so the x86_64-pc-windows-gnu unwinder is very different than the i686-pc-windows-gnu unwinder, so it may be worth double checking i686. If libstd binaries picked up a dependency on winpthreads my guess is it'd be through that (the unwinder)

>>>TimNN, Contributor

Yeah, I don't think we can get around the pthread dependency on i686 easily, if at all. However I'm still happy that  we can probably get away with pthread/seh on x86_64-pc-windows-gnu.

Out of curiosity, do you have download / usage stats for the different windows versions of rust?

>>>alexcrichton, Owner

;##D41 Moving to pthread toolchain should work fine
;##ROLE PM
;##INV F
;##FORM SOL
;##REL ELAB D39
;##SEN NEU

Ah yeah so FWIW I think moving to compiling the compiler with a pthread/seh toolchain on x86_64 should work just fine. We'll have to update some script somewhere to distribute the new dll but that's no different than distributing the libstdc++ dll we do today. I'm pretty confident this toolchain switch will not affect programs compiled by the compiler (the unwinder is implemented in Rust and kernel32.dll, not in the mingw libraries)

Unfortunately we don't have many usage stats :(

>>>vadimcn, Contributor

;##D42 We cant kill -pc-windows-gnu until we migrate
;##ROLE ETC
;##INV F
;##FORM SOL
;##REL NEW
;##SEN NEU

-pc-windows-msvc targets depend on MSVC linker, so you need to have at least the MSVC Build Tools installed along with it.   I don't think we can kill  -pc-windows-gnu targets until we migrate to the lld linker or something.

>>>jonathandturner, Contributor

;##D43 IS there any advantage in having those?
;##ROLE ETC
;##INV F
;##FORM OPQ
;##REL ELAB D42
;##SEN NEU

@vadimcn - for sake of argument, since the VS tools are free, it seems they are roughly on par with the gnu tools in terms of being able to get and use them.  Since the access is the same, are there other advantages of the gnu tools?

>>>vadimcn, Contributor

;##D44 It might be needed when linking with c++ apis
;##ROLE ETC
;##INV F
;##FORM SOL
;##REL ELAB D43
;##SEN NEU

@jonathandturner: For one thing, you can install a complete -pc-windows-gnu toolchain with rustup, not so for -msvc.
-gnu may also be needed when linking with c++ libraries that do not build with MSVC.

>>>vadimcn, Contributor

So I tried building Rust with msys2's i686 mingw toolchain and it fails to link because of references to pthread functions from libgcc_eh.a.

>>>JordiPolo, Contributor

Maybe open a question in some very visible blog or reddit or somewhere like that about if anyone is in fact using i686-pc-windows-gnu?

>>>vadimcn, Contributor

I've managed to build the compiler with msys2's i686 mingw toolchain, but this required several manual steps.

First of all, since gcc's unwinder depends on pthreads, we'll need to add println!("cargo:rustc-link-lib=pthread"); after this line.

stage0 failed to build stage1 because it does not have the line above.  Setting RUSTC_FLAGS=-Clink-arg=-lpthread didn't seem to have any effect, so I fixed this by copying libgcc_eh.a and import libs from a nightly into stage0/lib/rustlib/i686-pc-windows-gnu/lib.

Using the newly built stage1 toolchain I compiled a test program, and found out that it depends on winpthread1.dll :(
Turns out gcc has both static and dynamic version of libpthread, and by default it prefers the dynamic one.   Fixed this by deleting libpthread.dll.a from msys/mingw32/i686-w64-mingw32/lib.

After all that my test program compiled and did not depend on winpthread dll.
Not sure how to fix 2. and 3. in rustbuild though...

>>>TimNN, Contributor

@vadimcn: Awesome! I thought that something along the lines of 1) and 2) should be possible, thanks for figuring that out!

;##D45 Does linking libpthread statically work?
;##ROLE OP
;##INV F<
;##FORM SOL
;##REL ELAB D41 
;##SEN NEU

@alexcrichton: Does linking libpthread statically sound like an acceptable solution to you?

I can look into the necessary rustbuild changes and would open a separate PR for that.

Regarding the slowness you mentioned, @vadimcn: I'll assume we would need a fairly recent mingw toolchain to get that fix? Live Edit: Ah you mentioned in #28445 (comment) that this was fixed in 6.2.0, so I assume we'd just go and use 6.3.0?

;##D46 do we have compatibility constraints on mingw's versions?
;##ROLE OP
;##INV F
;##FORM OPQ
;##REL NEW
;##SEN NEU

@alexcrichton: Do we have any compatibility constraints, which mingw version we use?

>>>vadimcn, Contributor

@TimNN: yes, the slowness seems to have been fixed.

;##D47 We could use these flags
;##ROLE ETC
;##INV F
;##FORM SOL
;##REL GEN D45
;##SEN NEU

To make sure that ld selects the static version of libpthread we could use -Wl,-Bstatic hint, except that I don't think you can inject it from a build script.  We'd have to switch to #[link_args=...].

>>>cuviper, Contributor

Build scripts can specifiy the "kind", with the same meaning as #[link] kind.  So you'd output:
cargo:rustc-link-lib=static=pthread

>>>alexcrichton, Owner

Yeah upgrading to 6.3.0 should be totally fine and linking libpthread statically seems ok.

;##D48 staitc-pthread is likely not usable
;##ROLE PM
;##INV F
;##FORM SOL
;##REL NEW
;##SEN NEU

;##D49 What about static-nobundle?
;##ROLE PM
;##INV F
;##FORM OPQ
;##REL REFR D48
;##SEN NEU

I, too, do not know how to deal with -Wl,-Bstatic. I unfortunately don't think we can use static=pthread like @cuviper mentioned as I think such a construction would cause the libstd to be incompatible with other non-6.3.0 toolchains. I wonder if maybe the static-nobundle type can be used in this case? I think technically gcc_eh should also be static-nobundle...

>>>vadimcn, Contributor

;##D50 What about static-nobundle?
;##ROLE PM
;##INV F
;##FORM OPQ
;##REL REFR D48
;##SEN NEU

I wonder if maybe the static-nobundle type can be used in this case? I think technically gcc_eh should also be static-nobundle...

Yeah, sounds like another use case for static-nobundle!   I don't think we currently do static hinting for them though.

>>>vadimcn, Contributor

Okay, I have a branch here that builds and passes tests (well, up until debug info tests) on msys's version of mingw.

Depends on #40524 for kind=static-nobundle

>>>alexcrichton, Owner

;##D51 Won't that patch breeak compatibility with win32 toolchain?
;##ROLE PM
;##INV F
;##FORM OPQ
;##REL NEW
;##SEN NEU

@vadimcn so just to clarify, I think that patch will break compatibility with win32 toolchains, right?

>>>vadimcn, Contributor

;##D52 Won't that patch breeak compatibility with win32 toolchain?
;##ROLE ETC
;##INV F
;##FORM OPQ
;##REL NEW
;##SEN NEU

I think that patch will break compatibility with win32 toolchains, right?

;##D53 It should continue workijng
;##ROLE ETC
;##INV F
;##FORM SOL
;##REL REFR D52
;##SEN NEU

I don't think so: win32 toolchains still include libpthread, they just don't use in std.

>>>alexcrichton, Owner

Excellent! A+ from me

>>>vadimcn, Contributor

@TimNN, do you want incorporate this into your PR, or should I submit it separately?

>>>TimNN, Contributor

@vadimcn: I think it would be best to land this separately. This PR will still take a bit of time -- There're still some test failures on ARM and I haven't yet really tested on macOS (although I plan to do so this weekend).

Also I think both PR have a high potential to causes trouble on the bots, so landing things in small chunks would be preferable, I think.

>>>arielb1, Contributor

@TimNN

If you are rebasing, remember to apply the fix in #40779 to your LLVM (or you'll get a test failure on ARM).

>>>TimNN, Contributor

@arielb1: Thanks for the heads up, this was already on my mental todo list :)

>>>TimNN, Contributor

I reported the PowerPC failure as https://bugs.llvm.org//show_bug.cgi?id=32485.

>>>TimNN, Contributor

I have a tentative (but probably a bit too heavy-handed for inclusion in upstream LLVM) fix for the PowerPC failure at TimNN/llvm@aa34b2c, which simply disables the bad optimisation in more situations.

With that patch PowerPC completes successfully.

>>>TimNN, Contributor

So, I also went back to the ARM failures:

To recap: compiler-rt got a few patches which added code specific for Thumb1. With those patches applied our builds were failing in strange ways.

I originally stated that our cross compiler had __ARM_ARCH_ISA_THUMB=2 defined, so those patches should not apply to us. Revisiting the issue I noticed that, due to us passing -march=armv6 to the compiler, it's actually using __ARM_ARCH_ISA_THUMB=1.

Thus my new fix is to patch gcc-rs to use -march=armv6t2.

This seems to fix the main problem on ARM and incidentally the jemalloc deadlock as well.

Still remaining are panic-runtime/abort.rs and run-pass/panic-runtime/abort-link-to-unwinding-crates.rs not terminating.

TODO:

;##D54 Should we adjust the config?
;##ROLE OP
;##INV F
;##FORM OPQ
;##REL NEW
;##SEN NEU

 Should we adjust the configs in dist-arm-linux to also set CT_ARCH_ARCH=armv6t2?

Now the real questions:

Is that the "correct" fix?

;##D55 Is it acceptable to do this?
;##ROLE OP
;##INV F
;##FORM OPQ
;##REL NEW
;##SEN NEU

Is it acceptable to upstream that patch to gcc-rs?

;##D56 Should we try to compile with armv6t2 isntead?
;##ROLE OP
;##INV F
;##FORM OPQ
;##REL ELAB  D55
;##SEN NEU

Or should we maybe try and compile just compiler-rt (and jemalloc?) with -march=armv6t2?

>>>alexcrichton, Owner

@TimNN I personally have no idea what the difference between armv6 and armv6t2 are, so I probably can't comment much to wheteher that's right or not. But hey if it makes things work it makes things work!

Adjusting dist-arm-linux is ok, although optional. It basically just affects how we compile jemalloc which isn't too too important if it's a little slower than it would be otherwise.

The powerpc patch also seems ok to me, but it'd be great if an LLVM dev could say "yeah seems fine" before we throw it in (it's good that we have an issue to track upstream as well)

>>>TimNN, Contributor

I'm currently debugging the panic-runtime/abort.rs hang: As previously stated it only occurs when RUST_BACKTRACE=1, it gets until _Unwind_Backtrace, where it apparently ends up in some complex endless loop.

As best as I can tell, our trace_fn is called repeated, with the exact same values in the registers and on the stack around $sp.

I have no idea what could be going on. There is a supposedly fixed gcc bug from 2014 which describes somewhat the same symptoms.

If someone wants to take a look, here is a link to the compiled abort test: https://transfer.sh/YJdCY/abort

Run with RUST_BACKTRACE=1 and foo as an argument and you should have an endlessly running program.

Hint: If gdb shows a broken backtrace (eg. only to entries in gcc_s.so) do stepi until you're out of gcc_s.so.

>>>alexcrichton, Owner

@TimNN I wonder if that's related to the super ancient toolchain we're using?

(or is that the other image...)

>>>TimNN, Contributor

@alexcrichton: No, we're actually using a fairly recent toolchain in that image:

On my test raspberry I have gcc 5.2.1.

>>>alexcrichton, Owner

Bah that's a bummer.. If worse comes to worse I think we should disable that test. It's a non-tier 1 platform and it's holding up the LLVM upgrade, which probably isn't worth it.

>>>alexcrichton, Owner

(disable that test for arm, that is)

>>>nagisa, Contributor

So, the Thumb2 thing is interesting, because sources seem to indicate it is a required extension in ARMv6, but then thereâ€™s no point in not having it enabled by default?

>>>TimNN, Contributor

I just patched both of those tests to set RUST_BACKTRACE=0 for the sub command executed, and all other tests passed. So I would just set RUST_BACKTRACE=0 conditionally on the arm target.

>>>alexcrichton, Owner

@TimNN that seems like a reasonable workaround to me at least, yeah.

Note that if we take that route we should file an issue to track fixing it, but that's ok.

>>>alexcrichton, Owner

guh didn't mean to close

>>>TimNN, Contributor

So, it appears that the thumb 1 implementation of (at least) __udivsi3 is simply incorrect, it doesn't even pass compiler-rt's unittests when compiled with -march=arm.

>>>TimNN, Contributor

With the -D__ARM_ARCH_ISA_THUMB=0 proposed by @nagisa in alexcrichton/gcc-rs#149 the compiler-rt unit tests pass as well, so I'll see what happens if I pass that to the compiler-rt build.

>>>TimNN, Contributor

I reported the bad Thumb1 builtin as https://bugs.llvm.org/show_bug.cgi?id=32492

>>>TimNN, Contributor

I've switched to a different fix for the ARM builtin failures: manually defining __ARM_ARCH_ISA_THUMB=0 in the compiler-rt build script, as suggested in alexcrichton/gcc-rs#149.

Note that this does not fix the panic-runtime/abort* failures, so extra path for them is still required.

>>>TimNN, Contributor

Since the linux builds seem to be done now (except for emscripten, I'll try to report that bug upstream this week) I've been looking into macOS today:

Except for one debuginfo test, everything passes!

The failing test is cross-crates-span.rs: The same generic function (from another crate) is called with different type parameters. The test sets a breakpoint in that function. The breakpoint in one of the instantiations of the generic function is not hit (I've experimented with different combinations).

I'll continue looking into that, though if anyone has any insights, please let me know.

>>>TimNN, Contributor

So, well, I checked, and cross-crates-span.rs fails for me with LLVM 3.9 as well, so I guess that's good news and I'll just assume it will pass on the bots.

The iOS build was successful as well, which means we should be getting pretty close to getting this merged.

This means I will be looking into Windows again next.

>>>alexcrichton, Owner

Thanks for the updates @TimNN! If you're feeling like this is getting close we can try throwing this at @bors.

>>>bors, Contributor

ðŸ”’ Merge conflict

>>>TimNN, Contributor

I reported the emscripten failure upstream with a minimised testcase: kripken/emscripten-fastcomp#176

>>>pnkfelix, Member

(FYI it is thought that landing this PR will fix #39015 . I mention this mostly so that this PR's status will show up on that ticket. ;)

>>>TimNN, Contributor

So just FYI, the test thats failing with emscripten & LLVM 4.0 actually fails as well on master when emscripten is compiled with debug assertions...

On the other hand, I think I've found the problem and a fix!

Update: Fix submitted at kripken/emscripten-fastcomp#177

>>>TimNN, Contributor

I've also submitted my initial patch for the PowerPC assertion to upstream llvm (D31790) and got some feedback on a better, more targeted fix. I'll switch to that once the review is done.

>>>cuviper, Contributor

It seems like you're getting really close!

Do you think this will be ready before 1.18 branches?

>>>TimNN, Contributor

So unless something has regressed, the only thing that requires more work is windows-gnu and I'll be working on that over the weekend so this PR will hopefully be ready by the end of next week at the latest. Which means it should be in time for 1.18.

The only thing that I can imagine delaying this PR to 1.19 is a deliberate decision to merge this after 1.18 has branched to have the full six weeks of nightlies to find any regressions.

>>>TimNN, Contributor

Lets make use of the empty queue:

Edit: Apparently @b_ors try isn't really functional here

>>>bors, Contributor

âŒ›ï¸ Trying commit 17e01d3 with merge 1781be5...

>>>TimNN, Contributor

Well... windows-gnu is proving to be terribly uncooperative.

As expected MinGW with Win32 threads doesn't work since it doesn't provide std::thread (c++). MinGW with Posix threads required some additional, manual linking of libpthread and libgcc_s (despite #40805) and now causes undefined reference to LLVMRustSetLLVMOptions, rustc_llvm::initialize_available_targets::hdba7e30f03a6524a with MinGW64. On MinGW32 llvm-tblgen.exe crashes...

;##D57 Why do we compile rustc with Mingc?
;##ROLE OP
;##INV F
;##FORM OPQ
;##REL NEW
;##SEN NEU

This led me to ask the question: Why do we even compile rustc with MinGW? Wouldn't std be enough? Thus I opened #41165 to discuss just that.

On another note, while the emscripten assertion has been fixed, the test still fails... I'll investigate a bit, but if nothing jumps out I'm inclined to just ignore the test for emscripten (at least for now).

>>>alexcrichton, Owner

@TimNN feel free to throw this at @bors if we've got an empty queue, we can at least test out and see how far it gets.

I'll comment on the reference issue about MinGW. tl;dr; we should try really hard to get it working as-is.

>>>bors, Contributor

ðŸ’¥ Test timed out

>>>TimNN, Contributor

;##D58 Does that mean staying with win32 threads or switching to pthread?
;##ROLE OP
;##INV F
;##FORM OPQ
;##REL NEW
;##SEN NEU

@alexcrichton: Does "working as-is" mean staying with Win32 Threads or does that include switching to pthread?

@vadimcn: I'm having trouble building my llvm40 branch (which has your patch applied) with MinGW with  Posix threads:

Linking rustllvm complains about missing pthread / tls symbols, though this can be fixed by adding cargo:rustc-link-lib={gcc_s,pthread} (also tried with static and static-nobundle)

Linking rustc complains about missing symbols (if the above is fixed):

Do you have any ideas?

For the record, I have configured rustc with: configure --enable-extended --enable-ninja --disable-manage-submodules --enable-locked-deps --enable-cargo-openssl-static --enable-llvm-static-stdcpp --enable-debug-assertions --enable-llvm-assertions --build=x86_64-pc-windows-gnu

;##D59 We should avoid throwing at bors
;##ROLE OP
;##INV F
;##FORM SOL
;##REL NEW
;##SEN NEU

(@alexcrichton: I don't think throwing at bors is useful yet, since the windows-gnu build fail fairly quickly, so all the other builds would be canceled)

Although I guess trying wouldn't hurt.

@bors r+

>>>bors, Contributor

ðŸ“‹ Looks like this PR is still in progress, ignoring approval

>>>TimNN, Contributor

@bors retry force

>>>bors, Contributor

ðŸ“‹ Looks like this PR is still in progress, ignoring approval

>>>bors, Contributor

ðŸ“‹ Looks like this PR is still in progress, ignoring approval

>>>TimNN, Contributor

@bors r+

>>>bors, Contributor

ðŸ“‹ Looks like this PR is still in progress, ignoring approval

>>>cuviper, Contributor

Perhaps bors is deterred by WIP in the title?

>>>petrochenkov, Contributor

Perhaps bors is deterred by WIP in the title?

Exactly.

>>>TimNN, Contributor

Ugh. I thought this was somehow related to the 'try', which previously bors thought had timed out.

Thanks for the heads up!

>>>vadimcn, Contributor

@TimNN: I've managed to build at least stage1, though with current LLVM snapshot not with your branch.
Also, I used cargobuild (i.e. configured it via config.toml), not configure.

;##D60 Did you use the toolchain of msys2?
;##ROLE ETC
;##INV F
;##FORM OPQ
;##REL NEW
;##SEN NEU

Did you use the toolchain packaged by msys2, or a standalone one (e.g. from mingw-builds)?
Did you rebuild LLVM?

>>>TimNN, Contributor

;##D61 We're currently sing the msys2
;##ROLE OP
;##INV F
;##FORM SOL
;##REL ELAB D60
;##SEN NEU

@vadimcn: I'm using the mingw shipped with msys2.

I can build the current master just fine, the errors only occur on my branch.

Did you rebuild LLVM?

I started in a clean build directory, so I'd say that counts as a yes.

>>>TimNN, Contributor

@vadimcn: BTW, the only potentially important thing in that configure line is probably --enable-llvm-static-stdcpp, although again, that works just fine on rust master.

>>>vadimcn, Contributor

;##D62 Is the only combination not working pthreads mingws on your breanch?
;##ROLE ETC
;##INV F
;##FORM OPQ
;##REL NEW
;##SEN NEU

@TimNN: are you saying that the only combination that doesn't work is pthreads mingw + your branch?

>>>TimNN, Contributor

@vadimcn:

master + MingGW Win32 Threads: Presumably works

master + Msys2 MinGW (Posix Threads): Works

llvm40 + MinGW Win32 Threads: Doesn't work (missing std::thread (c++) support

llvm40 + Msys2 MinGW (Posix Threads): Doesn't work (see errors above)

>>>vadimcn, Contributor

I've repro'd the linker error. This is very strange - these 4 symbols are exported from rustc_llvm-XXXXXXX.dll

>>>vadimcn, Contributor

these 4 symbols are exported from rustc_llvm-XXXXXXX.dll

Actually, it seems that I was wrong abut that.  After rebuilding everything from scratch, I found that rustc_llvm-XXXXXXX.dll exported only a handful of symbols, all of them from emscripten's "Relooper" library (e.g. rl_new_relooper).

Why had this happened?  This page gives the answer:

By default ld exports symbols with the auto-export functionality,
[...]
If, however, -export-all-symbols is not given explicitly on the command line, then the default auto-export behavior will be disabled if either of the following are true:

A DEF file is used.

Any symbol in any object file was marked with the __declspec(dllexport) attribute.

As it happens, Relooper's public API is marked with __declspec(dllexport) and so all other symbols become private.
I found it a bit hard to believe that this is the first time we are coming across this case, but setting RUSTFLAGS=-CLink-arg=-Wl,--export-all-symbols did fix the build.

>>>TimNN, Contributor

@vadimcn: Awesome, thanks for the investigation!

>>>TimNN, Contributor

So how do we best fix this?

With my admittedly limited understanding of the situation, we have multiple choices, I think:

Fix this for rustbuild only:

Use RUSTFLAGS
Update cargo to support adding -Clink-arg=... from the build script of rustc_llvm
Hack something together with #[link_args=...] and features set in the build script of rustc_llvm

Fix this in rustc:

on mingw, always pass --export-all-symbols

cc @alexcrichton, @retep998

>>>retep998, Member

;##D63 We should use an explicit DEF file
;##ROLE PM
;##INV F
;##FORM SOL
;##REL NEW
;##SEN NEU

@TimNN What we should be doing is using an explicit DEF file or linker script for dylibs, the way we currently do for cdylibs on all platforms, and dylibs for msvc.

>>>alexcrichton, Owner

Spoke briefly with @TimNN on IRC about this. First off awesome find @vadimcn, that sounds notoriously hard to track down!

Looks like the dllexport may be coming from the LLVM source itself, so @TimNN is going to run a test where we just comment that out in our forked version of LLVM and see if it work.

>>>vadimcn, Contributor

;##D64 Removing dllexports would be the quickest fix
;##ROLE ETC
;##INV F
;##FORM SOL
;##REL NEW
;##SEN NEU

Removing dllexports from relooper symbols would be the quickest fix in this case.

;##D65 We shoudl start passing --experot-all symbols or provide a list of exports 
;##ROLE ETC
;##INV F
;##FORM ENU
;##REL NEW
;##SEN NEU

To fix it robustly, we should either start passing --export-all-symbols when linking Rust dylibs, or provide an explicit list of exports as @retep998 suggests.
In either case well need a separate fix for stage0.  #[link_args("-Wl,--export-all-symbols")] in rustc_llvm would probably work.

>>>alexcrichton, Owner

;##D66 We should avoid changing linker invocations
;##ROLE PM
;##INV F
;##FORM SOL
;##REL REFR D65
;##SEN NEU

I would prefer to avoid changing linker invocations in this PR itself, those have a high likelihood for causing breakage. Let's defer that to later if the removing dllexport fixes the issue.

>>>TimNN, Contributor

@bors r+

Lets see what the bots say, (this includes an exit 1) to deliberately fail the build.

>>>bors, Contributor

ðŸ“Œ Commit f0b2b7b has been approved by TimNN

>>>bors, Contributor

âŒ›ï¸ Testing commit f0b2b7b with merge 54e8328...

>>>bors, Contributor

ðŸ’” Test failed - status-appveyor

>>>TimNN, Contributor

Appveyor fails with this:

If I remember correctly, I've encountered this previously when using a 32bit MinGW from sourceforge. I'll see if I can reproduce this again.

>>>TimNN, Contributor

I couldn't reproduce the tablegen failure locally, however appveyor seems to fail consistently (I tried different mingw versions as well):

https://ci.appveyor.com/project/TimNN/rust/history

I had the .dmp file uploaded to https://transfer.sh/x9pLn/foo.dmp,

I uploaded that dump file to http://www.osronline.com/page.cfm?name=analyze, however the only useful thing I could gleam from the output was that it was apparently caused by a null pointer.

At this point I'm kinda out of ideas, anyone any thoughts?

>>>ranma42, Contributor

That looks similar to http://lists.llvm.org/pipermail/cfe-dev/2016-December/051980.html (i.e. it might be caused by a miscompilation).

>>>TimNN, Contributor

@ranma42: Nice find! I'll try the suggested workaround (compile with -fno-omit-frame-pointer) soon.

>>>TimNN, Contributor

Lets give this anothet try, since my test build has passed the critical point.

@bors r+

>>>bors, Contributor

ðŸ“Œ Commit ce1be7a has been approved by TimNN

>>>bors, Contributor

âŒ›ï¸ Testing commit ce1be7a with merge 23806c7...

>>>bors, Contributor

ðŸ’” Test failed - status-appveyor

>>>TimNN, Contributor

Ugh. I think I lost a small patch during a rebase, I'll fix that once I'm back at a computer.

>>>TimNN, Contributor

@bors r+

>>>bors, Contributor

ðŸ“Œ Commit 5a4475c has been approved by TimNN

>>>bors, Contributor

âŒ›ï¸ Testing commit 5a4475c with merge 00d3310...

>>>bors, Contributor

ðŸ’” Test failed - status-travis

>>>nagbot-rs, 

test

â€¦

-Manish
On Mon, Apr 17, 2017 at 8:34 PM, bors ***@***.***> wrote:
 ðŸ’” Test failed - status-travis
 <https://travis-ci.org/rust-lang/rust/builds/222763352>

 â€”
 You are receiving this because you are subscribed to this thread.
 Reply to this email directly, view it on GitHub
 <#40123 (comment)>, or mute
 the thread
 <https://github.com/notifications/unsubscribe-auth/AaPN0Kuy9f0sbrekekYDjuG1eNDbXt1_ks5rw1xQgaJpZM4MNOAe>
 .

>>>arielb1, Contributor

#40417 (not sure)

let's see: @bors retry

>>>bors, Contributor

âŒ›ï¸ Testing commit 5a4475c with merge 89bf584...

>>>arielb1, Contributor

@bors r+

>>>bors, Contributor

ðŸ“Œ Commit 469755e has been approved by arielb1

>>>arielb1, Contributor

@bors retry

>>>bors, Contributor

âŒ›ï¸ Testing commit 469755e with merge 5e19fd3...

>>>TimNN, Contributor

@alexcrichton: I went through all the merged PRs newer than rust-lang/llvm#34 and cherry-picked those not in my branch except rust-lang/llvm#68 (that hasn't landed on rust-lang/master yet) and rust-lang/llvm#37 (that had merge conflicts and I wasn't sure how applicable it still was).

If those don't cause any problems with bors I think this is good to go, but I'll leave the final r+ to you.

>>>TimNN, Contributor

(Grrr. I wasn't done yet GitHub)

One open question remains: Given that the next beta is cut in 11 days, should we postpone merging this until after the beta (to give more time to find and fix any regressions)?

NB: this PR currently still includes a deliberate failure to allow running tests without actually merging it.

>>>bors, Contributor

ðŸ’” Test failed - status-travis

>>>TimNN, Contributor

@bors retry

>>>bors, Contributor

âŒ›ï¸ Testing commit 469755e with merge a32a973...

>>>bors, Contributor

ðŸ’” Test failed - status-travis

>>>arielb1, Contributor

>>>arielb1, Contributor

@bors r+

>>>bors, Contributor

ðŸ“Œ Commit af12199 has been approved by arielb1

>>>bors, Contributor

âŒ›ï¸ Testing commit af12199 with merge 0470cbf...

>>>bors, Contributor

ðŸ’” Test failed - status-appveyor

>>>TimNN, Contributor

Things are looking good, I'd say: The first appveyor bot (64bit MinGW deploy) ran succesfully (and hit the exit 1 I put a the and, which cancelled the other bots).

Should we try again with finish-fast set to false in appveyor.yml?

>>>arielb1, Contributor

@TimNN

You can add a echo YAY; sleep 10000 to get results on all the bots.

>>>TimNN, Contributor

@arielb1: Good idea, I hadn't though of that (although we probably want to do that in a loop so the builds aren't canceled from a lack of output)

>>>TimNN, Contributor

@bors r+

Lets test this again, this time with an infinite sleep loop at the end so that tests aren't prematurely canceled.

>>>bors, Contributor

ðŸ“Œ Commit 20926e5 has been approved by TimNN

>>>alexcrichton, Owner

Looking great as usual @TimNN, thanks so much for sticking with this!

A few requests for the LLVM submodule:

Could you expand the commit message for rust-lang/llvm@4275d89?

Could you mention the breakage seen in rust-lang/llvm@20acd70? (notably @vadimcn's comment, or a link to that would be great)

Could you remove the PR merge commits? (should be ok to just cherry-pick the actual commits)

Dropping the jemalloc bits should be fine, I'm dubious that optimization ever kicked in anyway.

;##D67 Does using the llvm tip causes problems with emscripten?
;##ROLE PM
;##INV F
;##FORM OQP
;##REL NEW
;##SEN NEU

I'd also idly muse that there's no real reason to use the literal release_40 branch. We could reduce the stack of patches by a lot I think by just using LLVM tip (as of like right now). I think that'd cause problems with emscripten though, right? (different merge bases) It seems like we should also stick with the current merge base as you've already done all the testing. You should mostly disregard this paragraph.

The compiler-rt submodule looks a little suspicious though, so I just wanted to confirm. I think the following PRs are missing from the rust-2017-04-13, was that intentional? (I don't recall upstreaming many of these...)

rust-lang/compiler-rt#24 - UB with INT_MIN in an intrinsic

rust-lang/compiler-rt#26 - was this fixed upstream in LLVM, right?

rust-lang/compiler-rt#27 - infinite recursion on FreeBSD in an intrinsic

rust-lang/compiler-rt#28 - fixing rust-lang/compiler-rt#27 I think?

rust-lang/compiler-rt#31 - more mystery on sparc?

One open question remains: Given that the next beta is cut in 11 days, should we postpone merging this until after the beta (to give more time to find and fix any regressions)?

Yeah if you're ok with it I'd prefer to stay conservative here and wait until after beta is branched (should happen late next week) before merging this. This looks like it's got a lot of potential for accidental regressions!

Although it may be good to at some point categorize the number of bugs this (the upgrade to LLVM 4.0) fixes. If it fixes enough bugs we may wish to land it for beta and deal with the backports.

>>>TimNN, Contributor

Could you expand the commit message for rust-lang/llvm@4275d89?

Sure (this has also been upstreamed to emscripten).

Could you mention the breakage seen in rust-lang/llvm@20acd70? (notably @vadimcn's comment, or a link to that would be great)

Of course. I'll add a link to @vadimcn's comment to the comment added in that commit.

Could you remove the PR merge commits? (should be ok to just cherry-pick the actual commits)

That's what I had originally when @arielb1 requested on IRC I use the merge commits so that the original PR number was linked from the cherry picks. Although I can easily go back to the non merge commit version.

The compiler-rt submodule looks a little suspicious though.

Ugh. Yeah, thanks for the reminder, I honestly didn't even look at compiler-rt submodule.

One open question remains: Given that the next beta is cut in 11 days, should we postpone merging this until after the beta (to give more time to find and fix any regressions)?

Yeah if you're ok with it I'd prefer to stay conservative here and wait until after beta is branched (should happen late next week) before merging this. This looks like it's got a lot of potential for accidental regressions!

Yeah I'm totally fine with postponing (the bitrot potential for this PR is luckily pretty low).

>>>alexcrichton, Owner

I use the merge commits so that the original PR number was linked from the cherry picks

That actually sounds very reasonable, let's leave as is.

>>>frewsxcv, Member

@bors r+

Lets test this again, this time with an infinite sleep loop at the end so that tests aren't prematurely canceled.

Instead of holding up the queue, you could also just conditionally turn on whichever builders you want for this pull request by temporarily adding ALLOW_PR=1 here https://github.com/rust-lang/rust/blob/master/.travis.yml#L15-L49

>>>bors, Contributor

ðŸ’¡ This pull request was already approved, no need to approve it again.

There's another pull request that is currently being tested, blocking this pull request: #41363

>>>bors, Contributor

ðŸ“Œ Commit 20926e5 has been approved by frewsxcv

>>>frewsxcv, Member

@bors r=TimNN

>>>bors, Contributor

ðŸ’¡ This pull request was already approved, no need to approve it again.

There's another pull request that is currently being tested, blocking this pull request: #41363

>>>bors, Contributor

ðŸ“Œ Commit 20926e5 has been approved by TimNN

>>>TimNN, Contributor

@frewsxcv: Yeah, I know, but right now the most important bit is appveyor (and seeing if the latest llvm backports broke any of the other bots), so r+ is the best way to go here as far as I know.

>>>bors, Contributor

âŒ›ï¸ Testing commit 20926e5 with merge 83059b5...

>>>bors, Contributor

ðŸ’” Test failed - status-appveyor

>>>arielb1, Contributor

#40546

@bors retry

>>>bors, Contributor

âŒ›ï¸ Testing commit 20926e5 with merge 146430a...

>>>bors, Contributor

ðŸ’” Test failed - status-appveyor

>>>retep998, Member

That looks like a resounding success to me. Build died at exactly 3 hours when the timeout was hit.

>>>TimNN, Contributor

That looks like a resounding success to me. Build died at exactly 3 hours when the timeout was hit.

Yay! I checked all the logs and they indeed show that all builds were successful ðŸŽ‰

>>>Kixunil, ðŸ‘Ž
            1

@TimNN did someone hire you to do this or did you do it in your free time? If someone hired you, could you disclose your employer?

>>>TimNN, Contributor

@Kixunil: Nope, not being payed for this. Just started it and stubbornly stuck with it.

>>>Kixunil, Other

Awesome! Thank you very much! I look forward to being able to target AVR... :)

>>>copumpkin, Other

This is great, thanks! As someone not familiar with LLVM release process, is there an ETA on when this will end up in a release?

>>>TimNN, Contributor

I look forward to being able to target AVR.

Yeah, wanting to experiment with rust on ARM AVR (without having to build a custom compiler) was one the motivating factors in me starting this.

@copumpkin:

The current plans are as follows, as far as I am aware:

This will be available on nightly once the next beta has branched (in about a week) and then make its ways to beta in about 7 weeks and to stable in about three months.

>>>alexcrichton, Owner

@TimNN congratulations! That's awesome news that we've got green lights across the board (and warm sccache caches now).

Did you wanna take care of the last few compiler-rt patches? I don't mind taking care of them either if you've run out of time for this :)

>>>TimNN, Contributor

@alexcrichton: I can take care of the compiler-rt patches, although probably not until this weekend, which I guess is fine given that we want to wait until after the beta has branched before we merge this.

If you want them done earlier I won't mind if you do them.

>>>alexcrichton, Owner

Nah sounds good to me!

>>>mrhota, Contributor

@alexcrichton @TimNN what's this about compiler-rt patches? It seems like most work on this issue is happening in other repos, and perhaps on non-master branches, but there's nothing written down anywhere that I can see. Could y'all provide links or relevant information so we can see what work went into this issue?

>>>alexcrichton, Owner

@mrhota oh you can find the list of patches here: https://github.com/rust-lang/compiler-rt/commits/rust-llvm-2016-07-18

(note that's the branch corresponding to the commit of the compiler-rt submodule in the rust-lang/rust repo)

>>>TimNN, Contributor

@alexcrichton: I think I incorporated all your feedback:

;##D68 to_string is no longer necesary
;##ROLE PM
;##INV F
;##FORM SOL
;##REL NEW
;##SEN NEU

The to_string commit / backport is no longer necessary, since it's part of the new emscripten merge (see below)

I updated the comment regarding the dllexport

I pushed the five PR's mentioned to the compiler-rt branch (I also had a quick look over the others compiler-rt PR's and didn't find any others that seemed relevant and weren't upstreamed).

Since I had to rebase the LLVM submodule anyway to edit the commit message, I:

cleaned up the older LLVM submodule commits as well, so that every rust modification now has a merge commit with pull request number (with two old exceptions).

updated the llvm base to 4.0.1

update the fastcomp base to 1.37.10

The always fail is still active, so lets test this PR again:

@bors r+

>>>bors, Contributor

ðŸ“Œ Commit 516d3a0 has been approved by TimNN

>>>bors, Contributor

ðŸ’¡ This pull request was already approved, no need to approve it again.

There's another pull request that is currently being tested, blocking this pull request: #41485

>>>bors, Contributor

ðŸ“Œ Commit 516d3a0 has been approved by TimNN

>>>bors, Contributor

âŒ›ï¸ Testing commit 516d3a0 with merge f857be8...

>>>bors, Contributor

ðŸ’” Test failed - status-appveyor

>>>TimNN, Contributor

@bors retry

ar.exe failure

>>>bors, Contributor

âŒ›ï¸ Testing commit 516d3a0 with merge ad3f352...

>>>bors, Contributor

ðŸ’” Test failed - status-appveyor

>>>TimNN, Contributor

Yay, looks like all the builds timed out again, so things seem to be good to go. (I didn't verify all the logs this time).

>>>alexcrichton, Owner

@TimNN looks great to me!

I hope to branch beta later today, so want to pull out the fast-fail? I'll r+ this after the beta is branched.

I'd also like to reiterate that you're at least my own personal "Rust Hero of the last N Months" where N is two and counting. If we delay this for 3 more days then it'll be a 2+ month PR!

>>>TimNN, Contributor

@alexcrichton: I removed the always fail commit.

I'd also like to reiterate that you're at least my own personal "Rust Hero of the last N Months" where N is two and counting. If we delay this for 3 more days then it'll be a 2+ month PR!

Thanks a lot! All the positive encouragement and feedback has helped a lot in keeping me motivated to work on the upgrade :).

>>>Kixunil, Other

I'd also like to reiterate that you're at least my own personal "Rust Hero of the last N Months"

Mine too! :)

>>>alexcrichton, Owner

@bors: r+

Beta's branched, let's do this!

>>>bors, Contributor

ðŸ“Œ Commit 8994277 has been approved by alexcrichton

>>>bors, Contributor

âŒ›ï¸ Testing commit 8994277 with merge 0777c75...

>>>bors, Contributor

â˜€ï¸ Test successful - status-appveyor, status-travis
Approved by: alexcrichton
Pushing 0777c75 to master...

>>>brson, Contributor

Thanks for slogging through this @TimNN.

>>>BatmanAoD, Other

Congratulations @TimNN!

>>>DemiMarie, Contributor

Thank you @TimNN!

>>>michaelwoerister, Contributor

ðŸŽ‰

>>>pkphilip, Other

Wow! Thanks a lot @TimNN! That is some effort!

>>>Kixunil, Other

I've just noticed that README mentions clang 3.x. Shouldn't this be updated?

>>>rkruppe, Contributor

@Kixunil That part of the readme is about the C and C++ compiler used for compiling C and C++ dependencies during the build, not about the LLVM version.

>>>Kixunil, Other

@rkruppe I guess I'm too hungry and tired. Thank you for pointing that out! :)

