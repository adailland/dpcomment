>>>michaelwoerister, Contributor


This PR changes the way symbol names are generated by the compiler. The new algorithm reflects the current state of the discussion over at rust-lang/rfcs#689.


Once it is done, it will also fix issue #30330. I want to add a test case for that before closing it though.


I also want to do some performance tests. The new algorithm does a little more work than the previous one due to various reasons, and it might make sense to adapt it in a way that allows it to be implemented more efficiently.



;##D1 It would be to know if DefPath refers something in a crate
;##ROLE OP
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

@nikomatsakis: It would be nice if there was a way of finding out if a DefPath refers to something in the current crate or in an external one. The information is already there, it's just not accessible at the moment. I'll probably propose some minor changes there, together with some facilities to allow for accessing DefPaths without allocating a Vec for them.


TODO




Actually "crate qualify" symbols, as promised in the docs.


Add a test case showing that symbol names are deterministic.


Maybe add a test case showing that symbol names are stable against small code changes.


;##D2 Is there any benefit in sticking to SHA?
;##ROLE OP
;##INV F
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

One thing that might be interesting to the @rust-lang/compiler team:
I've used SipHash exclusively now for generating symbol hashes. Previously it was only used for monomorphizations and the rest of the code used a truncated version on SHA256. Is there any benefit to sticking to SHA? I don't really see one since we only used 64 bits of the digest anyway, but maybe I'm missing something? ==> Just switched things back to SHA-2 for now.


>>>rust-highfive, Collaborator


r? @Aatch


(rust_highfive has picked a reviewer for you, use r? to override)


>>>bluss, Contributor



;##D3 Siphash is not the same category of has as SHA
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D2
;##SEN NEU

SipHash it is an algorithm designed by cryptographers, but it's not in the same category of hash functions as SHA-2 which is a cryptographic hash function.


For example, the SipHash paper says




In general, building a MAC from a general-
purpose cryptographic hash function appears to be a highly suboptimal ap-
proach: general-purpose cryptographic hash functions perform many extra com-
putations for the goal of collision resistance on public inputs, while MACs have
secret keys and do not need collision resistance.




and




We comment that SipHash is not meant to be, and (obviously) is not, collision-
resistant.





;##D4 Only SHA is deisgned for some cases
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D3
;##SEN

This use case does not use a secret key with SipHash (it always uses the default key), and it wants to have collision resistance on public inputs. Yes, in practice, we can find collisions for either of them if the hash is only 64 bits long, but only SHA-2 is designed for this case.


>>>michaelwoerister, Contributor



;##D5 It seems Siphash is nto a good candidate to replace sha
;##ROLE OP
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D4
;##SEN NEU

@bluss Those are good references. It really sounds like SipHash is not a good candidate for this use case. I'll switch things to SHA-2.


>>>bluss, Contributor



;##D6 What is the impace of a collision?
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

What's the impact of a collision?


>>>bors, Contributor


☔️ The latest upstream changes (presumably #31487) made this pull request unmergeable. Please resolve the merge conflicts.


>>>michaelwoerister, Contributor




What's the impact of a collision?





;##D7 A collision could cause compilation errors or memory corruption
;##ROLE OP
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D6
;##SEN NEU

Symbol conflicts: Two functions with different signatures could end up with the same name. If it's in the same crate, compilation will probably just fail. If it's in different crates, either linking fails due to a conflict or the wrong symbol might be linked, resulting most probably in untraceable, subtle memory corruption.


>>>nikomatsakis, Contributor


Nice.


>>>nikomatsakis, Contributor


cc @alexcrichton @brson


>>>alexcrichton, Owner


This looks fantastic to me, nice work @michaelwoerister!



;##D8 Both SHA and Siphash should be suitable
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL REFR D5
;##SEN NEU

I wouldn't have too many opinions about SHA2 vs SipHash, I suspect either choice will be suitable for our purposes. I'd personally love to jettison the SHA2 implementation in the compiler, and I highly doubt we can find a SipHash practical collision with the same path, different metadata, and yet something like different type substitutions. We should also be able to change this if we ever need to really as we can only guarantee no recompiles within one version of Rust anyway.


>>>michaelwoerister, Contributor



;##D9 We have been using siphash for a while without problems
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL EALB D8
;##SEN NEU

Thanks for the comment @alexcrichton. It's true, we have been using SipHash for function monomorphization for quite a while now and I've never seen a problem with that.



;##D10 We should aim for low collision and not care about security
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

My assumption about the requirements for this hash function (and later also one used for fingerprinting incremental compilation artifacts) is that it should provide good distribution so that collision probability is as low as it can theoretically be for a given number of hash value bits, BUT that we don't care about  "security", i.e. whether it's easy to find hash collisions on purpose. Or is there some kind of "attack scenario" that I'm overlooking?


;##D11 We could use CRC64 To maximize perofrmances
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D10
;##SEN NEU

For maximum performance (and if the above assumptions hold), we could also use something like CRC64.
Anyway, I think for this PR, I'll just leave SHA-2 in.


>>>bluss, Contributor


Here's the issue about collisions in type_id, but that's only tangential to this: #10389. As long as we go into this with the knowledge that SipHash is just a regular hash function, I'm fine.


>>>michaelwoerister, Contributor


@bluss Thanks for the link!


>>>michaelwoerister, Contributor



;##D12 "-C metadata" is a mismoner, should be changed
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU
;##D13 We could replace it with "salt" or "disambiguator"
;##ROLE OP
;##INV T
;##BCOM T
;##FORM ENU
;##REL ELAB D12
;##SEN  NEU

As an aside, I think "-C metadata" is a bit of a misnomer. Something like "-C salt" or "-C disambiguator" would be clearer (although the later one definitely is too long).


>>>michaelwoerister, Contributor



;##D14 We might want to cross-crate share symbol names
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

Another side note: Now that we get predictable symbol names for monomorphizations, we might want to start sharing them cross-crate.


>>>alexcrichton, Owner



;##D15 Siphash is also used extensively in Cargo
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D9
;##SEN NEU

Ah as another data point in Cargo we extensively use SipHash for fingerprinting crates and packages. I haven't at least seen anyone run into any problems with that.



;##D16 It would be hard ot rename -C metadata because it is used a lot
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL REFR D12
;##SEN NEU

I also agree that at this point -C metadata is basically just wrong, but I don't think we can rename due to the extensive usage in Cargo right now :(


>>>bors, Contributor


☔️ The latest upstream changes (presumably #31524) made this pull request unmergeable. Please resolve the merge conflicts.


>>>arielb1, Contributor



;##D17 What is the problem with the compiler SHA2 implementation?
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM OPQ
;##REL ELAB D8
;##SEN NEU
;##D18 It is really eas to get a collision with siphash
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL REFR D8
;##SEN NEU

What's the problem with the compiler SHA2 implementation? Making a collision with SipHash with a known key only requires some modifiable string on both ends - e.g. an item name, or comment.


>>>michaelwoerister, Contributor



;##D19 The implementation of SHA-2 is just incomplemente
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D17
;##SEN NEU
;##D20 The risk of collision is the only reason we would remove siphash
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D18
;##SEN NEU

@arielb1 I don't think anything is wrong with the SHA-2 implementation per se. It's just incomplete (only supports SHA256) and it's one more piece of code that needs to be maintained. I'd guess that second point is the main motivation for wanting to get rid of it.


>>>michaelwoerister, Contributor



;##D21 While before it was allowed to have crates with the same name, now it is not and it generates an error
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

So, here's something interesting: Some of the test cases (e.g. run-pass/typeid-intrinsic.rs) link to an external crate that has exactly the same name, and thus the crate graph ends up with two identical crates in it. So far, this was no problem because the two crates still have a different SVH but under the new scheme, two crates are considered the same if they have the same name/metadata pair.



;##D22 We should throw a compliation error instead of a linker errors
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D21
;##SEN NEU

The tests now fail with 'duplicate symbol' linker errors, but I guess the sensible thing to do here, is to emit a compilation error when the crate loader discovers two crates with the same name/metadata but different SVHs.


>>>michaelwoerister, Contributor



;##D23 Does anyone has any idea why the backtrace.rs test case fails?
;##ROLE OP
;##INV T
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

Up until that last commit this passes make check for me locally, with the last commit it looks good too, except that the run-pass/backtrace.rs test case fails (it seems to panic while trying to write the backtrace). Does anybody have an idea what that could be about? In general, creating backtraces seems to work just fine...


>>>michaelwoerister, Contributor


That's the error in question: https://travis-ci.org/rust-lang/rust/builds/109449298#L6591


>>>alexcrichton, Owner



;##D24 The test should be updated to check for backtrace::foo isntead of just foo
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D23
;##SEN NEU

Oh you should just be able to update the test to check for backtrace::foo instead of only foo, I believe that previously the crate name was never on symbols, just in the debug description of symbols.


>>>michaelwoerister, Contributor



;##D25 IT seems to be caused by something more complicated
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL REFR D24
;##SEN NEU

@alexcrichton I'm afraid it's something more complicated than that. If you look at the actual backtrace that the subprocess provides (see below), it looks like there is a panic while creating the backtrace (in std::sys::backtrace::tracing::imp::write in gcc_s.rs). Something causes an error there.




>>>alexcrichton, Owner



;##D26 That seems normal, just caused by the wrong assertion
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL REFR D25
;##SEN NEU

Hm, that looks normal to me though? It looks like the assertion message originates from here which was testing a panic originating here. The bad output happened because it expected to find - foo where it instead printed - backtrace::foo.



;##D27 We might want to cut the first few frames when printing backtraces
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D26
;##SEN NEU

In other words we should probably really look into skipping the top few frames when printing a backtrace, but other than that it should be good!


>>>michaelwoerister, Contributor


Yes, you're right of course :)
The test passes just fine now.


>>>michaelwoerister, Contributor

;##D28 The error added for the new linker errors is more conservative than it needs to be
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

So, commit 545cc8f adds an error to the compiler that is meant to make it easier to understand the new kinds of linker errors that are possible now with the new symbol naming scheme.
However, the condition on which the error is emitted is more conservative than it strictly needs to be:
When the graph of crates being compiled contains two different crates with the same 'crate-name' and the same set of -Cmetadata provided salts, the compiler errors out, since then symbol conflicts can occur. In many cases though, there wouldn't be any conflicts because the crates don't define the same items.



;##D29 Adding this error will consistute a breaking change
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D28
;##SEN NEU

At the moment we allow these crate graphs, so adding this error will constitute a breaking change. I think, it's a good idea to be conservative here, since it semantically is a conflict trying to compiler two different crates with the same "identifier", but I wanted to make sure that this is indeed what we want to do here.


>>>alexcrichton, Owner



;##D30 Should we consider crate-type as well?
;##ROLE PM
;##INV T
;##BCOM T
;##FORM OPQ
;##REL REFR D28
;##SEN NEU
;##D31 Could this brrak in practice?
;##ROLE PM
;##INV T
;##BCOM T
;##FORM OPQ
;##REL ELAB D30
;##SEN NEU

Good idea @michaelwoerister! I wonder though, as evidenced by the large number of test renames, maybe we want to somehow consider crate-type as well? I think that this may actually affect Cargo as well because we'll commonly have a project with both a library and a binary of the same crate name and also both of which have the same -C metadata. In retrospect perhaps not the best forward thinking there, but could mean that this could break in practice?


>>>michaelwoerister, Contributor



;##D31 That change seems a bit ad hoc
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL REFR D30
;##SEN NEU

Hm, it seems a bit ad hoc to make the crate-type part of the crate identifier. In the Cargo case you talked of, will the library and binary versions of a crate ever show up in the same crate graph? If so, couldn't Cargo take care of incorporating the crate-type by specifying an additional corresponding -C metadata option? Do we give any guarantees as to with which -Cmetadata values a crate will end up with?



;##D32 Hard-coding the crate-type seems unecessary
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D31
;##SEN NEU

The reason why I'm a bit reluctant to hard-coding the crate-type into symbol hashes, is that right now we have a very simple and straightforward model: a crate is identified by its name and, if further disambiguation is needed, the salt provided via -Cmetadata.  The salting mechanism is so general that it can be used in place of any other mechanism, and so it feels to me like we are unnecessarily muddling things if we start to incorporate other things into the salt as well.


>>>alexcrichton, Owner



;##D33 But this case comes up often enough to justify an ad-hoc solution
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D31
;##SEN NEU
;##D34 But it might older cargos to not compile anymore
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D33
;##SEN NEU

Yeah it's true that it feels ad-hoc, but this comes up pretty frequently I believe because binary crates in Cargo often link to their library counterparts. Cargo could definitely pass -C metadata, but currently all existing cargo binaries don't. It would basically mean that an older Cargo could not work with a newer compiler (which Cargo currently relies on for snapshots).



;##D35 We could land the cargo and hold this for a while
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D34
;##SEN NEU

We could always land a Cargo change now and then hold off on this for a bit? I think this may want to land sooner than that though?



;##D36 Does the model lacks usability?
;##ROLE PM
;##INV T
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

I do agree that the model in this PR feels right, although in terms of usability it may lack a bit?


>>>alexcrichton, Owner



;##D37 Another possibility possibility would be to indicate that the salt has bin appended
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

Another possibility would be to just say "the salt has bin appended to it if a binary is being created" or something like that, but that's also not... great


>>>michaelwoerister, Contributor



;##D38 Do we allow one compile to create multiple crate-types?
;##ROLE OP
;##INV T
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU
;##D39 That causes a problem because executable and binary need to have different salts
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D38
;##SEN NEU
;##D40 A solution would be to keep a map of symbols name
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D39
;##SEN NEU

We do allow one compiler run to produce multiple crate-types, right? I.e. rustc --crate-type=lib,bin will produce an executable and a library. However, now we have a problem: the executable and the binary should have different salts and thus all their symbol names should be different. It's doable, but implementing this without unnecessarily redoing a lot of work would be a bit of effort (we'd need to keep a map of symbol names and do substitutions in the optimized IR or do that directly in the binaries and in crate metadata).



;##D41 Another solution would be to use a flag
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D39
;##SEN NEU

Another way to handle things would probably be to keep using the old symbol naming scheme and activating the new one only when -Zincr-comp is specified. That way we'd have some time to make the change to Cargo without being blocked on it.


>>>alexcrichton, Owner



;##D42 It's rare enough that shouldn't be a problem
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D38
;##SEN NEU

Yeah you can emit both a bin and a lib at the same time, but that may be sufficiently rare and "weird" that we shouldn't worry about it too much. In either case I don't think we'd want to retranslate everything with just different symbol names.



;##D43 A worry is to break the old cargo's compatibility
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAN D34
;##SEN

I'm a little worried about breaking older Cargo's compatibility with newer rustc, though, mostly in terms of portability. Platforms which aren't tier 1 for us and don't have Cargo typically rarely update Cargo as it's somewhat difficult for them to compile, so this'd force them all to update to a newer Cargo. Not necessarily the end of the world, and may not be the much effort in the grand scheme of things.


>>>bors, Contributor


☔️ The latest upstream changes (presumably #31882) made this pull request unmergeable. Please resolve the merge conflicts.


>>>nikomatsakis, Contributor

;##D44 Those two models are equivalent in simplicity
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

I personally find these two models equivalent in terms of their
"simplicity":




Hash is crate name and salt


Hash is crate name, type, and salt




In my mind, the salt logically means "authority and version number".
Basically it is the global naming scheme.


It seems to me that since cargo allows a binary to link to itself as a
library, that implies that option 2 is the right way to think of things.
That is, the salt here would be " crates.io/version" and that remains
constant between both bin/lib. (The actual salt may be different but that
doesn't really matter, this would be sufficient.)


On Feb 25, 2016 3:42 PM, "bors" notifications@github.com wrote:




[image: ☔️] The latest upstream changes (presumably #31882
#31882) made this pull request
unmergeable. Please resolve the merge conflicts.


—
Reply to this email directly or view it on GitHub
#31539 (comment).




>>>michaelwoerister, Contributor




In my mind, the salt logically means "authority and version number".





;##D45 The salt is more a disambiguation mechanis
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL REFR D44
;##SEN NEU

I see the salt more as a general purpose disambiguation mechanism (which cargo then uses to provide "authority and version number")




Another possibility would be to just say "the salt has bin appended to it if a binary is being created" or something like that, but that's also not... great





;##D46 It would be nice to come back later on and tyr to do something more consistent
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D44
;##SEN

I'll give this a try now, so that the PR can move forward. At some point, I'd still like to come back to this though and see if we can't do something with more consistent semantics -- maybe at the cost of forcing some non-tier 1 platforms to re-compile their Cargo distributions.


>>>alexcrichton, Owner


I've opened up rust-lang/cargo#2420 to ensure that Cargo generates distinct metadata for libs/bins to hopefully protect against whatever we decide to to moving forward.


>>>michaelwoerister, Contributor


To give a little update on this: The core changes to symbol naming seem to be working for some time now, but there are many small issues with the test framework and how it sets up LD_LIBRARY_PATH and related things. It's very time-consuming to work through these issues since some of them only show up in stage2. But (slow) progress is being made on this PR.


>>>bors, Contributor


☔️ The latest upstream changes (presumably #31979) made this pull request unmergeable. Please resolve the merge conflicts.


>>>briansmith, Other



;##D47 The use of salt here is confusing for crypto people
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

The use of the term "salt" is confusing for crypto people reading these patches since this isn't a salt in the sense crypto people normally use. I recommend using some other term.



;##D48 This needs documentation for why SHA is securely delimited
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU
;##D49 Another option would be to switch to labeled length-prefixed values
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D48
;##SEN NEU

it seems you are using SHA-256 for some security-sensitive reason. If so, then you should document why/how the inputs to SHA-256 are securely delimited. But, instead, I recommend that you switch to labeled length-prefixed values.


Bad (the way the patch is written):




Good:




To see why this is bad, consider s = { "ab, "c" } vs s = { "a", "bc" }. These would hash to the same value without the length prefixes, but they mean different things. Similarly, instead of having an optional field for "-exe", it is better to have a non-optional, labeled, length-prefixed field.



;##D50 sessions.opts.cg.metadata needs documentation
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

Also, the documentation for session.opts.cg.metadata and other things should be documented so that people maintaining it know that it is a security-relevant function. In particular, all the stuff about labels, length prefixes, and avoiding optional fields would apply to that above.



;##D51 It not clear what would be needed to extend securely
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

Finally, the documentation for this code should make it clear exactly why it is secure and what one would need to do to extend it securely (i.e. using labeled length-prefixed subfields, avoiding optional fields, and never reusing a label for a different purpose).


>>>briansmith, Other




Ah as another data point in Cargo we extensively use SipHash for fingerprinting crates and packages.





;##D52 This should switch to CRC-32
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL REFR D9
;##SEN NEU

IMO, you should either switch to CRC-32 (if it doesn't need to be secure) or a secure hash function, if it does need to be secure. Misusing SipHash for something it wasn't intended for is worse than either of those options, IMO.


>>>michaelwoerister, Contributor


@briansmith Thanks a lot for your comments!
I have some questions:




The use of the term "salt" is confusing for crypto people reading these patches since this isn't a salt in the sense crypto people normally use. I recommend using some other term.





;##D53 The use of "Salt" should be consistent with this meaning
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL REFR D47
;##SEN NEU

Can you elaborate on that? The value stored as "crate salt" is used as additional input to the hash function we use when generating symbol hashes. I thought that would kind of match up with how the term is used normally.




it seems you are using SHA-256 for some security-sensitive reason.





;##D54 SHA is not used for that reason
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D 48
;##SEN NEU

No, we actually don't. At least as far as I know we just want something that provides good random distribution.




But, instead, I recommend that you switch to labeled length-prefixed values.




That's a good point in any case. I'll fix that.




Similarly, instead of having an optional field for "-exe", it is better to have a non-optional, labeled, length-prefixed field.




Well, since we are appending the "-exe" string to something that something that can't contain a - or an x we should be fine here.


>>>michaelwoerister, Contributor

;##D55 It is now possible to prevent run using a different version than the one at compile
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOl
;##REL NEW
;##SEN NEU

@alexcrichton @FlaPer87 I'm working on putting in the link-guard mechanism hinted at at various places and I've run into a problem with the run-make/relocation-model test case.
Some background on the link-guard: At the moment we want to prevent compiling something against one version of a dynamic library and then, at runtime accidentally using a different version of the dynamic library. Before this patch this was impossible because every symbol had the SVH in it and you'd get an error by the dynamic linker when using the wrong version of a dylib. After the patch this isn't the case any more, so we want to add some safety measure to prevent this error case.
The way I have implemented this for locally is the following:




In every crate that we compile, we emit a function called __rustc_link_guard_<crate-name>_<crate-svh>


The body of this function contains calls to the __rustc_link_guard functions of all dependencies.


An executable contains a call to it's own __rustc_link_guard functions.





;##D56 THe _rustc_link_guard function will fail if a wrongdylib is loaded
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D55
;##SEN NEU

As a consequence the __rustc_link_guard function call graph mirrors the crate graph and the dynamic linker will fail if a wrong dylib is loaded somewhere because its __rustc_link_guard function will contain a different SVH in its name.



;##D57 This does fail in the relocation-model tests
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D56
;##SEN NEW
;##D58 Why would it fail without the link-guard?
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D57
;##SEN NEU

So far, this works pretty well. However, in the relocation-model test I get an error when trying to create a dylib with -Crelocation-model=static, which is kind of to be expected because statically compiling a dynamic library does not make much sense (right?). Why does it work without the link-guard? Because the test file being compiled just contains an empty main function and consequently the resulting binary does not contain any relocations. With the link-guard, however, we always reference the __rustc_link_guard functions in dependencies and thus linking fails:





;##D59 We could remove the faulty case
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D58
;##SEN NEU

My proposed fix for this would be to just remove the cases where a dylib is compiled with relocation-model=static since it's not supported in general anyway. But I'd like to get your feedback on this first. Any thoughts?


>>>alexcrichton, Owner


@michaelwoerister yeah that sounds fine to me, it was probably just added via copy/paste and not necessarily pored over much.


>>>briansmith, Other




Can you elaborate on that? The value stored as "crate salt" is used as additional input to the hash function we use when generating symbol hashes. I thought that would kind of match up with how the term is used normally.





;##D60 That's context, not salt
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM SOL
;##REL REFR D53
;##SEN SOL

Usually we (I) would call that "context". Salts are usually random and/or intended to be unguessable by an attacker.




No, we actually don't. At least as far as I know we just want something that provides good random distribution.





;##D61 Why not just use FNV then?
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM OPQ
;##REL REFR D54
;##SEN NEU

In other words, you don't use an equality comparison of these values as a substitute for a value comparison, then, right? Assuming that is the case, why not just use FNV? If that is not the case, then you are indeed using SHA-256 as a security mechanism.




Well, since we are appending the "-exe" string to something that something that can't contain a - or an x we should be fine here.




:)


>>>michaelwoerister, Contributor




Usually we (I) would call that "context". Salts are usually random and/or intended to be unguessable by an attacker.




OK, in that case I'll rename it. The term "salt" is only used internally anyway, so it should be OK to use something more unwieldy like "crate_disambiguator".




In other words, you don't use an equality comparison of these values as a substitute for a value comparison, then, right? Assuming that is the case, why not just use FNV? If that is not the case, then you are indeed using SHA-256 as a security mechanism.





;##D62 What we aim to achieve is only low collision
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D61
;##SEN NEU

Implicitly we do make an equality comparison: If there is a collision between symbol hashes, you can get linker errors. What we don't care about is whether such collisions can easily be fabricated by an "attacker". What we want is a sufficiently low probability of accidental collisions.


Anyway, more documentation on the respective fields and methods is always a good idea. I'll add those.


>>>michaelwoerister, Contributor


@alexcrichton Great, thanks for the quick response!


>>>arielb1, Contributor


@michaelwoerister
@briansmith



;##D63 Would be nice to have SVH to be injective
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

I would really like the SVH to be injective (maybe use RBML?) to avoid annoying matches.


>>>michaelwoerister, Contributor


@arielb1




I would really like the SVH to be injective (maybe use RBML?) to avoid annoying matches.





;##64 It should be already like that
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM SOL
;##REL REFR D63
;##SEN NEU

That should already be the case in practice, if the hash function used (currently SipHash for the SVH) has a low enough probability of collisions. Can you go into more detail on the motivation of your comment?


>>>arielb1, Contributor


@michaelwoerister


I was talking about the content being hashed over.


There's an annoying issue if, say, you concatenate names together without a separator, so that "foo bar" is the same as "fo obar".


Also, I would prefer to use SHA256 instead of SipHash for collision-resistance - use functions for their correct use!


>>>michaelwoerister, Contributor


@arielb1
Agreed on all points. There probably are some places where something like this could happen in the current implementation.


Note though that this PR is only tangentially related to the SVH, so I'll not try to address these issues here.


>>>bors, Contributor


☔️ The latest upstream changes (presumably #31710) made this pull request unmergeable. Please resolve the merge conflicts.


>>>nikomatsakis, Contributor


@michaelwoerister -- so what are the outstanding blocking issues before this can land? I am thinking that I will rebase #32016 on top of it, since the work I am doing there about symbol naming for impl will benefit from the work you've done here (and would conflict otherwise).


>>>nikomatsakis, Contributor


Also, I'll steal the review from @Aatch.


>>>nikomatsakis, Contributor


(Unless he objects :)


>>>nikomatsakis, Contributor


@arielb1 regarding the SVH stuff, I am also using it for #32016 to hash the content of HIR nodes and determine what has changed. Obviously in that case I care a lot about conflicts, so I will take a look at fixing the problems you highlighted. Seems straight-forward enough... (There are a few other things I wanted to change anyway)


>>>michaelwoerister, Contributor




so what are the outstanding blocking issues before this can land?




As of right now, none :)


>>>nikomatsakis, Contributor


@michaelwoerister very good, will review pronto


>>>nikomatsakis, Contributor


@bors r+


>>>bors, Contributor


📌 Commit f425c19 has been approved by nikomatsakis



>>>bors, Contributor


⌛️ Testing commit f425c19 with merge e04eae4...


>>>bors, Contributor


💔 Test failed - auto-win-msvc-32-opt


>>>nikomatsakis, Contributor


@michaelwoerister failure is related to the link guard somehow (from here):




>>>michaelwoerister, Contributor


Probably something related to the MSVC toolchain. I'll investigate.


>>>bors, Contributor


☔️ The latest upstream changes (presumably #32112) made this pull request unmergeable. Please resolve the merge conflicts.


>>>eddyb, Member

;##D64 Would ti be possible to avoid storing item_symbols in metadata?
;##ROLE PM
;##INV F
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

@michaelwoerister Would it be possible, after this change, to avoid storing item_symbols in metadata and compute them on-demand?
Last I checked that was the only reason we couldn't write metadata before entering trans which could allow us to have .rlib files usable by other compilations while the current compilation is in trans, and only delay linking until all the trans jobs are done (cc @alexcrichton who knows about my previous attempt at this).


>>>michaelwoerister, Contributor




Would it be possible, after this change, to avoid storing item_symbols in metadata and compute them on-demand?





;##D65 It should be doable when internal symbols stop use gensym_name
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D64
;##SEN NEU

Yes, that should be possible. Maybe not immediately, as some of the internal symbols still use gensym_name but after that is changed (in a subsequent PR) symbol names should be entirely predictable.




... have .rlib files usable by other compilations while the current compilation is in trans ...




Oh, neat!


>>>michaelwoerister, Contributor


@bors r=nikomatsakis


>>>bors, Contributor


📌 Commit d534c75 has been approved by nikomatsakis



>>>michaelwoerister, Contributor


The link-guard symbols where not added to the DLL def file on Windows. Let's give it another try.


>>>bors, Contributor


🔒 Merge conflict


>>>bors, Contributor


☔️ The latest upstream changes (presumably #32238) made this pull request unmergeable. Please resolve the merge conflicts.


>>>michaelwoerister, Contributor


@bors r=nikomatsakis (after rebase)


>>>bors, Contributor


📌 Commit f6b0f17 has been approved by nikomatsakis



>>>bors, Contributor


⌛️ Testing commit f6b0f17 with merge 8c4d880...


>>>bors, Contributor


💔 Test failed - auto-mac-64-nopt-t


>>>nikomatsakis, Contributor


failure looks legit http://buildbot.rust-lang.org/builders/auto-mac-64-nopt-t/builds/8420/steps/compile/logs/stdio


>>>nikomatsakis, Contributor


@michaelwoerister and I chatted a bit over e-mail. I'm going to close this PR and open one of my own that includes his commits plus a few more.


