>>>errordeveloper, Contributor

;##D1 C Library calss should be made only when necessary, Rust functions should be used the rest of the time
;##ROLE OP
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

This is to improve the interoperability with external C libraries.
One should be able to leverage most Rust's standard run-time functions
for openning and closing files with all the error handling etc, while
only making C library calls when it's very neccessary.


>>>errordeveloper, Contributor



;##D2 The change still requires windows support and unit tests
;##ROLE OP
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

it is still missing Windows support... and unit tests. Would be great to hear some feedback before I proceed with more work on this.


>>>errordeveloper, Contributor



;##D3 Should unit tests be added to every implementation of this trait, except its definition?
;##ROLE OP
;##INV F
;##BCOM T
;##FORM OPQ
;##REL ELAB D2
;##SEN NEU

My main question regarding the unit tests is whether I should add it to every implementation of this trait  except from the trait definition, right?


>>>errordeveloper, Contributor


Regarding Windows, I have no idea, so please do feel free to make some suggestions... Does it even have FDs in the same sense?


>>>alexcrichton, Owner



;##D4 How does windows deals with HANDLE values vs file descriptors?
;##ROLE PM
;##INV F
;##BCOM T
;##FORM OPQ
;##REL GEN D2
;##SEN NEU
;##D5 Dealing with file descriptors manually is not protable
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

I'm a little wary to do this because of, sadly, windows. I don't quite grok how windows deals with HANDLE values vs file descriptors (there is some correspondence at least). Dealing with a file descriptor manually is also largely not portable, but it is often quite useful!


I would want to understand better how this works with windows before moving forward, personally.


>>>errordeveloper, Contributor




I would want to understand better how this works with windows before moving forward, personally.




@alexcrichton understood.




Dealing with a file descriptor manually is also largely not portable, but it is often quite useful!




I have briefly though of doing something along the lines of:






;##D6 In some cases it is usefull to pass the file descriptor along
;##ROLE OP
;##INV F
;##BCOM T
;##FORM SOL
;##REL REFR D5
;##SEN NEU

Although this seems rather useful and makes sense along the side of with_c_str, but in some cases all you really want is to pass that file descriptor along and take the responsibility of closing it yourself. The prosed change certainly makes a lot of sense as the first step.


To me, the most disapointing bit was finding out that there is fs_from_raw_fd...


>>>errordeveloper, Contributor



;##D7 Windows doesn't seem to present many differences in dealing with file descriptors
;##ROLE OP
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D4
;##SEN NEU

@alexcrichton by looking at libnative/io/file_win32.rs, it doesn't seem like there is a huge difference...


There is only an additional method:






;##D8 A solution would be to provide an additional handle
;##ROLE OP
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D7
;##SEN NEU

So I guess I could provide get_handle in addition to get_fd in the windows version.


We need to check with libuv also...


>>>alexcrichton, Owner



;##D9 Is a file descriptor first-class in windows?
;##ROLE PM
;##INV T
;##BCOM T
;##FORM OPQ
;##REL ELAB D7
;##SEN NEU

I'm not sure whether a file descriptor is a first-class thing in windows or what relation it has to HANDLE other than there's likely a one-to-one mapping. Most windows apis deal with a HANDLE instead of a file descriptor, so this change would definitely be favoring unix over windows.



;##D10 Manually handling the flags on file descriptors may break methods functionalities
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D8
;##SEN NEU

From your example above, however, this is why I've been hesitant to add it in the past. Many methods on these objects won't work if you start manually fiddling with flags on the file descriptor itself.


>>>retep998, Member



;##D10 get_fd could be made unsafe to give a warning?
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM OPQ
;##REL ELAB D10
;##SEN NEU

Perhaps get_fd should be unsafe to warn you that working with file descriptors is an unsafe thing?


>>>errordeveloper, Contributor

;##D11 The block would be unsafe regardless, therefore there's no need to make get_fd unsafe
;##ROLE OP
;##INV F
;##BCOM T
;##FORM SOL
;##REL REFR D10
;##SEN NEU

I have considered this and it's in the doc comment. There is not much you
can do with it apart from passing to a C function, which you will have to
wrap into  an unsafe block anyway.
The FD is not a thing that you would have to keep secure anyway, a user can
get all FD to each of the processes running with their UID without a lot of
effort, if they had to be secure they wouldn't be numeric anyway. This is
not the right place to discuss security anyway, why did I even get started?
As far as Rust is concerned, it does not intend to make the result
application secure. It can only make it safer. Although, I think insecurity
is a side effect of unsafe languages...
On 13 Jul 2014 18:30, "Peter Atashian" notifications@github.com wrote:




Perhaps get_fd should be unsafe to warn you that working with file
descriptors is an unsafe thing?





Reply to this email directly or view it on GitHub
#15643 (comment).




>>>alexcrichton, Owner



;##D12 Applying this change in the current form could create a memory safety issue
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL REFR D10
;##SEN NEU

This is not necessarily a security bug, it has the possibility of becoming a memory safety bug. Functions in libnative (and possibly libuv as well) may be designed assuming complete control of a file descriptor. If this control is broken, the broken assumptions may lead to memory unsafety.


I don't think we have any examples of this today, but that doesn't mean that it's impossible to have.


>>>errordeveloper, Contributor

;##D13 Adding a lock attribute would be a way to additionally increase safety
;##ROLE OP
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D12
;##SEN NEU

OK, sure. I'm not completely opposing making it an unsafe function. And,
perhaps with suggested with_c_fd solution, it may be made somewhat safer
with respect to other functions... I would also propose adding a lock
attribute around this and may be also add a guard for ensuring that only
read-only access is allowed, perhaps. For example, get_fd could fail if
it holds write access. Although it would be less useful that way... I'm not
sure whether one can force to reopen the same FD though.


So best solution would probably be to just simply call those functions
unsafe.
On 13 Jul 2014 19:37, "Alex Crichton" notifications@github.com wrote:




This is not necessarily a security bug, it has the possibility of becoming
a memory safety bug. Functions in libnative (and possibly libuv as well)
may be designed assuming complete control of a file descriptor. If this
control is broken, the broken assumptions may lead to memory unsafety.


I don't think we have any examples of this today, but that doesn't mean
that it's impossible to have.





Reply to this email directly or view it on GitHub
#15643 (comment).




>>>andrew-d, Contributor




I'm not sure whether a file descriptor is a first-class thing in windows or what relation it has to HANDLE other than there's likely a one-to-one mapping. Most windows apis deal with a HANDLE instead of a file descriptor, so this change would definitely be favoring unix over windows.




For what it's worth, a HANDLE on Windows is essentially the equivalent of the unix fd - it's what's used by the operating system, stored internally in the handle table of each process, etc..  fds on Windows, on the other hand, are only used by the C runtime library, and I believe there are cases in which a CRT fd doesn't have a backing HANDLE, though some quick googling doesn't provide any information about this.


>>>errordeveloper, Contributor


So my Stack Overflow post resulted in a solution that will work for what I am doing right now.


>>>errordeveloper, Contributor


I do still insist on this going forward.


@alexcrichton you commented earlier:




This is not necessarily a security bug, it has the possibility of becoming a memory safety bug. Functions in libnative (and possibly libuv as well) may be designed assuming complete control of a file descriptor. If this control is broken, the broken assumptions may lead to memory unsafety.




So it does occur to me now, based on the solution posted on Stack Overflow, that libnative (and most likelly libuv too) will allow one to call file.fd(), it's just that std::io::fs::File tries to hide it away for some reason.



;##D14 fd and get_fd could be made unsafe, but their unsafety should be assume by default
;##ROLE OP
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D11
;##SEN NEU

Perhaps fd() and my get_fd() should be made unsafe for the reasons that we discussed? Although, personally I do not see those reasons being particularly strong. As I said, if one will be passing this to a C function call, they will need to explicitly say that it's going to be unsafe. In fact, I do think that operation of actually getting the numeric value of the file descriptor is 100% safe as such. It's what you do with it after.



;##D15 A different solution could be to prevent users from opening the same file twice
;##ROLE OP
;##INV F
;##BCOM T
;##FORM SOL
;##REL GEN D13
;##SEN NEU

In fact, one might actually simply use this to could how many files they have opened so far. As far as standard run time goes, it could actually attempt to protect form file descriptor leaks by preventing someone from opening the same file over and over again with the same mode... It would just tell you, that this had already been open and here is the original handle.


>>>alexcrichton, Owner



;##D16 librustuv and llibnative should remain experimental and we should not rely on them
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

The librustuv and libnative interfaces are likely to always be experimental and not intended for general consumption. They provide their own access to file descriptors out of necessity for the library itself, I wouldn't recommend relying on the native/rustuv interfaces for extracting file descriptors.



;##D17 Adding this feature should be unsafe because is not possibile to guarantee safety
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D12
;##SEN NEU

If we were to add this function, I believe that it should be unsafe as we don't know for sure that all backing support is indeed memory safe if a file descriptor is fiddled with. Additionally, it should generally be avoided and not be necessary.



;##D18 Applying this change to windows would tie rust to the C runtime library
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

Also, from what @andrew-d said about file descriptors on windows, this would be tying rust permanently to their C runtime library. I'm not entirely sure if that's desirable or not?


>>>errordeveloper, Contributor


Another use case for this would when one wants to use std::os::MemoryMap, which takes a file descriptor and does so on windows also. If you look at the source code it calls libc::get_osfhandle(fd) to get the handle...



;##D20 Should std::io::fs::File be used instead of natvie::io::file::open?
;##ROLE OP
;##INV F
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

Anyhow, right now I need to use native::io::file::open, if I want to use std::os::MemoryMap. Is this okay or I should ideally use std::io::fs::File?





>>>alexcrichton, Owner


Ok, after stewing for a bit I think I'd like to move forward with this. @errordeveloper, could you add the following pieces to the pr?




Add get_fd to all the other I/O primitives in std::io (where applicable). The ones that I can think of are:

{Tcp, Unix}{Stream, Acceptor, Listener}
UdpSocket,
File
PipeStream
Std{Reader, Writer}




All methods can basically point to one other method to look for documentation


There should be stern documentation about the dangers of using raw file descriptors, I can help with the exact wording


Windows networking objects should be commented that they are returning a SOCKET, not a file descriptor


Comments should indicate that file descriptors on windows are C runtime artifacts, not HANDLE values.




And some unresolved questions I also have:





;##D22 Should get_fd be unsafe?
;##ROLE PM
;##INV T
;##BCOM T
;##FORM OPQ
;##REL REFR 17
;##SEN NEU

Should get_fd be unsafe? (I would vote yes)



;##D85 Should get_fd return a int instead of c_int?
;##ROLE PM
;##INV T
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

Should get_fd return an int instead of a c_int? This is largely due to SOCKET where it is a c_uint and this also may just vary per-platform. I would tend to lean towards yes to not expose C types, but I don't feel super strongly about this.



;##D86 Is there a better name than get_f?
;##ROLE PM
;##INV T
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

Is get_fd the best name? The sockets on windows definitely aren't file descriptors...



;##D87 SHould get_fd be a trait?
;##ROLE PM
;##INV T
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

Should get_fd be a trait method? It's probably too much abstraction for now, so I would vote no. The upside is that you have to explicitly import something to look at the file descriptor.




Does that sounds ok? We can deal with the questions in time, and I'm around to help out with any questions you have, feel free to reach out on IRC! (I'm acrichto)


>>>huonw, Owner




Is get_fd the best name? The sockets on windows definitely aren't file descriptors...





;##D23 get_os_identified is another possible name
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D86
;##SEN NEU

get_os_identifier? (I guess people will likely be looking for "file descriptor" or "fd" when searching for it, so this may not be the most discoverable name.)


>>>chris-morgan, Member


I do not like this, Sam-I-Am.



;##D24 The change is not needed because it is not a reasonably expected utility to have since it wouldn't work on bare metal
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEG

Supposing I wish to use a different runtime that doesn’t use that sort of descriptor at all—a bare metal case might do it, or perhaps an emscripten-specific runtime for running in the browser (I can easily imagine that one having absolutely nothing to do with such magic numbers). I do not believe it is at all reasonable to expect to be able to have such a descriptor, at the language level at least.



;##D25 The function should not only be unsafe, but also unstable
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL REFR D22
;##SEN NEG
;##D26 The function should have a separate trait
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEG

Still, for pragmatism’s sake, it must evidently be exposed somewhere. Given that, I would say very strongly that such functions should be marked unsafe, and probably unstable also. I would think also that having it on a separate trait would be a good thing—could the trait even live in the libc crate to make it absolutely clear that it’s That Sort of Thing?


>>>chris-morgan, Member



;##D27 Having this function on a separate trait would allow to use it as a generic bound
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D26
;##SEN NEU

A benefit of using a trait for this is that you could then use it as a generic bound, e.g. for exposing a safe interface over ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count).


>>>errordeveloper, Contributor

;##D28 There are precedents in the standard run-time of functionalities not working on bare metal
;##ROLE OP
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D24
;##SEN NEU

I cannot disagree with you, Chris. I do however believe that current
standard run-time contains plenty of bits that wouldn't work on bare metal.
My original diff contains only changes for filesystem access abstractions,
and I would argue whether filesystems should exist on certain kinds of
embedded systems. In regards to sockets, nearly all of embedded stacks
numeric descriptors that are quite similar in nature, those that are
different in respect to this are, in fact, different in many other ways.
On 18 Jul 2014 08:45, "Chris Morgan" notifications@github.com wrote:




I do not like this, Sam-I-Am.


Supposing I wish to use a different runtime that doesn't use that sort of
descriptor at all--a bare metal case might do it, or perhaps an
emscripten-specific runtime for running in the browser (I can easily
imagine that one having absolutely nothing to do with such magic
numbers). I do not believe it is at all reasonable to expect to be able to
have such a descriptor, at the language level at least.


Still, for pragmatism's sake, it must evidently be exposed somewhere.
Given that, I would say very strongly that such functions should be marked
unsafe, and probably unstable also. I would think also that having it on a
separate trait would be a good thing--could the trait even live in the libc
crate to make it absolutely clear that it's That Sort of Thing?





Reply to this email directly or view it on GitHub
#15643 (comment).




>>>huonw, Owner




I would think also that having it on a separate trait would be a good thing





;##D29 Having a trait would not be beneficial
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL REFR D26
;##SEN NEU

A trait is useless for distiguishing things that only have sensible implementation under certain runtimes, the std::io interfaces are completely opaque to the underlying runtime, meaning an implementation for File would apply to a File objects in any runtimes, exactly the same as a freestanding method.


>>>errordeveloper, Contributor



;##D30 Shoudl get_fd be atted to std::io::file or require native::io::file::open?
;##ROLE OP
;##INV F
;##BCOM F
;##FORM OPQ
;##REL REFR D20
;##SEN NEU

@huonw what do you say: add get_fd() to std::io::File or keep it how it is right now, requiring one to use native::io::file::open?


>>>errordeveloper, Contributor


I have just notice new rust-lang/rfcs#185... If that's to be implemented, I'd hold on with the get_fd() story.


>>>tbu-, Contributor



;##D31 get_fd should not be be unsafe, since getting a raw pointer is similar and not unsafe
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL REFR D25
;##SEN NEU

I don't see why getting the file descriptor should be unsafe – getting a raw pointer from a & pointer isn't unsafe either, it's only that actually using it is unsafe.


As per the Rust design documents, reading private values from objects isn't considered unsafe if I remember correctly.


>>>l0kod, Contributor



;##D32 get_fd could use a struct instead of a c_int
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D85
;##SEN NEU

First, about the get_fd method, I suggest to use something like the FileDesc struct (with close_on_drop set to true) instead of the c_int result (how should be typed to fd_t anyway).



;##D33 A solution for the safety problem could be to enclose the FD in a closure
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D22
;##SEN NEU

Second, it would be safer to enclose the file descriptor use into a closure. What's unsafe about file descriptor is their lifetime: they can be closed by another piece of code, refer to a different file (i.e. close then open), or passed to an execve (Command close all file descriptor, except 0 to 2, before execve anyway, but some unsafe code could execve too).

;##D34 We should not bother dealing witht he life of the FD, just close it when the raw one is closed
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

;##D35 In case of memorymap struc, the rust libraris should take care of fd safety
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

I don't think we need a close_after parameter, we just can make the file descriptor object live until the C binding close the raw file descriptor.
If we really need a persistent file descriptor we can dup it.
For MemoryMap-like struct, the Rust libraries should take care of file descriptor transfert/safety. Maybe MapFd should be created from a RtioPipe?



;##D36 With_c_str might provide some inspiration
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

We could use a with_fd method inspired from the with_c_str but for the RtioPipe trait:




I used Option hack because it's maybe not possible to get fd_t from any RtioPipe (libuv, special architecture?).


The problem is that we get error: cannot call a generic method through an object…

;##D37 Is there a plan to support generic method calls?
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM OPQ
;##REL NEW NEU
;##SEN

By the way, is there plan to support generic method call through trait?


>>>l0kod, Contributor




First, about the get_fd method, I suggest to use something like the FileDesc struct (with close_on_drop set to true) instead of the c_int result (how should be typed to fd_t anyway).


;##D38 Letting the RtioPipe handle the fd closing would be a better approach than using close_on_drop
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL REFR D32
;##SEN NEU

Not the right choice, prefer to return &fd_t to let the RtioPipe handle the file descriptor closing, but it sound unsafe anyway because the RtioPipe can read/write/lseek/close the same file descriptor.
The with_fd method definitely seems to be a better choice.



;##D39 The fd should be wrapped in a object that deals with closing it
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL REFR D33
;##SEN NEU

To properly handle file descriptor lifetime in bindings, the right thing to do is to wrap the bindings in a Rust object who handle the file descriptor closing.


>>>tbu-, Contributor




Second, it would be safer to enclose the file descriptor use into a closure. What's unsafe about file descriptor is their lifetime: they can be closed by another piece of code, refer to a different file (i.e. close then open), or passed to an execve (Command close all file descriptor, except 0 to 2, before execve anyway, but some unsafe code could execve too).





;##D40 The only way a fd could be unsafe if it used to construct something
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL REFR D33
;##SEN NEU

I don't see how reading the file descriptor is unsafe in any way – only using them to construct other things should be unsafe. Compare




(which is safe) to





;##D41 Getting a value of a point is not unsafe, using it is
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL GEN D40
;##SEN NEU

(which is unsafe). Getting the raw value of a pointer is not unsafe at all, while actually using it is. This is how it should be handled with file descriptors IMO, getting them out of a structure is no problem at al – only using them to construct other things should be unsafe.


>>>l0kod, Contributor




I don't see how reading the file descriptor is unsafe in any way – only using them to construct other things should be unsafe.





;##D42 FD should not be considered read-only, because they can be modified byt the syscalls
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D40
;##SEN NEU

For example, the read or lseek syscalls modify the file descriptor representation (in the kernel): it change the file offset where the initial owner could read or write. A file descriptor value can not really be "read-only" because interacting with it will update the kernel structure for this file descriptor.




Getting the raw value of a pointer is not unsafe at all, while actually using it is.


;##D43 A pointer is not the same thing as a FD
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D41
;##SEN NEU

This is true for pointer but there is no relation with file descriptor. Your example is only about memory.
Rust understand memory management and can control it but file descriptors are managed by the kernel. So Rust should take care not to allow uncontrolled behavior with file descriptor value.


This is why I used the "lifetime" word. It's the same problem as memory management (i.e. to control the usage) but it's not the same way to prevent unsafe behavior.


>>>retep998, Member



;##D44 A FD is nothing more than integer, so it should not be unsafe
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL REFR D11
;##SEN NEU

A file descriptor on its own still can't be used as anything more than an integer value unless you use unsafe code. I'm really not seeing the difference between file descriptors and raw pointers since both are nothing more than integers until you use some unsafe code. And since you'll have to use unsafe code anyway to use the file descriptor, you could easily sidestep any imposed safety of a with_fd method. If having with_fd is seen as a good idea, then why not have with_raw_ptr for &ptr?


>>>tbu-, Contributor




For example, the read or lseek syscalls modify the file descriptor representation (in the kernel): it change the file offset where the initial owner could read or write. A file descriptor value can not really be "read-only" because interacting with it will update the kernel structure for this file descriptor.




Well, read also modifies a raw pointer's content, e. g.:






This is true for pointer but there is no relation with file descriptor. Your example is only about memory.
Rust understand memory management and can control it but file descriptors are managed by the kernel. So Rust should take care not to allow uncontrolled behavior with file descriptor value.




The kernel also manages the underlying memory, and as shown above will happily write to any raw pointers I hand it.



;##D45 Any syscall that handles raw fd/pointers should be unsafe
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D43
;##SEN NEU

So I think the solution should be that the syscalls are unsafe, as long as they take raw filedescriptors or raw pointers.



;##D46 FDs could possibly be wrapped in a safe way
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL REFR D39
;##SEN NEU

On a related note, there might be some useful way to wrap a file descriptor in a safe way, so it can be lended to different objects or moved into them without a whole File wrapping it.


>>>l0kod, Contributor




since you'll have to use unsafe code anyway to use the file descriptor, you could easily sidestep any imposed safety of a with_fd method.





;##D47 Using with_fd, like with with_c_str, could help avoiding unsafe use
;##ROLE REFR
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D36
;##SEN NEU

Well, the with_fd is not to "impose" safety but to avoid unsafe (distracted) use.


The with_c_str is useful to use a C string while being assured that this string exist: it allow Rust to know the pointer (use) lifetime. That way we can have a guaranty that the (binding) code using it does something meaningful (and the Rust runtime can cleanup the mess afterwards).




If having with_fd is seen as a good idea, then why not have with_raw_ptr for &ptr?




Why not? :)




Well, read also modifies a raw pointer's content




That's the purpose of read to write to memory, but it also change the file descriptor metadata.




On a related note, there might be some useful way to wrap a file descriptor in a safe way, so it can be lended to different objects or moved into them without a whole File wrapping it.





;##D48 Using with_fd would achieve the goal of safely wrapping the fd
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL REFR D46
;##SEN NEU

This is partially the purpose of the with_fd: to allow bindings to use file descriptor (in the safer way).


>>>tbu-, Contributor




Well, the with_fd is not to "impose" safety but to avoid unsafe (distracted) use.




So does the solution that I propose and is currently being implemented for raw pointers.



;##D49 Are fd are raw points really different?
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM OPQ
;##REL REFR 43
;##SEN NEU

I don't see how raw pointers and file descriptors are different here.


>>>l0kod, Contributor


For raw pointers, the usual (safe) way to handle them correctly is to keep the pointed Rust object (e.g. Vec) "alive" (stay in scope) while manipulating the pointer (e.g. .as_ptr()).
So the programmer must manually check that this rule is respected.



;##D19 The goal of with_fd is to remove the manual check the safety
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB 47
;##SEN NEU

The with_fd goal is to remove the manual check but let Rust handle it.




I don't see why getting the file descriptor should be unsafe – getting a raw pointer from a & pointer isn't unsafe either, it's only that actually using it is unsafe.





;##D50 Getting a fd should not be unsafe
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D41
;##SEN NEU

I don't think getting a file descriptor should be unsafe. However Rust doesn't know that the raw file descriptor use is unsafe (and some people don't either).




So I think the solution should be that the syscalls are unsafe, as long as they take raw filedescriptors or raw pointers.





;##D51 unsafe syscall are usually wrapped in safe functiosn
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D45
;##SEN NEU

Raw syscalls are unsafe but they are usually wrapped in "safe" functions.




I don't see how raw pointers and file descriptors are different here.


;##D52 FD are handled by the kernel: unlike pointers, rust doesn't about their unsafety
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D49
;##SEN NEU

Rust know how to handle memory and that raw pointers are unsafe because their use is not checked by the compiler but by the programmer.
File descriptors are handled by the kernel and Rust doesn't know about their unsafety: there is no file descriptor dereferencing.


>>>tbu-, Contributor




Raw syscalls are unsafe but they are usually wrapped in "safe" functions.




-- quote break --




I don't think getting a file descriptor should be unsafe. However Rust doesn't know that the raw file descriptor use is unsafe (and some people don't either).





;##D53 The library should be already providing a safe interface to unsafe fd functions
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL GEN D51
;##SEN NEU

The library should totally do this, isn't it doing that already? All functions taking a raw file descriptor and using it should be unsafe. Then add a type for an owned file descriptor FileDesc and provide a safe interface for it. Then you get borrowed file descriptors (&mut FileDesc) and shared file descriptors RefCell<FileDesc> for free.


I believe that you think that what I propose is impossible. If that's the case, please say so, because I'm very sure that this is very possible. If you think what I'm proposing is impractical, please say so.


>>>tbu-, Contributor




The with_fd goal is to remove the manual check but let Rust handle it.




This would be the &mut FileDesc in my case.


>>>l0kod, Contributor




I believe that you think that what I propose is impossible.




No, I only want the safer way to deal with file descriptor :)

;##D54 The RefCell<FileDesc> is the optimal choice if implemented for all syscall using fd
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D53
;##SEN NEU

The FileDesc thing is quite close to my first proposition and the RefCell<FileDesc> looks like a winner if it's implemented in all syscalls and functions wrappers who deal with file descriptors and would require a mutable FileDesc (not a mutable internal fd_t) with borrow_mut to (exclusively) use the file descriptor, even for read-only call.
The interesting (and dangerous) thing is the shared/locked file descriptor wrapper.


>>>l0kod, Contributor




would require a mutable FileDesc (not a mutable internal fd_t) with borrow_mut to (exclusively) use the file descriptor, even for read-only call.


;##D55 Using borrow_mut to read variables is not viable
;##ROLE NEU
;##INV F
;##BCOM F
;##FORM SOL
;##REL REFR D54
;##SEN NEU

We can't force some code to use borrow_mut to read a variable.
I think the RefCell<FileDesc> should be wrapped into it's own struct to be able to control the borrow_mut behavior for any use (read or write) or maybe use a simple Mutex internally.


>>>tbu-, Contributor




even for read-only call.




Of course – it's a write access, as it modifies the underlying stream (it moves the cursor position).




We can't force some code to use borrow_mut to read a variable.





;##D56 Letting function take a mut filedesc would allow the use of borrow_mut
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL REFR D55
;##SEN NEU

We can, by letting all the functions modifying underlying structure (like moving the cursor, etc.) take a &mut FileDesc.



;##D57 Using RefCell<FileDesc> will automatically make every pattern work safely
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D54
;##SEN NEU

The good thing is, using my partially described FileDesc type, all the usual pattern will automagically work, safely. I'm talking about bare FileDesc passing, mutable borrowing &mut FileDesc, run-time borrowing RefCell<FileDesc>, sharing Arc<RefCell<FileDesc>> etc.


>>>l0kod, Contributor




We can, by letting all the functions modifying underlying structure (like moving the cursor, etc.) take a &mut FileDesc.





;##D58 Forcing every function to take the mut filedesc implies they are all using it
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL REFR D56
;##SEN NEU

It's a bit artificial and it imply all functions using file descriptor anyway (except for printing or duplicating file descriptor maybe).


I think it should affect a lot of code but it's worth a try.



;##D59 Possible names for the fucntions
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM ENU
;##REL ELAB D56
;##SEN NEU

The methods would probably looks like get_ref_fd, get_mut_ref_fd and get_fd (preferably less verbose).


>>>errordeveloper, Contributor


@l0kod @tbu-, thank you for joining this, it certainly starts to make much more sense now.


>>>l0kod, Contributor


Some additional reflections about the FileDesc object:





;##D60 Wouldn't "handle" be better for windows as name?
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM OPQ
;##REL NEW
;##SEN NEU

About the name, does it make sense to use "file descriptor" instead of "handle" for Windows?



;##D88 A clone should call dup on the raw fd
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

If implemented, a clone should do the same as calling dup on the raw file descriptor.



;##D89 FileDesc methods should be extended with std::os functions
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

Probably for a dedicated issue but, I think it would make sense (for the next step) to extend FileDesc methods with std::os functions (e.g. openat, linkat, dup, fstat…). And, if so, what about Path and File methods (i.e. rename, copy, open…)?



;##D90 Should FileDesc be declared in std::os or std::fs?
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM OPQ
;##REL NEW
;##SEN NEU

What about declaring FileDesc in std::os or std::fs?



;##91 Does FIleDesc needs to follow Rust conventions?
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM OPQ
;##REL NEW
;##SEN NEU

Do we need a FileDesc trait and multiple file descriptor types (e.g. RegFileDesc, PipeFileDesc, SockFileDesc… found with fstat) to follow the Rust typing style and add appropriate methods (e.g. only mkdirat for DirFileDesc type)?




>>>petrochenkov, Contributor




About the name, does it make sense to use "file descriptor" instead of "handle" for Windows?




Yes, file descriptors in Windows are very similar to file descriptors in posix, use similar API and usually the most useful. (Example: http://msdn.microsoft.com/en-us/library/5fzwd5ss.aspx)
File handles are lower level mechanism, deal with WinAPI directly and are rarely touched by programmers. (Example: http://msdn.microsoft.com/en-us/library/windows/desktop/ms724211(v=vs.85).aspx)




this would be tying rust permanently to their C runtime library. I'm not entirely sure if that's desirable or not?





;##D61 Is tying rust to the C runtime library a necessary evil?
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM OPQ
;##REL NEW
;##SEN NEU

Isn't it a necessary evil similar to "tying rust permanently to glibc"?

;##D62 fs::File should expone low levels descriptors, even if sacrificing safety
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

;##D63 The naming could follow the C++ approach
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D60
;##SEN NEU

I actually found this issue after I couldn't get anything lower level from std::io::fs::File to do some file locking. fs::File definitely should expose its underlying descriptor even if it implies safety issues. Otherwise if you have to access some specific OS mechanism in just one place, you will have to fall back to using libc all over the place.
As for naming, C++ calls such escape hatches "native_handle"s and leaves their meaning fully implementation defined and platform specific (for example, they can always be 0 if  it's necessary). I'd do the same and specify their meaning for each platform separately.


>>>retep998, Member



;##D64 Handle provides advatanges over FDs in windows.
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D4
;##SEN NEU

I personally prefer HANDLE over a posix file descriptor while on Windows because it lets me use the full range of WinAPI methods which do significantly more than the equivalent posix functions, and sometimes your only option is the WinAPI versions (are there any posix methods that operate on file descriptors without an equivalent HANDLE version?). Granted you can always convert the two kinds of handles back and forth, but it just feels ugly that way.


>>>tbu-, Contributor



;##D65 What are FDs on windows?
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM OPQ
;##REL GEN D4
;##SEN NEU

What are file descriptors supposed to be on Windows? I only know of HANDLEs (and would have assumed that Rust will return these as FileDesc on Windows.)


>>>thestinger, Contributor



;##D66 HANDE is a better option than FDs for windows
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D64
;##SEN NEU

It has numeric file descriptors in the C runtime, which can be converted to and from a HANDLE. It would be best to just use HANDLE on Windows and have a different type on different platforms. It could trigger a portability lint or whatever.


>>>thestinger, Contributor



;##D67 It would be good to expose a proper FileDesc type with both FD and HANDLE
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

Anyway, it would be nice to expose a proper FileDesc type with the reference counting ownership semantics of POSIX file descriptors and Windows HANDLEs.






;##D68 All files should be O_CLOEXEC by default
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

An important thing to keep in mind is that all files should be atomically O_CLOEXEC by default, so using dup, dup2, etc. rather than fcntl is wrong.


>>>l0kod, Contributor




fd: c_inc





;##D69 A dedicated fd_t type is preferable over c_int
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D32
;##SEN NEU

Preferable to use a dedicated fd_t type instead of c_int.




impl FileDesc {
…
pub fn read(&self, buffer: &mut [u8]) -> IoResult<uint> { ... }





;##D70 It should not be possible to attempte a read on the FD
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

Like I said previously, we should probably take care of file descriptor type (e.g. regular file, socket, directory) and their capabilities: it should not be possible to attempt a read on a directory file descriptor.



;##D71 FileDesc should be both a trait and a enum
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D70
;##SEN NEU

To avoid this, FileDesc should be a trait and an enum. Something like this:





E.g. the native::io::file::open should then return the previously defined IoResult<FileDesc>.




An important thing to keep in mind is that all files should be atomically O_CLOEXEC by default, so using dup, dup2, etc. rather than fcntl is wrong.





;##D72 Dup3 is another possibility
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D68
;##SEN NEU

Right, dup3 can also do it but is a bit more newer.


>>>thestinger, Contributor



;##D73 dup3 and dup are better alternatives than dup2 for POSIX
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D68
;##SEN NEU

@l0kod: F_DUPFD_CLOEXEC for fcntl is part of POSIX, and equivalent to dup with CLOEXEC. I don't think there's a standard equivalent for dup2, but yes, dup3 can be used on Linux.


>>>thestinger, Contributor



;##D74 Using an enum requires including every kind of FD/handle
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL REFR 71
;##SEN NEU
;##D75 A low-lelve type shouldn't be adding checks not necessary for safety
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB 74
;##SEN NEU

If you do this with an enum, you're responsible for including every kind of file descriptor / handle. On Linux, that includes signalfd, eventfd, timerfd, epoll and more. It's not unsafe to call read on a file descriptor that's not readable, and a low-level type shouldn't be adding checks that aren't necessary for safety. There can be higher level abstractions, but that doesn't preclude having useful low-level functionality that it's built on.


>>>tbu-, Contributor



;##D76 Wrapping the FD in an enum would have a wrong effect on compatibility
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB 74
;##SEN NEU

Indeed, the whole point we wanted to achieve with this was compatiblity with low-level libraries in other languages – so wrapping it up as such an enum would have the wrong effect in my opinion.


>>>l0kod, Contributor


OK, I missed some file descriptor types ;) but It's probably why fstat can return an unknown type.
All 7 types (plus the unknown) are defined by POSIX.


>>>l0kod, Contributor




wrapping it up as such an enum would have the wrong effect in my opinion.




Doesn't it one of the goal of static typing: to avoid confusion between different things?



;##D77 Binding to a low-level library isn't a problem
;##ROL ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR 76
;##SEN NEU

I don't see why it would be a problem for binding with low-level library.


>>>tbu-, Contributor



;##D78 C is unable to understand what the enum is
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR 77
;##SEN NEU

Because C doesn't understand these enums, it only "understands" the raw FileDesc type.


>>>l0kod, Contributor



;##D79 The goal is wrapping unsafe functions, not dealing with high level typing
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR 78
;##SEN NEU

Yes, C understand the raw fd_t but the FFI goal is to wrap unsafe functions in safe ones. High level typing is not a problem.


>>>thestinger, Contributor



;##D80 Adding abstraction and typing restriction limits the expressiveness
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

By adding abstraction and typing restrictions, it's no longer a low-level library and can no longer express everything that you can in C. Exposing low-level functionality does not preclude having high-level abstractions built on top of them. It shouldn't go beyond what is necessary to achieve safety unless it's not making any use cases more difficult.


>>>l0kod, Contributor




By adding abstraction and typing restrictions, it's no longer a low-level library and can no longer express everything that you can in C.




Yes, that's the goal of proper wrapping, to avoid errors :)



;##D81 There's no difference betwee using a single FS and multiple traits
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D80
;##SEN NEU

I don't see the difference of use between a single FileDesc and multiple ones with traits for low-level binding. The enum thing is not a problem if you use it for return value and take a trait for function argument.



;##D82 FUnctions taking FDs should use traits
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D81
;##SEN NEU

The idea is that bindings who return file descriptors (e.g. open(2)) can tighten file descriptor type with fstat. Functions taking file descriptor as argument should use traits. Moreover, I don't see any problem if UnknownFd implement all traits. Am I missing something?


>>>petrochenkov, Contributor

;##D83 The goal should be allowing the use of the entire OS API
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D80
;##SEN NEU

Plus to thestinger, I feel the primary goal is a possibility to use an operating system API in its entirety.
And after that anybody can add, refine and discuss whatever abstractions and wrappers he wants.


>>>l0kod, Contributor


Good news! libuv now support file descriptors: joyent/libuv#1435.


>>>retep998, Member


Of particular note is that libuv provides HANDLE on Windows while Rust provides c_int file descriptors instead.


>>>alexcrichton, Owner


Closing due to inactivity. There are many changes planned to the I/O libraries, especially libnative. While these changes settle down over the coming weeks, something like this will definitely be included. I would recommend holding off to see how the new design of libnative works out.



;##D84 The goal is to have high-level primitives provide access to low level and raw objects
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

The plan is to have high-level primitives in libstd which provide access to lower-level primitives in libnative which in turn provide access to the raw file descriptor/handle objects.


>>>errordeveloper, Contributor


@alexcrichton I am definitely looking forward to see those changes. Is there a tracking issues for it?


>>>alexcrichton, Owner


I'd follow rust-lang/rfcs#219 which, although closed, will be updated with the next course of action.


>>>aturon, Contributor


See (and please comment on!) this new RFC.


>>>l0kod, Contributor


Merged RFC: https://github.com/rust-lang/rfcs/blob/master/text/0230-remove-runtime.md


Related issue: #17325.


>>>l0kod, Contributor


New PR: #19169


