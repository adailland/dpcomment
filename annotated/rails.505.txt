>>>dlee, Contributor


Update: as ncreuschling points out, there was a typo in the pull request message that said "HTML verb" instead of "HTTP verb".


Updated: update forms default to PUT instead of PATCH for current apps. Defaults to PATCH for new apps.


PATCH is the correct HTTP verb to map to the #update action. The semantics for
PATCH allows for partial updates, whereas PUT requires a complete replacement.


Changes:




adds the #patch verb to routes to detect PATCH requests


adds #patch? to Request


adds the PATCH -> update mapping in the #resource(s) routes.



;##D14 A point of the change was to prefer patch over put
;##ROLE OP
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

changes default form helpers to prefer :patch instead of :put for updates only for new apps


changes documentation and comments to indicate the preference for PATCH




This change tries to maintain complete backwards compatibility by keeping the
original PUT -> update mapping. Users using the #resource(s) routes should not
notice a change in behavior since both PUT and PATCH requests get mapped to
update.


>>>dasch, Contributor


GitHub needs a +1 button.


>>>benatkin, Other


I googled for HTTP verbs and clicked the first result and PATCH isn't listed.


http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html


Where is it?


Also I hardly think that updating everything except the primary key and the created_at timestamp is a PATCH.


>>>dlee, Contributor


@benatkin http://www.w3.org/Protocols/rfc2068/rfc2068


For past discussion, see issues #348 and #425.


>>>dasch, Contributor


The example needs to be indented 2 spaces so it'll show up correctly in the docs.


>>>dlee, Contributor


@josevalim, @fxn: Hey guys, this pull request has been sitting here for over a month unnoticed. It seems like master is now hosting code for Rails 3.2, so I'm thinking it can be merged in?


>>>josevalim, Member


It seems fine for me with the view configuration option. I am a bit concerned about generating more routes (routes generation is already slow), but I don't consider it a blocker at first. /cc @nzkoz


>>>fxn, Owner


Yes I had it in mind, but waiting for 3.1 to start working on 3.2 proper.


>>>fxn, Owner


Just a ping to say I am still waiting for 3.1 and have not forgotten this patch. That's because albeit 3-1-stable is branched, I prefer a master that does not move too much because cherry-picking back to 3-1-stable is very common these days. Focus is 3.1 now.


The patch does not merge cleanly anymore, by the way, in case you want to maintain it in sync.


>>>dlee, Contributor


@fxn, cool, glad to know this hasn't been forgotten. Let me know when you're ready to merge so I can update the pull request.


>>>jeremy, Owner


Nice patch!



;##D1 This might break put routes override default routes
;##ROLE PM
;##INV F
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

I think this will break apps (and engines) that use explicit put routes to override a default resources route. After upgrading Rails, users will see that the form seems to bypass their put override.


>>>steveklabnik, Member


+1 from me.


I wish GitHub had a better way to subscribe to issues instead of just commenting. I feel like "+1" is just noise, but I want to see what happens with this pull...


>>>bcardarella, Contributor


@steveklabnik can't you just click the 'Enable notifications for this Pull Request' link at the bottom?


>>>guilleiguaran, Owner


@steveklabnik test clicking in the link at the end of this page:


Notifications for new comments on this Pull Request are off. Enable notifications for this Pull Request


@jeremy This one is candidate for Rails 3.2 or 4.0?


>>>jeremy, Owner


3.2 candidate for sure. This needs thorough attention for a clean upgrade, however.


The guides need closer attention. Perusing the diff, I see a lot of search/replace changes from PUT to PATCH. I think having PUT just disappear will be too confusing. Gotta explain this change each step of the way!


Anyone care to take up the torch on this?


>>>stevegraham, Contributor



;##D2 Put should not require a complete replacement
;##ROLE ETCp
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

i must be the only person in the world that disagrees with "PUT requires a complete replacement", as per RFC2616 "HTTP/1.1 does not define how a PUT method affects the state of an origin server"



;##D3 PATCH is a better than that put
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN nEU

that said i like the name PATCH better than PUT for the purposes of what it is used for here.


>>>dlee, Contributor


I can refine this patch if the core team decides it will definitely go into Rails 3.2... don't want to write another huge patch just to be pushed off to the next version :).



;##D4 In which scenarion would it break?
;##ROLE OP
;##INV F
;##BCOM F
;##FORM OPQ
;##REL ELAB D1
;##SEN NEU

@jeremy can you give an example scenario where the put overrides would break? We might be able to provide a workaround, or at least put some notes in the documentation so that users aren't caught off-guard. Please suggest a workaround or an excerpt that can be added to the documentation.


>>>fxn, Owner


Yes, we talked about this patch after 3.1 and it is in the "roadmap" for 3.2 if it is good to go by then.



;##D5 But put means to put a resource to an url
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D3
;##SEN NEU

@stevegraham RFCs are not axiomatic systems, but I think there's no controversy in that PUT means "put this resource at that URL" ("The PUT method requests that the enclosed entity be stored under the supplied Request-URI.").


You're sending the resource itself, and in the target URL you either create a new resource ("If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI."), or else replace the existing one ("If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server.").


It is the app's choice to conform to that spec. Nowadays to do partial updates in a RESTFul way you need to define ad-hoc resources. For example, to toggle the "paid" flag of an invoice you may PUT to /invoices/:id/paid, but if you play by the rules you need PATCH for partial updates to /invoices/:id.


>>>josevalim, Member


Aside the docs concern, this pull request looks good to me. I would just add the following changes (but I can do it myself in later commits after this is merged, this is more of a mental note):



;##D6 config.action_view.default_method_for_update could be moved to config.default_method_for_update
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

We could move config.action_view.default_method_for_update to config.default_method_for_update so other frameworks can read it as well (see 2 below);

;##D7 routes for put and patch are not both needed
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEU NEU

There is no need to generate routes for both PUT and PATCH. We could read the config in 1) and generate just one of the routes;




config.default_method_for_update should be uncommented in new applications as we already changed all docs





>>>josevalim, Member


Typo: should be = :patch.


>>>fxn, Owner



;##D8 RF 5789 specifies that put cannot be refused to do partial changes
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

@stevegraham I have found a crystal clear and authoritative answer to whether PUT allows partial updates: The very RFC 5789 (http://tools.ietf.org/html/rfc5789) states that "A new method is necessary to improve interoperability and prevent errors.  The PUT method is already defined to overwrite a resource with a complete new body, and cannot be reused to do partial changes."


>>>NZKoz, Member



;##D9 Ir would be a good idea ot move this in config.action_view.default_method_for_update
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D6
;##SEN NEU

I like the idea of moving this to be config.action_view.default_method_for_update as it lets people who care about these things choose to use patch without hitting anyone with 2x route proliferation.



;##D10 But changing to PATCH is not a great idea
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

However I'm pretty strongly opposed to switching the default to PATCH just because of a neurotic interpretation of the RFC.  There are people with blog posts, printed books and screen casts where they do




Or





;##D11 RFC indications are not a good enough reason to break other people code
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D10
;##SEN NEU

Switching the default will make all of those tutorials and chunks of code fail with routing errors, and "the RFC says X" doesn't seem like anywhere near a good enough reason to do that.


Maybe for a 4.0 change but absent some genuine bug or difficulty we can't do this in a random minor release.


>>>steveklabnik, Member




Maybe for a 4.0 change but absent some genuine bug or difficulty we can't do this in a random minor release.




Yeah, sure, I mean, the asset pipeline from 3.0 -> 3.1 was a waaaaaaay smaller change. ;)




of a neurotic interpretation of the RFC





;##D12 We should be following the RFC as way that things are supposed ot be
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL  REFR D11
;##SEN NEU

This is not neurotic. It's simply following the way that things are supposed to work. Many more people want partial updates than an upsert, that's what PATCH is.


>>>jeremy, Owner


@dlee see my previous comment for a concrete example


>>>dlee, Contributor



;##D13 Why would this break apps?
;##ROLE OP
;##INV T
;##BCOM F
;##FORM SOL
;##REL GEN D4
;##SEN NEU

@jeremey I was actually responding to your first comment in this thread. You say that explicit put overrides would break apps, but I don't see how they would. Can you clarify what you mean by put overrides?


>>>dlee, Contributor


@jeremy not @jeremey


>>>jeremy, Owner


@dlee Declare a resource in config/routes. Declare a put route that overrides the resource's update. Now upgrade the app and enable PATCH. Oops, now your forms submit to patch and your put route override is bypassed.


Not the end of the world, and docs should be enough to cover that.


>>>dlee, Contributor


@jeremy One of the points of the change was:




changes default form helpers to prefer :patch instead of :put for updates only for new apps





;##D15 Would use atch only for new apps not cover the case?
;##ROLE OP
;##INV T
;##BCOM F
;##FORM OPQ
;##REL ELAB D14
;##SEN NEU

Note that form helpers use :patch only for new apps. Would this still not cover that case?


>>>getconor, Contributor



;##D16 RFC-5789 is still a proposed standard
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL REFR D8
;##SEN NEU

I agree with @NZKoz that this should not be included before 4.0 at the earliest. Unless I'm mistaken, RFC-5789 is still just a proposed standard, and it can still be changed or retracted. See: http://www.rfc-editor.org/info/rfc5789



;##D17 We should not update until we know that the standard won't be changed or retracted
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL GEN D16
;##SEN NEU

@steveklabnik This isn't the way things are supposed  to work yet, and even without all of the recent changes, we should only implement the standard when we know it won't change or be retracted- to do otherwise would be irresponsible. PATCH has been discussed by the IETF for almost ten years, why the rush to implement it in Rails now?


>>>josevalim, Member


Good point. Agreed @nzkoz.


>>>benatkin, Other


@mhutchin Interesting. I looked back at the link I posted at the top of the discussion and the RFC @dlee cited, which contains PATCH, appears to be obsoleted by one that I cited, which only has a reference to PATCH at the end. Here are the two documents:




RFC 2068: Hypertext Transfer Protocol -- HTTP/1.1 - Contains PATCH in the main body. January 1997.


RFC 2616: Hypertext Transfer Protocol -- HTTP/1.1 - Has a reference patch at the end (only Ctrl-F result for PATCH in the text version). June 1999. Says Obsoletes: 2068 at the top.




The reference to PATCH at the end says:




The PATCH, LINK, UNLINK methods were defined but not commonly implemented in previous versions of this specification. See RFC 2068 [33].




>>>getconor, Contributor


@benatkin Thanks, I knew they had been discussing it for a long time, I underestimated how long. :-)


I would only point out for those interested that RFC-2616 for HTTP/1.1 is now a DRAFT STANDARD, but at least it is further along in the process than the RFC that now covers PATCH, RFC-5789, which is a PROPOSED STANDARD, the "entry-level maturity for the standards track". For the meaning of the statuses see: http://www.rfc-editor.org/rfc/rfc2026.txt


>>>benatkin, Other


Probably not the best way to check this, but on this list RFC-2616 is on Draft Standards and RFC-5789 is on Proposed Standards.


http://www.rfc-editor.org/rfcxx00.html


>>>benatkin, Other


@mhutchin I didn't see your most recent comment until I posted mine. You said exactly the same thing! It took me a bit of thinking to see that there's a big difference between draft and proposed besides draft being higher up the list, but I can see it now.


>>>dlee, Contributor



;##D18 Put should be left even if we insert patch
;##ROLE OP
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

@NZKoz I don't think the "route proliferation" is so bad. In fact, even if Rails ends up supporting PATCH in the distant future, I'd prefer PUT be left as a standard route, perhaps linked to a different action (replace/upsert/etc.) This might not jive with a must-map-to-CRUD mindset, but it definitely jives with HTTP.


The interpretation of the RFC is not neurotic; I think we all share a clear and straightforward interpretation. I'll assume you meant "neurotic adherence to the RFC".



;##D19 Supporting patch would be to improve rails support for http, not to adhere to rfc
;##ROLE OP
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

If so, let me reiterate that supporting PATCH is not to merely adhere to an RFC. The reason is because Rails currently has broken support for HTTP as commonly understood--leading to potentially problematic interoperability with RESTful clients, caching mechanisms, and proxies.


I'd say implementing, documenting, and promoting a broken implementation of an HTTP VERB is a genuine bug, warranting a fix in a minor release, but I'll leave the decision up to the Rails core team.



;##D20 We shouldn't inhibit changes just for bcompatibility
;##ROLE OP
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

Finally, Rails shouldn't inhibit change just to retain backwards compatibility with blogs, books, and screencasts. In fact, I don't think Rails ever did care about that.


>>>dlee, Contributor


@mhutchin, @benatkin, the Draft Standard is actually going away: http://www.rfc-editor.org/rfc/rfc6410.txt. RFCs currently in Draft Standard status will either be promoted to Internet Standard or demoted to Proposed Standard.



;##D21 Rails supports already proposed standards, so we should not reject a change based on that
;##ROLE OP
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D16
;##SEN NEU

BTW, Rails supports modern cookies and content-disposition headers which are also Proposed Standards, so there's no basis to reject PATCH just because it's a Proposed Standard.


In fact, Rails should be the framework that helps PATCH attain the Internet Standard status since Rails clearly needs PATCH in order to support non-replacing updates.


Whether that happens in 4.0 or 3.2, I defer to the Rails core team.


>>>josevalim, Member




@NZKoz I don't think the "route proliferation" is so bad. In fact, even if Rails ends up supporting PATCH in the distant future, I'd prefer PUT be left as a standard route, perhaps linked to a different action (replace/upsert/etc.) This might not jive with a must-map-to-CRUD mindset, but it definitely jives with HTTP.

;##D22 Adding more routes might be expesnive
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

If @tenderlove says an extra route is almost free, I am +1 for including all routes, but I doubt this is the case. Remember some apps have more hundreds of resources routes. In the past, generating the format route proved to be quite expensive (for example).




If so, let me reiterate that supporting PATCH is not to merely adhere to an RFC. The reason is because Rails currently has broken support for HTTP as commonly understood--leading to potentially problematic interoperability with RESTful clients, caching mechanisms, and proxies.

;##D23 Is there any proofo for that?
;##ROLE PM
;##INV T
;##BCOM F
;##FORM OPQ
;##REL ELAB D19
;##SEN NEU

Do you have anything to support this? PATCH is a new verb in the specs, so I doubt proxies and caching mechanisms went crazy to support it and change PUT behavior.




Finally, Rails shouldn't inhibit change just to retain backwards compatibility with blogs, books, and screencasts. In fact, I don't think Rails ever did care about that.

;##D24 We should still care about bcompaitibility
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D20
;##SEN NEU

Yes, we should and we do care about that (we always consider it when doing big changes. If one of us forgets, other is there to remember). It is funny how everyone complains when Rails breaks backwards compatibility when moving from 3.0 to 3.1 but no one cares to ensure it. It is not just documentation that would be broken, but generators, engines and everything else. As I said in other ticket, each plugin checking for request.put? would now be broken in an app using PATCH as default.


In other words, +1 for this pull but leaving PUT as default to allow the community to catch up. Also, +1 if we can avoid routes proliferation.


>>>dlee, Contributor






If so, let me reiterate that supporting PATCH is not to merely adhere to an RFC. The reason is because Rails currently has broken support for HTTP as commonly understood--leading to potentially problematic interoperability with RESTful clients, caching mechanisms, and proxies.




Do you have anything to support this? PATCH is a new verb in the specs, so I doubt proxies and caching mechanisms went crazy to support it and change PUT behavior.




I was referring to the broken behavior of PUT in Rails, not the absence of PATCH.


For example, caches can reasonably assume that if I PUT {"a" => "b"} to a resource, then that's what it should return on a GET. However, if the original resource was {"c" => "d"}, Rails would by convention make the resource {"a" => "b", "c" => "d"}, not the expected {"a" => "b"}.


BTW, how did you reply to a comment? Or did you just insert ">" before each line?


>>>fxn, Owner

;##D26 Put should be default
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

I am also +1 on leaving PUT by default by now.

3.0 -> 3.1 had significant changes, like the asset pipeline or switch
to jQuery, but this change in routing seems both significant and kind
of subtle as far as code is concerned, so I personally lean on playing
safe for a minor release.

;##D27 We should be conforming to the RFC and support PATCH
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D16
;##SEN NEU

I think conforming to the RFCs is our duty, Rails has always been a
good web citizen and promotes good practices by design, so we have to
support PATCH and encourage proper usage of PUT within reasonable real
life constraints.

;##D28 PAtch might end up making put obsolete
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

Since PATCH is not required to carry strict partial updates, I think
PATCH is going to make PUT obsolete for updates, just always PATCH.
That could be 4.0.


>>>getconor, Contributor




@mhutchin, @benatkin, the Draft Standard is actually going away: http://www.rfc-editor.org/rfc/rfc6410.txt. RFCs currently in Draft Standard status will either be promoted to Internet Standard or demoted to Proposed Standard.




To be clear, this would only alter the status of RFC-2616 for HTTP/1.1, which isn't under discussion, in no more than two years. RFC-5789 for PATCH, and the Proposed Standard tier, are unchanged.




BTW, Rails supports modern cookies and content-disposition headers which are also Proposed Standards, so there's no basis to reject PATCH just because it's a Proposed Standard.




No, but it shouldn't be used as a selling point either.


I'm not saying that we should reject PATCH just because it is only a Proposed Standard. I do think that we need to be very clear though, since people started saying that this was to conform to the RFCs, that the RFC in question is only a Proposed Standard, and has been for a long time. The status of the RFC dramatically impacts the cost-benefit analysis. Most would readily agree that Rails should do just about anything to conform to relevant Internet Standards and that those should be the defaults, but we obviously can't and shouldn't conform to every Proposed Standard.


This should be evaluated without regard to the RFC.




In fact, Rails should be the framework that helps PATCH attain the Internet Standard status since Rails clearly needs PATCH in order to support non-replacing updates.




If we can do so with minimal disruption.


>>>josevalim, Member




I was referring to the broken behavior of PUT in Rails, not the absence of PATCH.


For example, caches can reasonably assume that if I PUT {"a" => "b"} to a resource, then that's what it should return on a GET. However, if the original resource was {"c" => "d"}, Rails would by convention make the resource {"a" => "b", "c" => "d"}, not the expected {"a" => "b"}.




My point is that I don't believe nobody actually relies on that. And I don't believe anybody will soon just because there is a PATCH verb now.




BTW, how did you reply to a comment? Or did you just insert ">" before each line?




I just replied through gmail and it seems GH did its magic.


>>>benatkin, Other


Note also that RFC-2616 has Roy Fielding and Tim Berners-Lee among the names, while RFC-5789 only has two names, not including those two, on it. Even if it had the same status (Draft Standard), it wouldn't carry quite the same weight to me unless I saw an endorsement from Roy Fielding. The obsolete standard, 2068, doesn't count.


Here's the first thing I found while searching for a new comment by Roy Fielding on PATCH:




PATCH is another option that, once it is sufficiently deployed, might be preferred over POST for sub-resource updates. However, we make these choices for a principled reason, not just because it seems RESTful. Ultimately, the methods should be chosen by the origin server and communicated somehow to the client via the media type or relationship processing rules. If the choice of method doesn’t make any difference to the other components (i.e., neither client nor intermediaries gain any value by using PUT or PATCH over POST), then we should admit that it just doesn’t matter to the architectural style.





;##D29 We can remain RESTful without PATCH
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

So it sounds like we can be pretty RESTful without PATCH, and especially without PATCH as the default.


>>>fxn, Owner




I was referring to the broken behavior of PUT in Rails, not the absence of PATCH.





;##D30 Why would Rails behaviour be broken?
;##ROLE PM
;##INV T
;##BCOM F
;##FORM OQP
;##REL NEW
;##SEN NEU

About this point, in what sense is Rails behavior broken? Rails does what is in its hands to let you use PUT in an easy way, even imitating the correct way of doing things in browsers where that's not possible.


The user is responsible for using those tools correctly. You are free to define as many ad-hoc resources as you want to speak proper HTTP. If you construct forms for partial updates and use update_attributes that's up to you.


>>>stevegraham, Contributor


Deleted original comment because replying from email borked my formatting :(


@stevegraham
I have found a crystal clear and authoritative answer to whether PUT allows partial updates: The very RFC 5789 (http://tools.ietf.org/html/rfc5789) states that "A new method is necessary to improve interoperability and prevent errors. The PUT method is already defined to overwrite a resource with a complete new body, and cannot be reused to do partial changes."


@fxn - I'm sorry I think you're mistaken here and I have to respectfully disagree with you. First of all RFC5789 is not HTTP, let's instead look at RFC2616


"The PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI."


The word replace does not appear at all, in fact if you continue to read on you see "HTTP/1.1 does not define how a PUT method affects the state of an origin server." This implies to me that there server is free to choose whether to replace the resource in it's entirety or apply the enclosed entity as a patch. It's as clear as day as far as HTTP 1.1 is concerned and putting aside my view own personal views, neither of these outcomes are incorrect.



;##D31 There's no proof that Put is not intendted to do partial canges
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D8
;##SEN NEU

I think the only reason RFC5789 exists is that the authors have misinterpreted RFC2616. There is simply no language in RFC2616 that mandates "The existing HTTP PUT method only allow a complete replacement of a document." or that "The PUT method is already defined to overwrite a resource with a complete new body, and cannot be reused to do partial changes." It's simply not there. There maybe an argument that "a new method is necessary to improve interoperability and prevent errors." I don't know.



;##D32 Why would PUT break caching?
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM OPQ
;##REL NEW
;##SEN NEU

I also don't see how PUT breaks caching? As far as I understand it a successful PUT invalidates the caches for that given URI but the request response itself is not allowed to be cached as per HTTP 1.1. Maybe someone would be kind enough to explain that for me.


Having said all of the above, it would be nice if someone could actually refute my point to my satisfaction, which you have not done so far. It's not very comfortable being the only dissenting voice.


>>>fxn, Owner


@stevegraham I agree with you in that the authors of the RFC5789 could be wrong, though I want to believe that you wouldn't be able to push such a proposal for so many time like they have done based on such a gross false premise. But yes, that's an hypothesis.



;##D33 Deosn't make sense to say "resource modified partially"
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL GEN D31
;##SEN NEU

I was for a while in rest-discuss and my feeling is that there's consensus about that interpretation of PUT. Also O'Reilly's book about REST is clear. What's a modified version of the resource? Resources in HTTP are not partial, they are resources, all or nothing, in my understanding of the terminology. You can only request and submit resources or resource representations. So in that sense I believe no verb can work with partial resources. That's where ad-hoc resources come to play, like the paid flag of an invoice in my example above.


But this thread is pulling in different directions. It's interesting. There's the objections about whether it is premature to support such a RFC because of its status. There's the objections about whether using PUT for partial updates is incorrect at all. There's the argument that Rails should be pioneer and push. Then there will be practical issues because web servers and proxies won't understand PATCH in the short term and we will only be able to tunnel it through POST.


All in all, I've written to Roy Fielding to ask for advice. I think that's the best we can do. Should Rails work in that direction? If yes, should we work on it today? Let's see whether Roy is so kind as to shed some light about this.


>>>benatkin, Other


@fxn I don't see where @stevegraham suggested that the authors of RFC-2616 are wrong. I only see where he suggested that the authors of RFC-5789 are wrong.


I think that it's great that you've contacted Roy Fielding. I hope to see an interesting reply.



;##D34 Why wasn't ths implement as plugin ?
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM OQP
;##REL NEW
;##SEN NEU

I wonder why this couldn't have been implemented as a plugin this summer when this and other issues were being discussed. If one was written, would it have been used? How about releasing a plugin based on this and seeing whether it takes off?


>>>fxn, Owner


@benatkin oh yes my bad, wrong copy & paste. I've edited the comment.


>>>NZKoz, Member



;##D35 Is there any practical benefit using it/negative in now using it?
;##ROLE PM
;##INV T
;##BCOM F
;##FORM OPQ
;##REL NEW
;##SEN NEU

All this discussion of RFCs and the like seems to miss the point entirely.  What's the negative impact of the current behavior to real users. Are there actual practical things which people are being bitten by because we use PUT?



;##D36 if not, we should just write a config option and not change the default
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL EALB D35
;##SEN NEU

Unless there's an answer to that then this entire thread is a massive distraction, we should add the config option, not change the defaults, and move on with our lives.


>>>fxn, Owner


The discussion in my view is relevant because there are people arguing that NO support for PATCH should be added at all.



;##D37 Multiple reasons why PATCH should be added/not added
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D35
;##SEN NEU

Arguments are: 1) it is too premature given the status of the RFC. 2) It is not clear in HTTP/1.1 that PATCH is needed at all. 3) Current web servers and proxies won't understand it, so this should add support only for tunneling.


I am enumerating, not subscribing them.


We need to answer that first question. I think the point about defaults is minor in the thread.


>>>NZKoz, Member



;##D38 Supporting without changing the default would be a tradeoff among all those points
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D37
;##SEN NEU

Supporting it as an option, with no change of defaults, circumvents all 3 of those objections.  Those who wish to use it can, those who don't care won't be affected in any way.


It's really the simplest solution that could possibly work and it won't break anyone's apps ever under any circumstances.  Unless there's a compelling reason to do something else, why don't we add the config option and move on.


>>>benatkin, Other

;##D39 Writing a plugin would be even better
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D38
;##SEN NEU

Saying no and encouraging the proponents to write a plugin would be even
simpler. I would prefer this, as until I get a better explanation of its
value and an easier-to-understand RFC, I don't want this to be in the docs.
I don't think that rails should side with a Proposed Standard that doesn't
have adoption from numerous web stack components (unlike the other proposed
standards @dlee cited, content-disposition and modern cookies) unless
there's a strong benefit to a number of users.


If there are technical reasons why such a plugin wouldn't work well they
could be addressed and the changes would likely help with other plugin
projects as well. Furthermore, there would be a clear path forward to
demonstrate the value of the PATCH behavior: integrate it with a caching
proxy and show how it improves things vs. not having PATCH.


On Wed, Nov 16, 2011 at 3:13 PM, Michael Koziarski <
reply@reply.github.com




wrote:


Supporting it as an option, with no change of defaults, circumvents all 3
of those objections.  Those who wish to use it can, those who don't care
won't be affected in any way.


It's really the simplest solution that could possibly work and it won't
break anyone's apps ever under any circumstances.  Unless there's a
compelling reason to do something else, why don't we add the config option
and move on.





Reply to this email directly or view it on GitHub:
#505 (comment)




>>>getconor, Contributor



;##D40 I never stated that changes were too premature
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D38
;##SEN NEU

Wait a minute. It was never my position that these changes are too premature given the status of the RFCs. The only reason I even mentioned the status of the RFCs was because they were being used in this thread, and the other threads mentioned, for various reasons, including trying to define the problem and justifying the changes, but without any mention of the fact that all of the RFCs mentioned were in various stages of maturity, and none of them were even final standards yet.


Other than that, I couldn't care less. I agreed with @NZKoz then, and I agree with @NZKoz now.


>>>fxn, Owner



;##D41 We should not push stuff if the feature is dubious
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D39
;##SEN NEU

+1 to what Benjamin said. I don't think it is a good idea to push code, docs, and tests to maintain if the feature ends up being dubious. If people want to play with something experimental better a plugin than a black hole in the code base hidden by a flag to the end user.



;##D42 Modifying one of the strongest ocnventions requires care
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D41
;##SEN NEU

I mean, we are touching one of the strongest conventions in Rails, it touches the blessed actions. We have to do that with extra care in my view.


If I had to bet, I'd say go, but I'd prefer to have a clear understanding of the convenience of pushing this from someone as Roy Fielding, given nobody in the thread AFAICT seems to have a definitive authoritative answer. Because pushing support for PATCH has implications, it sends a message to the user base. The guide and blog post need to explain to users when or why they should use PATCH, and from this thread we have no conclusions. A blog post saying "in case you want it, why? we don't really know, you just have it there, use at your risk, have fun" doesn't sound right to me.


>>>fxn, Owner



;##D43 It's easier to go with the solution that says partial updates put are ok
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

To summarize, it is even easier to go with the solution that says partial updates with PUT are OK. No changes needed.


>>>rkh, Contributor



;##D44 Partial updates require post
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL REFR D43
;##SEN NEU

Partial updates with PUT violate RFC 2616. You have to use POST.


>>>stevegraham, Contributor


Where?


>>>rkh, Contributor



;##D45 Based on section 9.6
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D44
;##SEN NEU

I understand Section 9.6 as "if you send a PUT request, don't care if the resource already exist, the server will tell us with a 200 or a 201" (i.e. the client will transmit the complete resource), how should that allow a partial update?


>>>fxn, Owner


@rkh That's also what I think, but the point is "I understand", we always say in advance something like that, "my understanding", "my interpretation", which is telling us we cannot derive without doubt that from the text in the RFC. So we need to resort to "which is the intention", or "which is the general consensus".


Roy Fielding has not replied to my email so far.


On the other hand @steveklabnik has some pointers that support that PATCH is needed for partial updates I'll post later.


>>>steveklabnik, Member


For example, in the (now obsolete) RFC2068:




The PATCH method is similar to PUT except that the entity contains a
list of differences between the original version of the resource
identified by the Request-URI and the desired content of the resource
after the PATCH action has been applied.




The definition of PUT:




The PUT method requests that the enclosed entity be stored under the
supplied Request-URI. If the Request-URI refers to an already
existing resource, the enclosed entity SHOULD be considered as a
modified version of the one residing on the origin server.




The enclosed entity be stored. Not 'some random stuff that changes things.' It's an entire entity. 'a modified version of the one,' not 'changes that should update the one.'


@fxn has the links I gave earlier, where Fielding also explicitly says PUT requires an entire representation. I don't have them handy.


>>>stevegraham, Contributor


Please post these links because if they're the same ones I have seen Fielding does not say anything of the sort.


>>>rkh, Contributor

;##D46 This is about http, not rest
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

He's quoting RFCs, not Fielding. This is not about implementing REST properly, this is about implementing HTTP properly.


On Dec 14, 2011, at 21:07 , Stevie Graham wrote:




Please post these links because if they're the same ones I have seen Fielding does not say anything of the sort.





Reply to this email directly or view it on GitHub:
#505 (comment)




>>>benatkin, Other


@steveklabnik As you say RFC2068 has been obsoleted by RFC2616. http://tools.ietf.org/html/rfc2068



;##D47 Patch doesn't seem to be part of http though
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D46
;##SEN NEU

RFC2616, a draft standard, doesn't include a definition of PATCH. All it has to say is The PATCH, LINK, UNLINK methods were defined but not commonly implemented in previous versions of this specification. See RFC 2068 [33]. To me this doesn't say that PATCH is a part of HTTP 1.1. Also the proposed standard for PATCH (not a draft standard) doesn't include any of the authors of RFC2616 in its list of authors, and I couldn't find any endorsement for RFC5789 from Fielding online.



;##D48 patch doesn't seem to be fit here
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D47
;##SEN NEU

So PATCH feels pretty random to me. Much more random than semantically replacing a document with an updated version but leaving created_at, updated_at, and id intact, and maybe omitting some unchanged fields for efficiency.


>>>rkh, Contributor


On Dec 14, 2011, at 21:26 , Benjamin Atkin wrote:




@steveklabnik As you say RFC2068 has been obsoleted by RFC2616. http://tools.ietf.org/html/rfc2068




But it got basically valid again by http://tools.ietf.org/html/rfc5789




RFC2616, a draft standard, doesn't include a definition of PATCH. All it has to say is The PATCH, LINK, UNLINK methods were defined but not commonly implemented in previous versions of this specification. See RFC 2068 [33]. To me this doesn't say that PATCH is a part of HTTP 1.1. Also the proposed standard for PATCH (not a draft standard) doesn't include any of the authors of RFC2616 in its list of authors, and I couldn't find any support for RFC5789 from Fielding online.


So PATCH feels pretty random to me. Much more random than semantically replacing a document with an updated version but leaving created_at, updated_at, and id intact, and maybe omitting some unchanged fields for efficiency.





Reply to this email directly or view it on GitHub:
#505 (comment)




>>>stevegraham, Contributor


@rkh NOPE NOPE NOPE


>>>benatkin, Other


RFC5789 is nearly two years old, is still a proposed standard, and I can't find any implementations of a write-through cache with it, nor can I find evidence of the two authors trying to push it forward since then.



;##D49 An header would be a better idea than a verb
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

I would be happy to see a rails plugin and an apache or nginx module written to show how it can improve how HTTP works, and then a better discussion about whether the complexity of adding another verb is needed could take place. I think headers might be better because to me whether something is being replaced or just modified isn't a yes/no question when metadata is considered.


>>>steveklabnik, Member


Here's one quote from Fielding:




Stefan, I think it is better to say that we only use PUT when the update action is idempotent and the representation is complete.




He goes on further to mention PATCH:




PATCH is another option that, once it is sufficiently deployed, might be preferred over POST for sub-resource updates. However, we make these choices for a principled reason, not just because it seems RESTful.




In the text of that post:




... complete replacement of a representation (PUT),




The text of the PATCH RFC, which is again, just a draft:




The PUT method is already defined to overwrite a resource
with a complete new body, and cannot be reused to do partial changes.





;##D50 There is no consensus that put should be only for full representation
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D31
;##SEN NEU
;##D51 Post would make much more sense than put
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D50
;##SEN NEU

My point is this: there's overwhelming consensus that PUT means 'whole representation.' Well, modified consensus, since it's not 100%. ;) However, it is true that PATCH is a draft standard, so I can see not implementing it in Rails. That's quite valid. However, continuing to use PUT is also wrong. If it's a partial update, POST makes much more sense.


>>>steveklabnik, Member


@benatkin




So PATCH feels pretty random to me. Much more random than semantically replacing a document with an updated version but leaving created_at, updated_at, and id intact, and maybe omitting some unchanged fields for efficiency.




No, not at all. That's a direct violation of PUT's semantics. POST is the random grab-bag method, anyway.


>>>rkh, Contributor


On Dec 14, 2011, at 21:54 , Benjamin Atkin wrote:




RFC5789 is nearly two years old, is still a proposed standard, and I can't find any implementations of a write-through cache with it, nor can I find evidence of the two authors trying to push it forward since then.


;##D52 Should we also stop supporting cookies?
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM OPQ
;##REL NEW
;##SEN NEU

You mean Rails should not support proposed standards like, say, Cookies?


Konstantin







Reply to this email directly or view it on GitHub:
#505 (comment)




>>>benatkin, Other



;##D53 Cookies are a different case
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D52
;##SEN NEU

Not because it's a proposed standard, no. But there are other reasons to support cookies: it's been implemented and experimented with in dozens of server, client, and middleware implementations long before the first version of Ruby On Rails came out, and it's a feature that's important to Ruby On Rails users.


>>>mikekelly, Other


fwiw, I brought this up on SO about 18 months ago (the answer was auto-accepted):


http://stackoverflow.com/questions/2364110/whats-the-justification-behind-disallowing-partial-put


>>>NZKoz, Member


We've gone back and forth on this for more than 6 months, there has never been a single case provided why we should change the defaults other than bible, sorry RFC, thumping.



;##D54 We should jsut add an option per patch and deal with the default later
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D43
;##SEN NEU

As I mentioned earlier, we should simply add an option for users who want to use PATCH to be able to use it, and move on with our lives.  We can address the defaults in some far distant release once we actually have real experience with the benefits.


In the interest of bringing this to a close I'm going to close this pull request, please feel free to submit another which only adds a configuration option allowing users to switch on PATCH


>>>dlee, Contributor


Would rails core accept the minimal PATCH commit? I don't want to work on the pull request just to have it debated for months and closed without resolution.


>>>fxn, Owner



;##D55 We shouldn't accept patch on the same basis we don't accept MOVE
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

RFCs are the tool we have to discuss this. Why don't we support MOVE in Rails. Well, because it is not in the RFC right? And if someone proposed MOVE we wouldn't accept it on the ground of not being there.


So let's accept this has to be discussed taking RFCs into account, and let's accept RFCs are not axiomatic systems and are subject to interpretation in some spots.


Having said that, if verb V is not clearly justified I see no point in hiding it behind a flag, as I said above. If the need for verb V is debatable it should not be in core.


>>>steveklabnik, Member


@NZKoz There are good reasons for this. I've cross-posted about this to rest-discuss, and as Jan Algermissen mentions,




When a client (or intermediary, for that matter) re-does a PUT N-times (e.g.
because it did not receive any response the first N-1 times due to network
problems) the result on the server might not be what the client assumes it is,
given the idempotent nature of PUT.


A client that is aware of the server's tunneling-partial-update-through-PUT
semantics might not redo the PUT but any intermediary in between might (because
they would not be aware of the out-of-band knowledge / just like Google
accelerator in the case of GET-to-delete-account).


What is the problem of just using POST for the partial update in the first
place? This is what POST is for.





;##D56 Not following standards can lead to bad outocomes in the long term
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

Also, 'bible-thumping' is just a way to dismiss arguments; you either follow web standards or you don't. Rails has brought REST(ish) to many, many people, and the choices Rails makes are important. When IE6 didn't follow the standard initially, it was an excellent browser. Years later, we can see how that was a mistake.



;##D57 Updating should be using post, not put
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D56
;##SEN NEU

I don't even mean this as 'let's implement PATCH,' as that's not yet a true standard. But update should really use POST by default, since most people aren't actually PUT-ing full representations.


>>>searls, Other


@steveklabnik +1, well said.


>>>mikekelly, Other


@steveklabnik that post from Jan is written on the basis that it is impossible to make an idempotent partial update. I disagree.


In some ways it's irrelevant anyway; people are already using partial PUT requests that are intended as idempotent.


Moving to POST would:


;##D58 Moving to post would have a negative impatct on clients
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

have a negative impact on clients since its non-idempotent nature has now made the requests non-repeatable

;##D64 Moving to post would have zero appreicable benefits
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

seem to produce zero appreciable benefits over the current practice




Supposedly, RFC2616 has been enforcing 'full PUT' for over 12 years and we're still yet to see any significant mechanisms that leverage this systemic agreement on the fullness of PUT requests.. that should tell us something (i.e. it's a useless semantic). Add in the fact we have implementations, like Rails, which blatantly disregard it and don't appear to suffer any real negative consequences.. I think it's a serious stretch to compare this to IE6.


>>>steveklabnik, Member


@mikekelly Honestly, if Rails devs knew what 'idempotent' meant, they'd be happy. I don't think they intend such things at all, I think they're just using the Rails defaults.



;##D59 If the semantics aren't useful, they should be changed
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

And if the semantics of PUT aren't useful, then they should be changed. In the spec for HTTP. And then we should follow it.


Agreements are useless if people don't actually follow them.


>>>fxn, Owner


Guys I am reopening this PR. There's a legitimate discussion going on here, and I was the guy that took this PR on his plate from day one.


If the discussion takes 6 months or 2 years, it just doesn't matter, it has to take the time it needs.


People tired of the thread can unsubscribe.


>>>steveklabnik, Member


Two more things, while I think of it:






;##D60 The phrasing suggests that put should require a full representation
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

if PUT didn't require a full representation, there'd be no way to do the 'or create' part of PUT's semantics. While not totally damning, I think it's also a strong supporting line of reasoning.





;##D61 Removing patch support would make it work in the same way that put does now, by sending a post
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

Rails hasn't suffered for 'implementing PUT wrong' (really app dev's fault, but assisted by Rails' shoddy defaults) because Rails apps haven't been receiving PUT requests: they receive POST requests with a _method parameter saying PUT. This is basically exactly what I'm saying should happen with the removal of support for PATCH but without the extra parameter, pretending to be a PUT.





>>>NZKoz, Member


I certainly don't agree with continuing the discussion, but as you say I can click the little "off" button :)



;##D62 We should not modify the default if there's no downside in it
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D54
;##SEN NEU

My objection is solely to switching the default without any actual downside to end users.  It's not about whether someone's app will break (which we can obviously work around) but about yet-more additional conceptual overhead for users picking up rails.  There's tonnes of books, screencasts and blog posts which show how RESTful routing works and they all say "put will update".


Users will read those blog posts or books, write :method=>:put in their html and get routing errors.


We can't just do that for the sake of feeling better about our purity.  I'd suggest we really need a web-accelerator level of pain to justify changing the defaults.


Have fun guys ;)


>>>myronmarston, Contributor




Supposedly, RFC2616 has been enforcing 'full PUT' for over 12 years and we're still yet to see any significant mechanisms that leverage this systemic agreement on the fullness of PUT requests.. that should tell us something (i.e. it's a useless semantic). Add in the fact we have implementations, like Rails, which blatantly disregard it and don't appear to suffer any real negative consequences.. I think it's a serious stretch to compare this to IE6.





;##D63 There are strong benefits in implementing PUT correctly
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D58
;##SEN NEU

@mikekelly: I don't think it's a matter of "real negative consequences"; rather, there are very, very positive benefits to implementing PUT correctly that are simply impossible to achieve when the server is not following proper PUT semantics.  I've got a recent internal HTTP service that I built with sinatra and it was very easy to get proper PUT semantics.  The app uses PUT both for create and update, and only allows full representations to be used.  Here are some of the benefits we've received:


;##D65 PUTs have the advatange of being idempotent
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D63
;##SEN NEU

Since PUTs are idempotent, they can be re-tried as many times as you want. We rely on this a lot. The service is consumed by our main rails app. The rails app performs the PUT to the sinatra service using a resque job, and it's very easy to retry the job when we have a transient failure. It just works.

;##D66 PUTs have the advantage of simplifying the code
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D63
;##SEN NEU

The fact that we use PUT for both create and update makes the client code exceptionally simple. We don't need to deal with two separate types of requests to ensure the sinatra service has the resource in the proper state. We just use a PUT, and it doesn't matter if the resource exists or not, or whether or not the resource is already in the desired state; the end result is the same.  We also leverage this in a cron job that runs every few days for the express purpose of reconciling any discrepancies between the user configuration data in the rails app and the data in the sinatra app.  It goes over every user, does a GET to the sinatra app to get the data, compares the data to what it has locally, and does a PUT if there is a discrepancy or if the sinatra app responds with 404 not found.  Again, the idempotent, create-or-update nature of the PUT makes this extremely easy.

;##D67 PUts increase transparency
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D63
;##SEN NEU

The fact that we use PUT for create (and thus allow the client to pick the identifier) makes the service very transparent and easy to troubleshoot.  When one of the users of the rails app has some missing data I don't have to go look up the id of the corresponding record in the sinatra service; I can easily construct URLs directly in my browser using the user ID I already know.




None of these benefits would be possible if we had implemented the normal rails PUT semantics in our sinatra service.



;##D68 Patch is interesting, but put is the correct and can be already used
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D63
;##SEN NEU

So here's my two cents (not that anyone asked for it....).  I'd love to see rails provide support to easily implement proper PUT semantics.  As part of this, some other HTTP verb should be used for partial updates. PATCH looks interesting, but POST can be used today and is the correct verb to use.  In addition, it would be great if ActiveRecord/ActiveModel provided an replace_attributes method that only supported FULL updates and no partial updates.  It would effectively be like update_attributes except that it would set any unmentioned attributes to nil.  Most of the time, this would cause the partial update to fail with validation errors, which is the correct behavior you would usually want.


>>>mikekelly, Other


@myronmarston right, this is a common approach e.g. Riak uses it



;##D69 THat works only because you don't rely on completeness being guaranteed
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D63
;##SEN NEU

The issue here is that your application doesn't rely on completeness being guaranteed for PUT across the web; it's an over-specification of HTTP. If your application does need full PUT (many do), then design and document it that way. I agree it's a good idea to try and make this behaviour easier to achieve in rails.



;##D70 Allowing put to support partial would benefit mobile clients
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D69
;##SEN NEU

Given we now have a lot of mobile clients with unreliable connectivity - allowing them by default to submit small, partial updates idempotently is a huge benefit. Neither POST or PATCH would allow this since they are non-idempotent.


>>>steveklabnik, Member




allowing them by default to submit small, partial updates idempotently is a huge benefit.





;##D71 What's the issue with 'expose a sub-resouce'?
;##ROLE PM
;##INV T
;##BCOM F
;##FORM OPQ
;##REL ELAB D70
;##SEN NEU

What's your issue with the 'expose a sub-resource' strategy?


>>>mikekelly, Other




What's your issue with the 'expose a sub-resource' strategy?




off the top of my head:


;##D72 Splitting everything is not practical
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D71
;##SEN NEU

splitting up every potential partial into individual resources is not practical if you want to be able to partially update each individual attribute of a resource.

;##D73 Put is more efficient
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D71
;##SEN NEU

it's much more efficient to put (oh snap!) this optimisation in the hands of the clients, rather than try and second guess what they want.

;##D73 It would make caching terrible
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D71
;##SEN NEU

smearing your resource state is a pain for things like caching; it's redundant, you introduce shared state between resources which cases problems with cache invalidation, etc etc





;##D74 Sub-resources deletion is still a good strategy though
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D71
;##SEN NEU

having said that, I do favour using sub-resource strategy based around deletion, which does tend to overlap somewhat. There are also ways to get around the third point about caching, but at a cost of increased complexity to your system.


>>>myronmarston, Contributor




The issue here is that your application doesn't rely on completeness being guaranteed for PUT across the web; it's an over-specification of HTTP. If your application does need full PUT (many do), then design and document it that way. I agree it's a good idea to try and make this behaviour easier to achieve in rails.





;##D75 Relying on completeness is not a problem
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D69
;##SEN NEU

Actually, my application does rely on it being the complete resource.  That's how it implements PIT as create or update.  It wouldn't be able to implement create if it allowed partial resources.




Given we now have a lot of mobile clients with unreliable connectivity - allowing them by default to submit small, partial updates idempotently is a huge benefit. Neither POST or PATCH would allow this since they are non-idempotent.





;##D76 We could just implement post and patch like that though
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D70
;##SEN NEU

The spec does not mandate that POST or PATCH be idempotent--but it doesn't say they can't be.  I think it makes sense to implement the partial update as an idempotent POST or PATCH and simply document that it is idempotent (even though the HTTP verb used does not require it).



;##D77 ANd we should not assume that every partial update is idepotent
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D70
;##SEN NEU

Also, while it's possible to implement some kinds of partial updates idempotently, it's not universally true that ALL partial updates are idempotent.  Consider the common case of using accepts_nested_attributes_for for a has_many association.  When an update comes in that is adding new associated records, it is not idempotent, because each time the update runs it will add additional records.


>>>fxn, Owner


On Fri, Dec 16, 2011 at 5:37 PM, Myron Marston
reply@reply.github.com
wrote:






The issue here is that your application doesn't rely on completeness being guaranteed for PUT across the web; it's an over-specification of HTTP. If your application does need full PUT (many do), then design and document it that way. I agree it's a good idea to try and make this behaviour easier to achieve in rails.




Actually, my application does rely on it being the complete resource.  That's how it implements PIT as create or update.  It wouldn't be able to implement create if it allowed partial resources.




Why not?


I think there's a corner case that involves validation. If I send the
representation of a sub-resource (to avoid the word "update") with PUT
I could create the corresponding part of the resource itself.


For example, I set the "paid" flag of an invoice to "true", and if
there are no validations that is idempotent and makes sense as far as
HTTP is concerned. It is idempotent if I can create an invoice with
that single attribute, because that PUT request consistently sets the
flag to true. What happens to the rest of the resource among requests
is irrelevant.

;##D78 We should be discussing protocol, not single applications
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL  REFR D59
;##SEN NEU

We are talking about the protocol, not about whether that makes sense
for a particular application.


But if the server refuses to create the invoice because a customer is
mandatory, and accepts the very same request 2 minutes later because
someone else created the invoice... I would not call those PUT calls
idempotent, the side-effects of the request are clearly different.


>>>fxn, Owner


Well, that could happen also for full requests... Indeed, regarding idempotence the spec says "(aside from errors or expiration issues)". So idempotence is defined for successful requests I interpret.


If that is correct, then I see no problem in allowing creation of sub-resources.



;##D79 Why would partial updates not allow PUT?
;##ROLE PM
;##INV T
;##BCOM F
;##FORM OPQ
;##REL NEW
;##SEN NEU

@myronmarston then, why do you think partial updates would not allow you to use PUT for creation and update?


>>>myronmarston, Contributor




@myronmarston then, why do you think partial updates would not allow you to use PUT for creation and update?





;##D80 Using put would add a lot of complexity
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL  ELAB D79
;##SEN NEU

It's possible, but it adds lots of complexity.  With how I've implemented PUT, the client assumes no knowledge of what state the resource is in on the server.  It simply doesn't matter.  It always PUTs the entire resource.



;##D81 The server should not need to know anyway
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D80
;##SEN NEU

Likewise, the server doesn't need to know if the request body is intended to be a partial or full representation; it uniformly treats it as a complete resource.



;##D82 It would make more maintaible code
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL  ELAB D80
;##SEN NEU

It makes for simpler, more maintainable code all around.


>>>fxn, Owner


@myronmarston excellent, thanks.


So in your case the application is designed that way. Metaphorically speaking, in my invoicing applications the paid flag is an ordinary resource from the client's point of view. It is convenient, better for the semantics of the applications, we like the model, etc.


But if we focus the conversation on the raw protocol, the more I read about it, the less I am convinced that HTTP requires full representation in PUT requests.


However, Roy Fielding has stated that is the intention in a few public places. @steveklabnik quoted him, and I've also seen this patch http://trac.tools.ietf.org/wg/httpbis/trac/changeset/1158#file1 Roy points to in this thread http://tech.groups.yahoo.com/group/rest-discuss/message/17415 (@mikekelly participated in that one).



;##D83 Being the spec ambiguous, using it that way would jsut create ambiguitiy
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

So, my personal take on this is: the HTTP spec is a bit ambiguous about partial updates via PUT. This opens the door to endless controversy because it does not follow from the spec crystal clear that you cannot do it. But Roy Fielding says you should send full representations. If you want an authoritative answer, Roy's the one. Thus, if Rails as a framework has to take sides, I think the most sensible choice is agreeing that partial updates via PUT are not the way to go.


That does not mean the path to address that in Rails is to support PATCH, but at least I believe we have a sensible conclusion about this.


Does anybody disagree?


>>>dlee, Contributor


@fxn I agree PUT should not be used for partial updates.



;##D84 THat's why we should use patch
;##ROLE OP
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D83
;##SEN NEU
;##D85 Is there any not cited reason to not use patch?
;##ROLE OP
;##INV T
;##BCOM F
;##FORM OPQ
;##REL ELAB D84
;##SEN NEU

PATCH sounds like the perfect solution for this (in fact, designed specifically for this purpose). Other than backwards compatibility issues (which we can avoid by making PATCH optional) and lacking the stamp of RFC Internet Standard (which wasn't an issue for cookies and content-disposition), what reasons are there for not using PATCH?


>>>steveklabnik, Member


Oh, also, some clarification from a changeset authored by fielding 9 months ago in the upcoming changes to the spec.




An origin server SHOULD reject any PUT request that contains a Content-Range header field, since it might be misinterpreted as partial content (or might be partial content that is being mistakenly PUT as a full representation). Partial content updates are possible by targeting a separately identified resource with state that overlaps a portion of the larger resource, or by using a different method that has been specifically defined for partial updates (for example, the PATCH method defined in RFC5789).




>>>mikekelly, Other



;##D86 What are the pratical problems that using PUT for partial would generate?
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM OPQ
;##REL REFR D85
;##SEN NEU

personally I think it's better to ignore the specifications and focus on the practical problems inflicted by using PUT for partial updates - what are they?


>>>reschke, Other


@dlee "lacking the stamp of RFC Internet Standard"



;##D87 Why are the those thijng lacking the stamp of RFC??
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM OPQ
;##REL REFR D85
;##SEN NEU

How exactly are PATCH (RFC 5789), Content-Disposition (RFC 6266) or Cookies (RFC 6265) "lacking the stamp of RFC Internet Standard"?


>>>dlee, Contributor



;##D88 The practical problem comes directly from not followings specs
;##ROLE OP
;##INV F
;##BCOM F
;##FORM SOL
;##REL REFR D86
;##SEN NEU

@mikekelly The practical problems stem precisely from not following specifications. It's as if your server did an update on a GET, or a delete on a PUT--you're breaking conventions/expectations. HTTP participants expect certain behavior following specifications, and breaking that expectation will lead to troubles.


>>>fxn, Owner


@mikekelly I think there are two ways to look at it.



;##D89 People can do what they want on private apps
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D78
;##SEN NEU

One way is the pragmatic choice one does for a particular application. People can do whatever they want. You can use GET for deletion, you can tunnel everything trough POST. You can submit partial updates through PUT... Individual programmers for particular projects decide to adhere to the spec or not and in what degree.



;##D90 But the framework should follow best practices
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D89
;##SEN NEU

The other point of view is the one of a web framework. In my view it is the duty of Rails to follow and promote best practices. When designing the framework, specs are what we need to base the design on, they are what define what's a good web citizen.



;##D99 We should encourage using hte correct verb
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D90
;##SEN NEU

If you are writing your own private links manager running in localhost, and you want to delete links with GET quick & dirty, please go ahead. But Rails should push the message you should be using DELETE. By design, the easy path does that. And it does going as far as having builtin macros, routing, conventions, and even tunneling the method through a hack while at the same time routing the verb correctly (BTW, someone said people do POSTs with _method really not PUTs anyway. No, browsers do POSTs, Rails routes PUT).


This PUT vs PATCH is no different. Though we need to take into account backwards compatibility, I think it is our responsibility to give the user the tools to do partial updates in a proper way.


>>>mikekelly, Other



;##D100 What would this behaviour be?
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM OPQ
;##REL REFR D88
;##SEN NEU

@dlee @fxn what is this unexpected behaviour exactly?



;##D101 is it really a real problem?
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM OPQ
;##REL ELAB D100
;##SEN NEU

Is it that a client might make a PUT request intended to 'shrink' a resource but instead only partially updates it as a partial? If so; is that a real problem? Aren't client devs reading documentation telling them what can be PUT where anyway?


>>>dlee, Contributor


@reschke #505 (comment)



;##D102 Another probblem would be a partial put being chanced
;##ROLE OP
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D101
;##SEN NEU

@mikekelly What you're describing is one of the problems. Another could be that a PUT request could be cached with a partial representation. Still another is that a client might assume the idempotent properties of PUT.


>>>mikekelly, Other



;##D103 a client would never cache a put though
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D012
;##SEN NEU

@dlee it's not practical to prime a cache with the contents of a PUT request - do you know of implementations which actually do this? The client is meant assume the idempotent properties of PUT, so that's not really a problem either.


>>>exviva, Contributor



;##D104 For rails, a partial update is the most common case
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU

Let's agree that for vast majority of Rails applications, a "partial update" (a.k.a. update_attributes) is the most common use-case for an update-like request. Just imagine having to re-submit full representations of large/complex resources on every update (like nested attributes or file attachments).



;##D105 But we should stick to patch for updating
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL  REFR D104
;##SEN  NEU

Having said that, I'd vote for routing PATCH to the update action, and coming up with a separate action with PUT semantics (create/update full representations) in Rails 4.


>>>reschke, Other


@dlee I'm aware of that.



;##D106 Most of the internet runs on proposed standards though
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL ELAB D87
;##SEN  NEU

I'm just confused about "lacking the stamp of RFC Internet Standard". PATCH, Cookies, and C-D are Proposed Standards. HTTP/1.1 currently is  a draft standard, but will be back at "proposed" soonish. As a matter of fact, most of the internet runs on "proposed" standards.


>>>dlee, Contributor



;##D107 Clients could be lead to make wrong assumptions on idempotent
;##ROLE OP
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D102
;##SEN

@mikekelly No, I don't know of any implementations off the top of my head. As for idempotent PUTs, the problem is precisely that clients assume the idempotent properties of PUT, but the server might not do idempotent updates in PUT.


@exviva I agree. But I think there should be some sort of transitional stage in 3.x that introduces devs to PATCH and allows them to opt-in before Rails 4.


>>>mikekelly, Other



;##D108 Does that mean that idempotent partial updates are not possible?
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM OPQ
;##REL REFR D107
;##SEN  NEU

@dlee ok, but what does the invalid use of PUT for non-idempotent requests have to do with the use of idempotent partial updates? Are you implying that idempotent partial updates aren't possible?


>>>dlee, Contributor


@mikekelly Sorry, I don't understand why you're talking about "idempotent partial updates". My worry is with non-idempotent partial updates happening behind a PUT request (expected to be idempotent).


>>>fxn, Owner


@mikekelly If you document you can delete a resource via POST requests, that's your business. Users of your API can certainly read that documentation and understand it.


If you allow idempotent partial updates via PUT requests also that's your business. Users of your API can read that documentation and understand it.



;##D109 THe point is if we should support it as framework, not if an user needs it
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR 108
;##SEN  NEU

But If you are a Rails programmer and want to provide DELETE for deletion and PUT for full updates the framework provides the means[*]. As of today there's no builtin way to do partial updates, because there's no builtin way in HTTP. This thread is about whether Rails as a framework should do something about this, not about the practical urgency you may feel. People have done delete via POST for ages.


[*] The current idioms with update_attributes are perfectly fine for full representations via PUT. "Full representation" belongs to your interface, update_attributes is your implementation. If your API requires a full representation (except perhaps for some internal stuff like cache counts), update_attributes allows you to store one just fine.


>>>mikekelly, Other


@fxn




As of today there's no builtin way to do partial updates, because there's no builtin way in HTTP





;##D110 That is already supported though
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D109
;##SEN  NEU

it's already built into rails and works ok over HTTP, afaict:


curl -H "Accept: application/json" http://test.dev/widgets/1


{"id":1,"foo":"bar", "fizz": "buzz", "car": "blue" }


curl -H "Content-Type: application/json" -X PUT -d "{ \"foo\": \"partially updated\" }" http://test.dev/widgets/1


curl -H "Accept: application/json" http://test.dev/widgets/1


{"id":1,"foo":"partially updated", "fizz": "buzz", "car": "blue" }


>>>steveklabnik, Member



;##D111 Yes, but that violates HTTP's semantics
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D110
;##SEN NEU

Sure, and so does GET /foos/1&action=delete to delete a resource, but that doesn't mean you're not violating HTTP's semantics to do it.


>>>mikekelly, Other



;##D112 The semantics are not clear enough to claim that
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D111
;##SEN  NEU
;##D113 THe current semantics prevent Partial idempotent updates
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D112
;##SEN  NEU

@steveklabnik most people agree that 2616 is not clear enough for this to be a serious issue, hence why httpbis has looked to improve it. I'm yet to figure out why exactly that semantic needs to be put in place by httpbis. It doesn't appear to be necessary and it prevents partial idempotent updates (PIUs).



;##D114 PIU are needed by modile
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D113
;##SEN  NEU


;##D129 PIU are super important for mobile
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D128
;##SEN  NEU

PIUs are important, particularly for mobile devices that operate on crappy networks and need to be able to make extremely granular requests (i.e. partials) that can be retried easily on failure (i.e. idempotently).


The fact is, rails behaves this way - it's demonstrably useful, and non-demonstrably detrimental to either rails applications or the web as a whole.


;##D115 We should leave it as it is
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D114
;##SEN  NEU


;##D130 We should jsut not touch it and wait to see what happens with https
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN  NEU


I think it's probably better to leave it as it is - given the contention over 2616 - and wait to see what happens with httpbis.


>>>dlee, Contributor

;##D116 The semantics are clear enough on PUT not allowing partial replacement
;##ROLE OP
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D112
;##SEN  NEU



@mikekelly I think 2616 is clear enough on the issue of PUT being full-resource replacements, but just in case it wasn't clear enough, there's also the RFC 5789 to make it explicitly clear.

;##D117 We can use patch fro PIU
;##ROLE OP
;##INV T
;##BCOM F
;##FORM ELAB D113
;##REL NEU
;##SEN



PIUs, and just partial updates in general, are important, we all agree. That's the whole point of this pull request--let's support the proposed standard of using PATCH to do partial updates.


PUT mandates idempotent full (non-partial) updates.
PATCH allows full or partial updates, idempotent or not.


@reschke Yes, a lot of the internet runs on Proposed Standards. That's why we shouldn't dismiss PATCH even though it's a Proposed Standard, because it's too restrictive to only support Internet Standard.


>>>mikekelly, Other

;##D118 nonetheless, there is some ambiguity
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D116
;##SEN  NEU



@dlee I don't want to argue semantics because it won't go anywhere, but would you agree there must've be some ambiguity that causes it to need updating by httpbis?

;##D119 pathc is not equivalent sicne it's not idempotent
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D117
;##SEN  NEU



The problem with moving to PATCH is that it's not equivalent since its definition is not idempotent: "PATCH is neither safe nor idempotent", this means that - on the web - these requests cannot be considered idempotent (even if your client and server know better). This means that any supporting infrastructure e.g. HTTP client libraries which know they can retry PUT requests on network failure, or generic accelerating proxies that perform a similar function cannot do so on these PATCH requests - even if they are intended idempotently, on the network they aren't.


Fwiw, that kind of argument does not hold up in the same way for the guaranteed fullness of a PUT request, which is exactly my problem with that (over)specification.


>>>dlee, Contributor

;##D120 From RFC,  It's clear that PATCH is meatn to fill the void left by PUT
;##ROLE OP
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFRNEU D118
;##SEN NEU



@mikekelly From what I can tell, it's clear that PUT means full-resource updates, and the purpose of RFC 5789 (PATCH) is not mainly to clarify PUT's definition (it does clarify, if only by taking for granted that PUT is full-resource replacement), but to provide a solution for a glaring hole in HTTP--namely, the lack of partial updates.

;##D121 There is no verb in http that guarantees idepotent and partial updates
;##ROLE OP
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D119
;##SEN NEU



I agree with you that PATCH does not guarantee idempotent updates. I agree with you it might be useful to have a verb that allows partial and idempotent updates. However, PUT is not it (no partial updates). Neither is PATCH (updates not guaranteed to be idempotent). There is no verb in HTTP that guarantees idempotent behavior while allowing partial updates.

;##D122 We should still push patch for the other reasons
;##ROLE OP
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D121
;##SEN NEU



Your desire for such a verb should not prevent PATCH from being supported in Rails. As for idempotent partial updates, it seems like using subresources (as discussed in previous comments) is the best strategy for now.

;##D123 It seems to be cleaer than RFCs do not support put partial updates
;##ROLE OP
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D122
;##SEN NEU



After all this, though, it seems we're pretty much on the same page. I think you'd agree it would be good to support PATCH in Rails if it's clear that PUT does not allow partial updates. Our task, then, is to ascertain whether or not PUT supports partial updates. And between RFCs (new and old) and Roy Fielding, it seems pretty clear the authorities are against partial updates in PUT. Can we agree on this?


>>>fxn, Owner


(With infinite love to @tenderlove).

;##D124 A framework should encourage to adhere to semantics, nto dictate them
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN  NEU



@mikekelly Ruby on Rails does not define HTTP semantics, as a web framework it has to provide means to its users to be able to adhere to them if they want to, promote proper usage of them, and still allow users to do delete via GET and partial updates via PUT (ie, promoting, not lecturing).


Today, to toggle the paid flag of an invoice and follow proper HTTP semantics, you have to make that flag a resource. That's for me a conclusion of this thread, based on quotes from Roy Fielding.

;##D125 It is still not clear if we should use PATCH or not
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D124
;##SEN  NEU



So the topic of the thread is: given these definitions, what should Rails do next? Perhaps the answer is PATCH, or perhaps is nothing, we still don't know.

;##D126 Even if we support patch, PIU would still not be supported
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D125
;##SEN NEU



And if Rails had some sort of support for PATCH, you still would not be able to do idempotent partial updates and adhere to HTTP semantics at the same time. That's just how things are defined, it's not under the control of Rails. To discuss the convenience of this you need to discuss with the HTTP guys, not the Rails guys.


>>>mikekelly, Other

;##D127 But your version of the semantics is not the only one
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D124
;##SEN NEU



@fxn the problem here is that you're insisting that your interpretation of the semantics in 2616 is the only valid one, which is not the case. Debating semantics is utterly pointless, but it is worth acknowledging that this particular discussion about PUT has been around for lot longer than this PR - which suggests that there is, in fact, more than one valid interpretation.


So even if "we must follow the spec at all costs" was a valid logical argument - in this instance it doesn't really move us forward due to the unavoidable reality that part of the spec in question is up to interpretation.

;##D128 It would be better to focus on the practicality
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D127
;##SEN  NEU



So, as I've said previously in this thread, I think we're far better off focusing on the actual benefits and problems of moving away from or staying with partial idempotent updates. I've already made a case for sticking with what we have:


PIUs are important, particularly for mobile devices that operate on crappy networks and need to be able to make extremely granular requests (i.e. partials) that can be retried easily on failure (i.e. idempotently).


The fact is, rails behaves this way - it's demonstrably useful, and non-demonstrably detrimental to either rails applications or the web as a whole.


I think it's probably better to leave it as it is - given the contention over 2616 - and wait to see what happens with httpbis.

;##D131 Why would PIU be bad?
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM OPQ
;##REL NEW
;##SEN  NEU



Aside from the concerns about following the spec, why do you think partial updates via PUT are bad for either rails apps or the web?


>>>reschke, Other

;##D132 PATCH can now be idempotent with if-match
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU



@mikekelly you can make a PATCH request idempotent by adding "If-Match".


>>>fxn, Owner


@mikekelly I don't say this is the only valid interpretation. At the beginning of the thread it was my reading of the spec, and it was what other sources interpreted. It is also clear that we are not inventing this controversy, it is old.


After this thread, we have a pulse of the generic consensus and Roy Fielding's view on this topic. And I believe that opinion is key. If Roy said "go do partial updates with PUT" we had already closed the PR.


This tells me that if I have to bet, I know where to bet. Not saying the other interpretation is wrong. The spec is ambiguous, so there's no right or wrong. It could be the case that the ambiguity was an overlook, I personally don't know. But what we have is consensus (different from unanimity), and the +1 of Roy Fielding regarding not doing partial updates with PUT.


So, Rails is (probably) going to provide a way for the majority of people participating in this thread that would like to do partial updates without PUT. At the same time, you will be able to continue doing partial updates via PUT.


Mind you, if we do something I don't expect it to be a dramatic change. At least at the beginning. It could be something discreet, like being able to say :method => :patch, and adding routing and conventions without changing defaults. Backwards compatibility must be respected, and indeed you may be doing form_for with a full-representation, which is the canonical use case of form_for reused in create and update views.

;##D133 Adhering to the specs is reason enough to add PATCH
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN  NEU



And yes, adhering to the spec/semantics is enough for me to consider adding support for this. Why does Rails support DELETE? Couldn't people delete via POST? Sure, and we are doing it all the time, but that's irrelevant, it is the duty of Rails to give you a way to do proper DELETE. When you work with polynomials you don't say "superscript", you say "exponent". And when people mean partial update, they are going to be able to say PATCH.


>>>mikekelly, Other

;##D134 Woudl that approach prevent non-conditional PIUs?
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM OPQ
;##REL REFR D132
;##SEN NEU



@reschke is that an explicit part of PATCH in its latest incarnation? Of course - that approach would also prevent non-conditional PIUs, right?

;##D135 This change still feels uncessary and complex
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D133
;##SEN NEU



@fxn I'm definitely not keen on this change - it's unnecessary, more complex, and stands to invalidate existing standard rails practices. It's unnecessary because it doesn't actually appear to achieve very much other than to satisfy:




a part of 2616 that doesn't even have to exist according to a valid interpretation


Roy Fielding's proposed clarifications in an spec that's not been published yet




we're going round in circles here and I have nothing to add at the moment, so I'm going to bow out for now


>>>reschke, Other


@mikekelly this applies to any HTTP method; for PATCH, see http://greenbytes.de/tech/webdav/rfc5789.html#rfc.section.2.p.4


re: "that's not been published yet" -- oh, it is published as Internet Draft, just not approved as RFC yet. Publication of Internet Drafts is for community review and gathering feedback. Hint, hint.


>>>myronmarston, Contributor

;##D136 rails does support idempotent updates, but the common idioms does non-idempotent updates
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU



@mikekelly -- Over and over gain you've pointed out that rails supports partial idempotent updates.  This is true, but update_attributes and the common idioms of rails (i.e. using accepts_nested_attributes_for) often result in a non-idempotent partial update.  Consider this params hash from the API docs:





This is not idempotent, because every time the update_attributes processes this hash, it creates two new posts (one with the title "Kari, the awesome Ruby documentation browser!", one with the title "The egalitarian assumption of the modern citizen").


Thus the conventions and idioms that rails encourages developers to use result in non-idempotent PUTs. Putting aside the full vs. partial question for a second, the non-idempotency here is a big problem.


>>>steveklabnik, Member


Fielding weighs in: http://tech.groups.yahoo.com/group/rest-discuss/message/18091


>>>steveklabnik, Member


And Fielding with a non-snarky answer:




PUT means PUT. There are no
partial updates in PUT. There was a half-assed attempt to add those
semantics by committee in the midst of standardizing HTTP, but that
attempt failed because PUT's existing semantics had already been deployed
and we can't graft partial updates on top of existing replace semantics.
Period. End of story. Hence, PATCH was defined in 1995 (and finally
standardized much later because the WebDAV group was lazy).


This answer is final. If anyone implements it differently in Rails,
then Rails will be neither compliant with HTTP nor compliant with REST.
Whether that matters to anyone developing Rails is besides the point.




Game over, man. Game over.


Now, to the question he addresses in his final paragraph: does this actually matter, to us? I obviously think it does.


>>>fxn, Owner


Case closed!


Yes, it matters.


We are about to release 3.2 RC, it's too late for 3.2, but I think the time it took to discuss this has been worthwhile because we didn't have such a clear and authoritative point of view at the beginning. Knowing which are the rules without doubt, we have the right mindset to work on the PR.


>>>mikekelly, Other


please consider my response to that, and wait for the discussion to play out.


obligatory meme:





>>>mikekelly, Other


Roy is responsible for the changes in httpbis so it's hardly an earth shattering revelation that he believes 2616 should be interpreted that way.


>>>steveklabnik, Member


He's also an author of 2616, so I'd expect him to be a pretty valid source when requesting clarification of it, too.




Knowing which are the rules without doubt, we have the right mindset to work on the PR.



;##D137 How far do we want rails to go?
;##ROLE PM
;##INV T
;##BCOM F
;##FORM OPQ
;##REL NEW
;##SEN NEU



Right. The real question is this: how far do we want Rails to go? Obviously, Rails cannot make every web service RESTful; that relies on human design. I would like to see Rails make it easier to comply with HTTP and HATEOAS, though, by providing helpful things in that regard. That's obviously longer-term and out of the scope of this pull request. However, this is a good start. I think the correct option as far as this pull request goes is this:

;##D138 We should start having two new actions, patch and upsert
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D137
;##SEN NEU

Add two new actions: patch and upsert. The update action should match to POST, the patch to PATCH, and upsert to PUT.

;##D139 Then adding a configuration option to use post instead of put
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D138
;##SEN NEU

Start off with having this as a configuration option, ActionController.update_verb, which is set to :post in new rails apps, but has a default of :put so that old apps still work.

;##D140 Later on, changed the default to post
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D139
;##SEN NEU

In Rails+1, change the default to :post but leave the option so that people can set it if they still don't want to update.




'upsert' isn't a great name. I've run across some people who don't know what this means, but it does capture what PUT is supposed to do in one, short word.


>>>reschke, Other

;##D141 We also need a new media type
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D139
;##SEN NEU



@steveklabnik keep in mind that just changing PUT to PATCH doesn't make things better magically, you also need an Internet Media Type describing the patch format. And no, "application/json" doesn't.


>>>steveklabnik, Member


Also, @mikekelly asked me to make something perfectly clear, so here it is:

;##D142 Standards should be followed
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D56
;##SEN NEU



I think that standards should be followed, because they're standards. They're the working agreements that we all go by, and if we discover that we're not compliant, software should changed based on that and nothing else. This doesn't mean they're infallible, and when they get revised, things should be changed again. Because compliance with a spec is the most important thing.


We now return to your regularly scheduled pull request.


>>>steveklabnik, Member

;##D143 post works better for the update
;##ROLE PM
;##INV ETC
;##BCOM F
;##FORM SOL
;##REL ELAB D141
;##SEN NEU



@reschke right. Baby steps. That's why I think that POST actually works better for what rails calls update.


>>>mikekelly, Other

;##D144 There are still valid interpretations of RFC that do not require the change
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D137
;##SEN NEU



it was tongue in cheek, and my point was that until httpbis makes it completely clear - there is no requirement to churn rails, because there are valid interpretations of 2616 which are perfectly fine with the current behaviour.

;##D145 This change is motivated more from speculation than from specs
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D144
;##SEN NEU



So, essentially, jumping the httpbis gun w/ this PR is driven by speculation and/or pedantry and not a need to conform to a spec which unquestionably requires the change (there isn't one, HTTPbis is a WIP) or fix a functional problem with rails (there isn't one of these, either). I think everyone should be clear about that.


>>>myronmarston, Contributor




So, essentially, jumping the httpbis gun w/ this PR is driven by speculation and/or pedantry rather than conforming to a spec which unquestionably requires the change (there isn't one, HTTPbis is a WIP) or fixing a functional problem with rails (there isn't one of these, either). I think everyone should be clear about that.



;##D146 The interpretation has been confirmed by the author
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D144
;##SEN NEU



That's not it at all. We have the one of the authors of the HTTP 1.1 spec, and the inventor of REST (which rails at least tries to adhere to...) saying that PUT means only full representations, and that rails is not in line with the HTTP or REST to allow it any other way.


>>>mikekelly, Other

;##D147 This change is significant, but it doesn't need to happen
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU



tl;dr cliffnotes for @tenderlove: change from this PR is significant, doesn't need to happen - may do in future if/when next revision of HTTP invalidates the approach. Roy Fielding is the ineffable fountain of HTTP wisdom.


>>>mikekelly, Other




That's not it at all. We have the one of the authors of the HTTP 1.1 spec, and the inventor of REST (which rails at least tries to adhere to...) saying that PUT means only full representations, and that rails is not in line with the HTTP or REST to allow it any other way.




Roy is an insanely smart guy and definitely an authoritative source on HTTP. His insight and opinion is important. But his opinion does not magically make 2616 more clear on this issue than it is. It's not clear. This is why Roy himself has revised it.


>>>fxn, Owner

;##D148 We still haven't decided which way to move
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFRNEW D144
;##SEN



@mikekelly we have not outlined yet the path, as I said before I don't expect to do any dramatic changes any time soon. Let's explore.

;##D149 The only decision is to add some support for patch
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D148
;##SEN NEU



At this point in the thread, the conclusion is that we are going to add some support for PATCH and promote good practices regarding PUT/PATCH in Rails applications. Good practices as described by Roy Fielding.

;##D150 But it needs to be progressively and maintaining bcompatibility
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D149
;##SEN NEU



But progressively, and with backwards compatibility as a must. At least for the time being.


>>>mikekelly, Other




At this point in the thread, the conclusion is that we are going to add some support for PATCH and promote good practices regarding PUT/PATCH in Rails applications. Good practices as described by Roy Fielding.


But progressively, and with backwards compatibility as a must. At least for the time being.




Ok fair enough, in that case it looks like @NZKoz hit the nail on the head over a month ago.. #505 (comment)


>>>fxn, Owner


The point of following the discussion was to know whether we should have to add anything at all. At that point we didn't know.


If Roy said "yeah, just do partial updates with PUT" no flag should be added, no code should be in core.


If Roy says "PUT means PUT. There are no partial updates in PUT." that justifies working on the PR. Working on the PR means what I said above, it does not mean applying the very patch.


>>>gducharme, Other

;##D151 Supporting patch will help awarness and adoption
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU



Allowing access to PATCH as a configuration option will help drive awareness and adoption. Further down the line, we might well see a larger number of devs and applications clamoring for a change of default configuration, in much the same way we saw jQuery make its way in core.


Count this as +1 to a configuration option.


>>>dlee, Contributor

;##D152 Hhow much should be pushed forward initially?
;##ROLE OP
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU



Rails 4 has been announced for the summer. How much PATCH support should we get in? There have been various proposals of how to support PATCH in Rails 4:




make PATCH and PUT both map to update and:

;##D153 An option is to edit form to use patch or put by default, the other as opt in
;##ROLE OP 
;##INV T
;##BCOM F
;##FORM ENU
;##REL ELAB D152
;##SEN NEU
make edit forms use PATCH by default and PUT by configuration opt-in
make edit forms use PUT by default and PATCH by configuration opt-in

;##D153 Another option is to split update in put and patch
;##ROLE OP 
;##INV T
;##BCOM F
;##FORM ENU
;##REL ELAB D152
;##SEN NEU

split update into different actions that map better to PUT and PATCH




>>>steveklabnik, Member


@dhh mentioned on Twitter that he supports some kind of support.


Really, to be honest, I think this pull request should probably be closed, and a discussion thread should be made on rails-core about it. That's sorta out of the scope of this particular PR.


>>>josevalim, Member

;##D154 We should have a config.method_for_update, respected by both routes and forms
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D153
;##SEN NEU



We should have a config option called config.method_for_update. Both routes and forms should respect this option. There is no need to generate both routes. It makes no sense to split update in two actions.


>>>josevalim, Member

;##D155 The only additional change needed is the config, making av and rouer read the config and change the generation of put and patch
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D154
;##SEN NEU



In other words, this pull request is almost good imo. It just needs to provide a config.method_for_update, make both AV and the router read from this config and change the router to stop generating both put and patch for update.


>>>steveklabnik, Member

;##D156 It dpeends on how much we want to push
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D155
;##SEN NEU



@josevalim It really depends on how far you actually want to go. A 'rails 4' gives a big opportunity to step back and evaluate the whole 'Rails REST' thing in general.


Then again, it seems that rails core wants rails 4 to be more of a normal release, so...


Regardless, I agree about this patch. It's good regardless of that stuff.


>>>dlee, Contributor


If Rails core gives the OK, I can fix the patch according to @josevalim's recommendations.


>>>fxn, Owner

;##D157 PATCH and PUT have different semantics
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D154
;##SEN NEU



PATCH and PUT have different semantics. PUT means create/replace and it is idempotent. PATCH means update (full or partial) and it is not idempotent.


If your application is a s3 clone, you want to upload assets with PUT. I think we need to be able to have both working, rather than a exclusive option.


>>>josevalim, Member

;##D158 We should still decide wich one goes for default
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL  REFR D157
;##SEN NEU



@fxn I agree both options should work, it is just a matter of what we choose as default. For instance, the router should generate just put or patch routes by default for resources, however if for some specific case I want to use both PUT and PATCH or another, I should be able to do it. The same for the view, responders, etc... they should work for both put and patch.


>>>fxn, Owner


@josevalim 👍


>>>josevalim, Member


So as both me and @fxn agree, we would love to receive a new pull request that adds those small changes to this already existing pull request. Thanks @dlee for holding on all this time.


>>>myronmarston, Contributor

;##D159 It would also be useful to have proper support for put
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL NEW
;##SEN NEU



I hinted at this above, but to reiterate: besides changing rails so that it supports PATCH, I'd also like to see improved support for proper PUT semantics.  Currently, rails idioms and conventions do not make this easy.  Specifically:


;##D160 update_attributes still support partial updates
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D159
;##SEN NEU

The common AR method used for updates is update_attributes. It supports updates of the full representation, but it also supports partial updates, which, as we've discussed above, is a violation of PUT semantics (at least in the mind of Fielding and other HTTP experts).

;##D161 It also support non idempotent updates
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D159
;##SEN NEU

update_attributes also supports non-idempotent updates when used in combination w/ accepts_nested_attributes_for.

;##D162 It would easy to just define a new replace_attributes method
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL ELAB D159
;##SEN NEU

I think the simplest way to provide an update method that does provide proper PUT semantics is a new method, replace_attributes.  It would set any attribute that is not included in the hash to nil, and thus treat the given attribute hash as the full resource.




Would the rails core team by interested in the addition of this API? I'm willing to take a stab at it, and can open another ticket to discuss further details, but figured it was worth inquiring here first.


>>>dlee, Contributor


I like that idea; it'd make adhering to HTTP much easier.

;##D163 Here's a list of better names for the method
;##ROLE OP
;##INV T
;##BCOM F
;##FORM ENU
;##REL REFR D162
;##SEN NEU



I'd prefer a method name that more strongly indicates the full-resource replacement. What do you think about full_replace, replace_all_attributes, replace_resource, replace_with, or simply replace? An even stronger word might be supplant, but that just doesn't have a nice ring to it.


>>>josevalim, Member

;##D164 reaplce_attributes would be the best name
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D163
;##SEN NEU
;##D165 BUt ti doesn't make much sense to have a method
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D162
;##SEN NEU



If there would be a method, I would simply call it replace_attributes. BUT in my opinion and experience it doesn't make sense at all to have a method like this in Rails because replace_attributes would be tied to the model while its behavior should actually be given by the resource (which is then defined by the application). Remember that different actors in the system (for example user and admin) may see the same model as two different resources where PUT would behave differently for each. Even without those actors, a single model may be exposed as two different resources or vice-versa.


In other words, replace_attributes (or anything like that) would be a poor fit and ultimately lead to poorly designed APIs as people would believe that a call to replace_attributes would be everything you would need to have proper PUT semantics.


>>>myronmarston, Contributor


You bring up good points, @josevalim.  I agree that people tend to think "model == HTTP resource" (or not even really think in terms of HTTP resources) and replace_attributes may seem to implicitly condone that line of thinking.

;##D166 Rails currently doesn't have anything
;##ROLE ETC
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D165
;##SEN NEU



That said, rails doesn't currently have anything that helps make it easy to implement proper PUT semantics.  If you want to implement proper PUTs you are essentially totally on your own.  Do you have a better suggestion?  (Also, should we take this to another thread? I don't want to derail the discussion here, but it's certainly related).


As I see it, replace_attributes isn't the perfect answer to HTTP spec or REST compliance any more than the rails scaffolds are.  But it is a tool that can help make it easier to implement proper semantics (FWIW--I implemented this in one of my models on a recent project, and it worked great).


>>>josevalim, Member

;##D167 Rails is a framework, it doesn't have to provide that
;##ROLE PM
;##INV T
;##BCOM F
;##FORM SOL
;##REL REFR D166
;##SEN NEU



How Rails doesn't provide anything? Rails is a framework, anyone can provide his own PUT setup according to his application semantics, as you did. And probably in less than 30LOC! Please start a new discussion as I have no interest in the direction this is going.


>>>fxn, Owner


Yeah, me neither.


Resources are conceptual, ARs model database tables. There's a gap there that I think would show as a complicated setup for such a simple thing.


I prefer to discuss that in another issue or PR.


>>>myronmarston, Contributor


@josevalim and @fxn: no need for another ticket. Two core rails members have weighed in against the idea.  Thanks for the input.  That's one less open source contribution I need to worry about; I have enough on my plate as it is.


>>>arunagw, Member


#5130 merged.


>>>miguelsan, Other


In the risk on being pedant by arguing on a closed discussion against the last three comments (@josevalim, @fxn and @myronmarston), where I even haven't any personal use case yet, I will still make my point here, since I don't know where it goes better.

;##D168 Rails does need sucha  method though
;##ROLE ETC
;##INV F
;##BCOM F
;##FORM SOL
;##REL REFR D177
;##SEN NEU



Rails does not provide a clean way to map resources to models "to and fro", which makes josevalim's point somewhat valid. I mean, devs usually call a model into a variable (normally in the controlle's show method), but they might as well make a mix of some related models to represent the resource that they want to expose. In this second case, they then have to rip the params off in the update action, so that they get the different models to validate and save and so on. That's what I see as a weak part of the framework. I feel that josevalim's argument could backing up a kind of "presenters-and-back" as a best way to translate/map models into resources, and that the implementation of such a paradigm into Rails should be seriously weighted. Were they dismissed (which I suppose, for that is a whole subject in itself), I would then come to my conclusion: I dislike disregarding a new method called replace_resource , which sets all empty attributes to nil (or blank, depending on validation rules), supposed that it gets applied on a single model. You can afterwards put all needed warnings in the documentation about the semantic meaning of it. I mean, Rails 4 is going to promote a new verb just to adhere to standards, without any appreciable gain in the short term, just for the sake of it? Do you really mean that you are going to leave devs on their own, having to understand why to use this or that, without further help? "Boy, if you want to make proper use of this new feature that we advocate, you'll have to write your own methods for it, it's just 30LOC, boy. After all, Rails is just a framework, don't expect too much from us."


See my point? I know I am a bit sarcastic at giving reasons for my petition, but I do it just in order to make it crystal clear and avoid another six months of discussion on the need of such method. I hope I got it.


PS. Sorry for coming in so late, I just saw the thread linked in the Rails Blog. I got through the whole of it, oh my!


>>>miguelsan, Other


I elaborated a bit more on the subject of ResourceAccessor and how and why the replace_resource method is needed..


>>>bf4, Contributor


fwiw, I backported the HTTP PATCH verb work for Rails 3.2 https://gist.github.com/bf4/8940203


>>>nextofsearch, Other


Hi @bf4,


Your patch doesn't work with my app. Rails 3.2.22.5


It crashes when running the web server with the following error:




.rvm/gems/ruby-1.9.3-p551@rails3.2/gems/actionpack-3.2.22.5/lib/action_dispatch/routing/mapper.rb:178:in `default_controller_and_action': missing :action (ArgumentError)




When running 'rake routes'




rake aborted!
ArgumentError: missing :action
/Users/danolee/.rvm/gems/ruby-1.9.3-p551@rails3.2/gems/actionpack-3.2.22.5/lib/action_dispatch/routing/mapper.rb:178:in `default_controller_and_action'




Any help will be greatly appreciated.


