>>>jasnell, Owner


Node-EPS: nodejs/node-eps#7
Ref: #4660,




It soft deprecates Buffer()


It adds Buffer.allocUnsafe(size) as a direct replacement for Buffer(number)


It adds Buffer.alloc(size[, fill[, encoding]]) to create a new initialized Buffer.


It adds Buffer.from(data[, encoding) as a direct replacement for Buffer(data[, encoding]) (for every variant)


It adds a --zero-fill-buffers command line flag that forces Buffer(number), Buffer.alloc(), and SlowBuffer(number) to zero fill the initialized Buffers.


It adds documentation, test cases and new benchmarks for each of these.


It modifies every existing call to Buffer() currently in core in order to demonstrate the extent of the changes required by these edits. It's not a small change by any measure.




Note: PR description updated to reflect new naming and implementation details


>>>silverwind, Contributor



;##D1 We should replace the name safe/unsafe with something better
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

+1 on the current approach, but can we please find another name? safe and unsafe might be immediately clear in the context of the current issue, but imagine someone who is unfamiliar reading the docs. How about something like





where unsafe is a boolean. Maybe even find a better name for the argument.


>>>jasnell, Owner


-1 on Buffer.allocate(num[, unsafe])

;##D2 The proposed replacement for tha method is not suitable
;##ROLE OP
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D1
;##SEN NEU

Part of the motivation for this change is to make the choice between using
a prefilled buffer or not more explicit and obvious. We don't achieve that
using a single method with an optional Boolean.


We can bikeshed the names but safe and unsafe are concise and to the
point.
On Jan 13, 2016 9:57 PM, "silverwind" notifications@github.com wrote:




+1 on the approach, but can we please find another name? safe and unsafe
might be immediately clear in the context of the current issue, but imagine
someone fresh reading the docs. How about something like


Buffer.allocate(num[, unsafe])


where unsafe is a boolean.


—
Reply to this email directly or view it on GitHub
#4682 (comment).




>>>jasnell, Owner


@trevnorris @ChALkeR @Fishrock123


>>>ChALkeR, Owner


@jasnell I might miss the point of this a bit, but just to be sure:




This commit features hard deprecation and does not touch the docs at all. The proposed solution was soft (doc only) deprecation at first.



;##D3 Buffer.unsafe should be either removed or reworded
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

The deprecation message tells people to use «Buffer.safe or Buffer.unsafe» with no warnings against the latter. The latter should be either removed from this notice or reworded, see #4660 (comment) and #4660 (comment).



;##D4 Buffe.safe needs new tests
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

Buffer.safe(number) probably needs new tests, including those that make sure that it's zero-filled.




>>>saghul, Member



;##D5 Would a safe Buffer be built with malloc+memset with this?
;##ROLE PM
;##INV F
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

Just a quick note/question: with this approach a safe Buffer would be basically built with malloc + memset, right? (I'm looking here)



;##D6 Using calloc would be faster
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D5
;##SEN NEU

In order to make safe buffers faster it might be a good idea to use calloc, since the zeroing could essentially be free in some cases. Repeating the benchmarks @mscdex did afterwards would be nice.



;##D7 Why is the arraybuffer allocated instead of passing the size?
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

Related question: is there a reason why the ArrayBuffer here gets the data allocated right above instead of just passing the size and letting it use its constructor which would already use calloc if the zero-fill flag was set? (see here).


PS: I just glanced throught the code out of curiosity, I might be totally off-base here. Sorry for the noise if that is the case.


>>>ChALkeR, Owner


@silverwind
-1 on Buffer.allocate(num[, unsafe]).


Several reasons:



;##D8 The new name would make it hard to grep
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D1
;##SEN NEU

That is a bit harder to grep and to automatically find all the places where you (or someone else) is using unitialized Buffers.

;##D16 The flag changes into not intuitive
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D1
;##SEN NEU

That flag changes the behaviour of a function in an unobvious way (I have seen people failing to understand all impications of using unitialized buffers).

;##D17 The name is not self-describing enough
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D1
;##SEN NEU

The names for these functions should better be self-describing.

;##D18 Merging different behaviours should be avoided
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D1
;##SEN NEU

Merging two different methods with different behaviour into a one that changes it's behaviour depending on a flag isn't a good design move.

;##D19 The methods should have separate documentations
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D1
;##SEN NEU

(Pretty important). The documentation on those methods should be separate, and it's very important. While Buffer.safe could be documented as usually, Buffer.unsafe documentation should describe all the dangers of using unitialized Buffers.




>>>ChALkeR, Owner



;##D9 Is there a performance hit on buffer.safe(number) vs buffer.unsafe(number).fill(0)?
;##ROLE PM
;##INV F
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

Once more notice: as it looks now, Buffer.safe completely ignores the pooled behaviour. What impications would that have on performance of Buffer.safe(number) vs Buffer.unsafe(number).fill(0)?


/cc @trevnorris


>>>rvagg, Owner


if someone wants to quickly do some benchmarks for us, you can grab N|Solid and run the buffer benchmarks. It's based on the latest v4.x and comes with a "policies" feature that you can use to zero-fill by default—it switches out the malloc with a calloc when enabled, see: https://docs.nodesource.com/nsolid/1.2/docs/policies. The performance profile for this would be very close to what we'd end up with by doing this by default in core because it's basically the same thing.


>>>jasnell, Owner


@ChALkeR ... This PR is still a work in process so some pieces are still missing or not quite complete. It's intended to facilitate more constructive conversation about what changes we need to make. I fully intend to iterate on it more and add the necessary docs.


>>>jasnell, Owner


@saghul ... with the approach currently implemented by this PR, calling Buffer.safe() allocates a new Buffer using calloc (see https://github.com/nodejs/node/pull/4682/files#diff-196d056a936b6d2649721eb639e0442bR90). Calling createBuffer() with flags[kNoZeroFill] set to 0 will cause the ArrayBufferAllocator::Allocate() function in node.cc to use calloc(size,1) as opposed to malloc.



;##D10 There's no performance benefit, but it's safer
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D9
;##SEN NEU

Currently, when Node starts up, a large buffer pool is created. New Buffer instances created using Buffer(num) are allocated off that pool and the memory is NOT zeroed out each time. Calling Buffer.safe() bypasses this pool and ensures that a new zero-filled allocation is created each time. You don't get the performance benefits of the pool but it's safer overall. And calling calloc should be a bit faster than calling fill(0) after the memory is already allocated, but that needs to be benchmarked (I'm sure @trevnorris could say for sure).


I'll be looking for ways of making this more efficient but given that the intent is to provide a more obvious way of creating "safe" buffers, going straight to calloc each time likely makes the most sense. We'll see tho.


>>>saghul, Member


@jasnell ah, I see now, thanks!


>>>jasnell, Owner


Looking at the implementation for the --safe-buffers command line flag now... there are a couple of design questions. The intent of --safe-buffers is to force all newly created Buffers to be zero filled automatically. Given that, there are three approaches I can take with this:



;##D11 We could use the slaw buffer pool with fill(0)
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU
Still use the slab buffer pool and fill(0) all Buffers after they are created. This works ok for smallish Buffers but could have significant performance impact on large buffers.

;##D11 Or we could skip the buffer pool
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU
Skip the slab buffer pool and simply calloc all new Buffers. This is more efficient than calling fill(0) but means we don't enjoy the benefits of the slab allocated pool.


;##D11 Alternatively, an hybrid appraoc
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU
Use a hybrid approach... for Buffers under a certain size, we allocate off the pool and fill(0), but for Buffers over that size we fall back to calloc.





;##D12 The flag will definitely have an impact on performances
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D11
;##SEN NEU

Regardless of the option chosen, --safe-buffers is going to cause a significant performance degradation, it's just a matter of figuring out how to minimize it.


>>>ChALkeR, Owner



;##D13 The name --safe-buffers is missleading
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

@jasnell Btw, about --safe-buffers — I don't like that name. Buffers are generally safe, careless (or accidential) usage of Buffer(number) isn't. Also, that flag probably should be there only until Buffer(number) is hard deprecated (or removed). Perhaps giving it a more explicit name, like --safe-buffer-from-number or --safe-buffer-number would be better.


>>>ChALkeR, Owner


@jasnell About the Buffer(number) speed under the flag:



;##D14 Buffer.safe should be fast with multiple values
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D11
;##SEN

Buffer.safe(number) should try best to be fast with various number values. That could involve calloc-ing for all number values, or callocing for large number values and using a pooled approach (like Buffer.unsafe(number).fill(0)) for smaller number values, whichever is faster.

;##D15 If the --safe-buffer-number flag is enabled, buffer should behave the same as buffer.save
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

Buffer(number) under the --safe-buffer-number flag (or however it would be called) should behave exactly like Buffer.safe(number) and reuse that code. That will guarantee that it's as fast as Buffer(number) is and minimize the codebase, lowering the probability of introducing bugs.




>>>jasnell, Owner


@trevnorris @silverwind @saghul @ChALkeR ... ok, pushed an update:




adds documentation


adds SlowBuffer.safe() and SlowBuffer.unsafe() also, deprecates SlowBuffer(size)


changes the impl of Buffer.safe(len) to simply call Buffer.unsafe(len).fill(0), benchmarks are showing that it's still faster than doing the calloc directly every time.


expands benchmark/buffers/buffer-creation.js to include the safe and unsafe options and larger buffer sizes


updates test cases and internal code bits to use SlowBuffer.unsafe.




Still todo: add the --safe-buffer command line flag... per @ChALkeR's comments I'll likely rename it to --zero-fill-buffers


>>>Fishrock123, Owner


This is moving a bit quick, but some general things:


;##D20 Buffer should be deprecated
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

If we are going to do this, Buffer(number) should be deprecated, probably first only in docs. I prefer runtime deprecations, since you can ignore them --no-deprecation, but I understand some users don't.

;##D21 safe and unsafe are not descriptive names
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D1
;##SEN NEU

safe() and unsafe() are not actually that descriptive. These sound like you are turning something on or off. I suggest going for allocSafe() and allocUnsafe().

;##D22 --zero-fill-buffers is a better name
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D13
;##SEN NEU

--zero-fill-buffers is a better naming, yes.





;##D23 Would it be worth to have a safe pool?
;##ROLE PM
;##INV F
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

You mentioned the pooling aspect. Would it be worthwhile to have a safe pool, or does that defeat the purpose?



;##D24 The commit should be split because they're too large
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

@jasnell Could you make sure to split up these commits, one replacing usage in core should be separate as it is quite large and makes this difficult to review.


>>>jasnell, Owner


@Fishrock123 ... I have absolutely no intention of landing this any time soon so there shouldn't be a worry about it moving too quickly :-) ... the intent right now is to get concrete options in the form of working code on the table for discussion as opposed to going around and around discussing whether or not it's a bug or not.


>>>jasnell, Owner



;##D25 Having a safe pool would not be worthwhile
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D23
;##SEN NEU

oh, another point, having a safe pool likely isn't worthwhile because you'd end up having to zero fill every time anyway to reset from the last time :-) An argument could be made that if --zero-fill-buffers is set, the pool should be zero filled on creation but given that we end up having to zero fill later anyway, it's a bit redundant and wouldn't buy us anything.



;##D26 The current implementatio of safe does an unsafe+fill and works faster than it should
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

Also, the current implementation of Buffer.safe() simply does a Buffer.unsafe().fill(), which shouldn't  be more efficient that simply doing a calloc but benchmarks are showing that it is... which baffles me a bit. I'd like to get that figured out.


>>>jasnell, Owner


@Fishrock123 ... I reswizzled the commits to make it easier to review.


>>>MylesBorins, Owner


citgm: https://ci.nodejs.org/job/thealphanerd-smoker/41/


>>>jasnell, Owner


Pushed a new commit to use the names zalloc() and alloc() instead


>>>Fishrock123, Owner


(What is zalloc?)


>>>jasnell, Owner


zalloc == 'zeroed-allocation'


>>>trevnorris, Contributor


this won't return consistent results, but not sure how to make it otherwise.


>>>jasnell, Owner



;##D27 The best approach would be to do multiple allocatiosn
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

Yeah, I was going to get back to that to see. The best approach I can think of is to do a whole bunch of allocations and test all of them


>>>trevnorris, Contributor



;##D28 That would icnrease the lielihood, but won't rule out missing the failure
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D27
;##SEN NEU

while that may increase the likelihood of hitting possible failure, won't rule it out. guess we can just do a best possible approach.


>>>jasnell, Owner



;##D29 It might not be possible to do better
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D28
;##SEN NEU

I'm not sure it's possible to do any better than that, unfortunately.


>>>trevnorris, Contributor


Recap of a couple points discussed on IRC:


;##D30 Buffer.zalloc should return crateBuffer
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

In Buffer.zalloc() simply return createBuffer(size);. Reason is because using the pool will allow uninitialized memory to exists in buffer.buffer, and if you're opting to use initialized memory then I'm alright making the assumption that the added perf hit (IIRC ~15% depending on allocation size) is not of concern to the user.

;##D31 It's weird that the user would have to use both constructor and factory
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

It feels a bit awkward to me that users would use the constructor new Buffer(string) but then a factory method Buffer.{z}alloc(). Granted, the new keyword is pointless in every regard since we create a new Uint8Array() anyway, but this is completely about user perception.




>>>trevnorris, Contributor


@saghul




is there a reason why the ArrayBuffer here gets the data allocated right above instead of just passing the size and letting it use its constructor which would already use calloc if the zero-fill flag was set?





;##D32 Zero-fill didn't exists at that point
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D7
;##SEN NEU

The zero-fill flag didn't exist when the native API was first updated. Good point that the flag could be toggled here just as easily.


>>>mafintosh, Member



;##D33 We should replace the constructor with buffer.from
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D31
;##SEN

@trevnorris i think we should add Buffer.from(str) and deprecate the constructor entirely. see #4660 (comment) for the reasoning


>>>ChALkeR, Owner


@jasnell Please note #4660 (comment)


>>>trevnorris, Contributor


@mafintosh Completely removing what has been a core part of the API almost since the beginning of node itself would require an EPS (https://github.com/nodejs/node-eps)


>>>mafintosh, Member


@trevnorris i would just hard deprecate it for now. would that require an EPS as well? hard-deprecating the number constructor only wouldn't have helped in any of the actual security issues we've found so far in userland modules.


>>>jasnell, Owner



;##D34 Reliable safety will come through --zero-fill-buffers
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

@ChALkeR ... yeah, I saw the comment. I don't believe it's accurate to say that most users should always zero-fill (using zalloc()) as the decision comes down to the specific needs of the code. Reliable safety (as @mikeal points out] will come through the use of the --zero-fill-buffers command line which will force everything to zero fill (but at a significant performance cost). The most I think we need to do in the documentation is explain the differences between Buffer.zalloc() and Buffer.alloc() in as clear and simple way as possible.


>>>jsha, Contributor



;##D35 The names alloc and zalloc are not intuitive
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

I definitely think the names alloc() and zalloc() are inadvisable. They imply that alloc() is the default function most people should use, while zalloc() is the unusual exception. I think alloc() and unsafeAlloc() would be much better. Even better would be to have a separate library for unsafe memory manipulation.


>>>trevnorris, Contributor


@mafintosh I think because the end goal is to remove it completely it may. Though this is something that should be brought to the @nodejs/ctc.


>>>jasnell, Owner


@trevnorris ... I've added this PR to the ctc agenda.


>>>jasnell, Owner



;##D36 Zalloc might not be the ideal default choice
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D35
;##SEN NEU

@jsha ... I'm personally not convinced that zalloc should be the default choice. The decision comes down to a choice between performance and safety, both of which are equally important depending on the use case. Neither should be preferred over the other.


>>>jsha, Contributor



;##D37 Presenting both gives th eidea that forgoing safety checkes is ok
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM SOL
;##REL REFR D36
;##SEN NEU

@jasnell: For almost all workloads, the difference in performance to zero-fill buffers is not a limiting factor. Presenting the safe and unsafe version of a function as equivalent implies that forgoing safety checks is a typical optimization step that many people should consider. In fact, it is an exceptional step that should only be undertaken after profiling and thorough testing.


>>>mikeal, Owner




Deprecate Buffer(num)





;##D38 Deprecating buffer would have enormous consequences
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D20
;##SEN NEU

The impact of this on the ecosystem is so massive that I can't even begin to think into the future where this would be more than an annoying warning. This is also incredibly difficult to test for because you're only deprecating one input type which, in an un-typed language, is very difficult to detect through just a modules unit tests.


>>>mikeal, Owner



;##D39 Why do we need two APIs when we have the --safe-buffers?
;##ROLE PM
;##INV F
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

So, what is the purpose of creating two APIs if we have the --safe-buffers option? I don't see how splitting the package ecosystem into modules that behave with different characteristics is preferable to one where we can alter the runtime to different characteristics for different use cases?


>>>jasnell, Owner



;##D40 Seems removing alloc and leaving Buffer is the best approach
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D39
;##SEN NEU

@mikeal ... at this point, after going through the exercise of implementing and testing this, I agree with you. I'm leaning towards taking alloc() back out, leaving Buffer(num) in place as it currently is, leaving the new zalloc() to support those who want to be able to allocate zero-filled buffers easily moving forward, and keeping (and backporting) the --zero-fill-buffers option.


>>>mafintosh, Member



;##D41 Having two APIs cover more corner cases than the flag
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D39
;##SEN NEU

@mikeal The main security issues we encountered in actual modules (ws and bittorrent-dht) resulted from Buffer(num) being called instead of Buffer(string) because of a programming mistake. Zero-filling buffers wouldn't have fixed these issues but having explicit APIs for both of these constructors might have. bittorrent-dht is a very well tested module and the collaborator list contains a bunch of really talented node programmers and it still had this issue. Anyway, this whole "unsafe Buffer" discussion kinda blew up and got derailed a bit. I'm leaning towards just implementing these APIs in a userland module and using that from now on.


>>>mikeal, Owner




Zero-filling buffers wouldn't have fixed these issues





;##D42 Would it has still been a security issue?
;##ROLE PM
;##INV T
;##BCOM T
;##FORM OPQ
;##REL ELAB D41
;##SEN NEU

What do you mean? Do you mean you still would have had a bug and zero-filling only would have stopped it from being a security issue or that it still would be a security issue even if zero-filling was global?


>>>jasnell, Owner


Sounds to me like two separate conversations became conflated with one another and the conversation derailed from there.


>>>jasnell, Owner


Nevertheless, having a PR will real code helps the discussion far more than and endless thread that's going around and around ;-) ... I'm going to let this PR sit until we can discuss on next weeks CTC call.


>>>mafintosh, Member



;##D43 It would have been a less server issue
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D42
;##SEN NEU

@mikeal zero-filling would have made it a less severe issue but you would still have been able to remotely crash processes by doing Buffer(largeNumber)


>>>mafintosh, Member


@jasnell yes i agree.


>>>ronkorving, Contributor



;##D44 Using a boolean flag is not that bad of an idea
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL REFR D2
;##SEN NEU

I don't see why Buffer.allocate(n, unsafe) is so unpopular here? Leaving out the boolean (the easy user behavior) would make it safe by default. Only when you really know what you're doing, do you make it unsafe explicitly. To me, this is similar to the noAssert boolean you can pass to all Buffer read/write functions. I think it avoids all proposed naming issues (safe/unsafe, alloc/zalloc). I know @ChALkeR listed a number of reasons, but they don't seem very convincing to me (and some sound like the same concern using different words).


>>>reqshark, Other



;##D45 It can be fairly dangerous
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D44
;##SEN NEW

@ronkorving it seems clearly dangerous if a hex or some weird number got into a Buffer constructor call




you would still have been able to remotely crash processes by doing Buffer(largeNumber)




to @mafintosh's point, perhaps there's a compromise somewhere here,


like a default BUF_MAXsize in bytes that could be configured?


>>>ChALkeR, Owner


Everyone, PTAL at https://github.com/ChALkeR/notes/blob/master/Lets-fix-Buffer-API.md


>>>jasnell, Owner


@ChALkeR ... thank you, I know you put a lot of work into that and it's definitely appreciated. Go get rest now! :-)


>>>jasnell, Owner


Note: Updated the PR description to reflect current status


>>>jsha, Contributor



;##D46 What about replacing --zero-fill-buffers with --unitialized-buffers
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

Instead of adding a --zero-fill-buffers option that people have to know to turn on, what about adding a --uninitialized-buffers option that people can turn on if they would like the old behavior? That would make modules safe by default, and provide an escape for anyone who found that their code became unacceptably slow.


>>>saghul, Member




changes the impl of Buffer.safe(len) to simply call Buffer.unsafe(len).fill(0), benchmarks are showing that it's still faster than doing the calloc directly every time.





;##D47 What benchmark and on what os?
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D26
;##SEN

Out of curiosity, what benchmarks did you run and on what OS?


>>>jasnell, Owner



;##D48 It was a custom benchmark on OSX
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D47
;##SEN NEU

@saghul ... the implementation has changed since I made that comment but... I created a custom benchmark for the purpose of testing the specific implementation and tested on OSX. The result was...odd.


>>>ChALkeR, Owner


@jsha, see q/a  points 10 and 3.


>>>saghul, Member




tested on OSX. The result was...odd.





;##D49 The results would differ based on the OS
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL GEN D48
;##SEN NEU

I asked because I assume the result could vary depending on the OS, libc implementation and so on... so some more diverse benchmarks would probably help make a better choice IMHO. Also, the buffer size can have an impact, but guess you did test that.


>>>ChALkeR, Owner


@jasnell, see q/a point 18, please.


>>>jasnell, Owner


@ChALkeR ... :-) I've read your excellent write up twice already ;-) thanks for doing that btw


>>>jasnell, Owner


Pushed an additional update based on ongoing discussions with numerous people.


>>>piscisaureus, Member



;##D50 Node should always zero-initialize buffers
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL REFR D46
;##SEN NEU

I think that if node is to zero-initialize buffers then we should just do it always. I don't even think that it would be a behavioral change - currently the contents of a new Buffer are unspecified and in practice are often indeed filled with garbage contents from old Buffers.



;##D51 We used to be too concerned about performance
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL ELAB D50
;##SEN NEU

I think in the past we were too concerned about performance. Likely initializing all buffers by default will not have a big performance impact; at least there would be no harm in trying it out.



;##D52 --zer-fill-buffers should be the default behaviour
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM SOL
;##REL GEN D46
;##SEN NEU

So I'm in favor of the --zero-fill-buffers argument to test out this new behavior. I think it would be even better to make it the default behavior, and evaluate just before cutting the next LTS.


Not a fan of the whole alloc/zalloc/deprecate fanfare. Future direction of the Buffer API should be to align it closer to TypedArrays. (which also happen to be zero-initialized btw)


>>>rvagg, Owner


@ChALkeR can I suggest updating your two gists to make it clear that the current behaviour of Buffer is by design. Like it or not, this is not a surprise or a newly discovered "security vulnerability" which is how a large portion of the people interacting with the various issues are interpreting things, leading to misunderstandings and frustrations with the way many of us are responding. i.e. THIS IS A SECURITY BUG, FIX IT NOW! vs I don't like the design decisions, can we please change them?


>>>ChALkeR, Owner


@rvagg I thought that I did.


First one:




If you fully understand that and are aware of how to prevent it — you could stop reading this note now, there will be nothing new for you here. I have seen several people who are not aware of that, so this note will be used as a reference in such situations.




By «nothing new» I meant that this is not something that has been discovered just now, but is done by-design and documented. I will elaborate that a bit and add a sentence noting that it's intentional behaviour.


Second one has this note at the top:





;##D53 The problem is how easy is to use the current API unsafely
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

Note: none of those describes any previously unknown vulnerability in Node.js, this is how the API was designed. The problem is in the fact that it's very easy to use the current API in an unsafe way, and there were various libraries hitting that (and probably many more still are).




That looks enough, no? Moreover, most part of that document was written to stop repeated questions over and over again and make the discussion more constructive. There is the whole Q/A section plus these citations:




Note: I am aware of various opinions on this issue. This post covers most of them in the Q/A section. Please, read this whole document first before posting comments or expressing your opinion anywhere, it covers some issues that you might have missed.


Do not forget that all the relevant issues are not votings, so posting plain «+1», «me too»-s, or «I hate this» comments is generally counter-productive. If you have anything to say or propose, please, do that in a constructive manner.




>>>rvagg, Owner


@ChALkeR yeah, sorry, I was asking for greater clarification. It's clear from #4660 that people are not reading any nuance here, hence the need to be absolutely clear & blunt.


>>>ChALkeR, Owner


@rvagg ChALkeR/notes@dedf246, ChALkeR/notes@a333069


>>>LinusU, Contributor



;##D54 Is it a good idea to have different behaviour on similar names?
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

Is it really a good idea to have a .from which doesn't do the same thing as TypedArray.from()?


Subclassing something and overriding some functions to do something different seems like it could potentially cause some confusion...


>>>trevnorris, Contributor



;##D55 We cannot use Buffer.from due to a read-only property
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

@jasnell I don't think anyone has taken into account the fact that we cannot use Buffer.from() since it is a read-only property of Uint8Array. e.g. if you attempted to run this it would print:




So, time to look for a different name.


>>>jasnell, Owner



;##D56 That's avoided by setting it before the prototype
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL REFR D55
;##SEN NEU

@trevnorris if you take a look at the PR, you'll see I get around that by declaring the from method before we set the prototype. Turns out to work rather well.


>>>jasnell, Owner


that is, I have Buffer.from working in the PR with all tests passing


>>>trevnorris, Contributor


@jasnell Ah nice. Thanks for pointing that out. Also from the conversation I feel like people believe that Buffer will eventually no longer be a constructor?


>>>jasnell, Owner

;##D57 The buffer constructor would be kept but deprecated
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW 
;##SEN NEU

The constructor form would be deprecated but not removed... And deprecation
would be docs only initially.
On Jan 19, 2016 3:29 PM, "Trevor Norris" notifications@github.com wrote:




@jasnell https://github.com/jasnell Ah nice. Thanks for pointing that
out. Also from the conversation I feel like people believe that Buffer
will eventually no longer be a constructor?


—
Reply to this email directly or view it on GitHub
#4682 (comment).




>>>trevnorris, Contributor



;##D58 The buffer constructor cannot be ever removed
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D57
;##SEN NEU

@jasnell Just so everyone is clear, it can never be removed.


>>>jasnell, Owner


Yep. Eventually we can look at a hard deprecation and switching the default
behavior to zero fill, but removing the constructor completely is not
possible.
On Jan 19, 2016 3:41 PM, "Trevor Norris" notifications@github.com wrote:




@jasnell https://github.com/jasnell Just so everyone is clear, it can
never be removed.


—
Reply to this email directly or view it on GitHub
#4682 (comment).




>>>ChALkeR, Owner



;##D59 An alternative would be to throw everytime
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL REFR D58
;##SEN NEU

@trevnorris The most close thing to removing it would be throwing on all input, but I do not see how that is better than leaving it in hard-deprecated state indefinitely.


>>>trevnorris, Contributor


@ChAlKeR going in between this thread and the EPS is redundant. Going to consolidate my conversation there. You'll see my comment about the Buffer constructor.


>>>jasnell, Owner


PR Rebased and Updated.


>>>ChALkeR, Owner


@jasnell Could you update the PR title and description, please? It's a bit confusing atm.


>>>jasnell, Owner


Bah... forgot to do that when I updated earlier... will update it now :-)


>>>trevnorris, Contributor



;##D60 Fill shouldn't not be required to be a string
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

fill shouldn't not be required to be a string. Buffer(5).fill(10) works today.


>>>trevnorris, Contributor



;##D61 This check is redundant
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

I'll assume this is only to handle the case where Number.isNaN('size'). But I also see the same check is performed by the need to run new Uint8Array(). Basically, don't need the || 0.


>>>trevnorris, Contributor



;##D62 This should be done in another part of the code
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

Don't do it here. Instead should set a variable in src/node.cc that's checkecd by ArrayBufferAllocator::Allocate  to always use calloc(). Something like this:





>>>trevnorris, Contributor


SlowBuffer never comes from the "slab".


>>>trevnorris, Contributor


extraneous whitespace change.


>>>jasnell, Owner


@trevnorris @ChALkeR ... made some updates based on the comments! thanks!


>>>tflanagan, Contributor


I'm totally nit'ing here, but in other areas of the documentation the alphabetical sort extends to the option names as well, so this would be reordered to:





>>>trevnorris, Contributor



;##D63 Should we add a check encoding !== undefined?
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

Should we do a strict if (encoding !== undefined) so values like false can't be passed?


>>>trevnorris, Contributor



;##D64 Should mirror Buffer#fill behaviour of not accepting strings
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

Current Buffer#fill() behavior does accept strings. Should probably mirror that behavior. May just want to punt on the error throw to fill() since it already does all necessary checks.


>>>jasnell, Owner


@trevnorris @rvagg ... ping ... some additional tweaks, including to node_buffer.cc and node_buffer.h


@tflanagan ... I'll update the ordering of the new doc items in the next update.


>>>jasnell, Owner


Ok, I've rebased and updated.
New CI: https://ci.nodejs.org/job/node-test-pull-request/1640/ (CI is temporarily private for non-collaborators, so I'll post the results once completed)


@nodejs/ctc @nodejs/collaborators ... putting out a last call on this. The Buffer API changes in this PR have been discussed and signed off with no objections by the CTC. If there are no further objections and if CI is green, I'll get this landed in master in 24 hours.


>>>jsha, Contributor


*versions. Also, this should probably say which versions, or "prior to X date."


>>>jsha, Contributor


Isn't this another example of the flaw in the new Buffer() constructor, where the same constructor (or function) can produce subtly different behavior based on the type of the input, where one of the behaviors is much riskier than the other? I would suggest having a separate Buffer.fromShared(arrayBuffer) or something that states intention more explicitly.


>>>jasnell, Owner


It's similar but far less unsafe... enough so that having a separate factory method likely isn't worthwhile. If it did prove to be problematic, adding a separate Buffer.wrap(arrayBuffer) (or fromShared) would still be possible.


>>>jsha, Contributor


Agreed that it's less risky. But given that it's an acknowledged risk, and we're already changing the API, why not change it once to be more robust?


Having a factory method with a different name doesn't cost any more from a complexity standpoint than having extra behavior on a single named factory method.


>>>jasnell, Owner


@trevnorris ... what do you think?


>>>ChALkeR, Owner


Perhaps Buffer.from(array) and Buffer.shared(arrayBuffer)?


The first (from) method actually converts the data, but the second one doesn't.
To me it looks like Buffer.shared( is a more intiutive description of what that method actually does.


Update: ignore the .shared( proposal, see what @domenic said below.


>>>domenic, Member


I don't have much of an opinion on whether to split but if you do, please don't use "shared". SharedArrayBuffer is coming, and so in the context of typed array APIs "shared" ends up meaning "shared among different threads".


>>>ChALkeR, Owner


Ah. @domenic, thanks.


Disregard my proposal about .shared( then. Note that it also perhaps affects the .fromShared name — it would be strange to have it if SharedArrayBuffer is going to be a different thing.


But I still would prefer a separate name for that method.


>>>jasnell, Owner


+1 thank you for that bit of info @domenic


>>>trevnorris, Contributor


Pass anything that can be transversed via index and it is treated like an array. An ArrayBuffer can't. Now, if we had it so passing a Typed Array used the same ArrayBuffer I can see how that could be confusing. In addition, this is the same API that new Uint8Array follows. No need for a new API call.


Just spoke w/ @jasnell on IRC. We've agreed that the signature should also match. So the API would be Buffer.from(arrayBuffer[, byteOffset[, length]]). This is an API gap, since there's no way to make a slice of an ArrayBuffer for a new Buffer instance. (@domenic I'm still pondering how to get something like readFile() to return an ArrayBuffer so could read in a 10GB file and make multiple slices of it into Buffers. though, not that it's a good idea, but hey)


>>>seishun, Member


I dislike how this change makes one function "preferred" over the other. I've been using Buffer(Number) in my modules that aren't for web servers and I know what I'm doing, so this change would present me with an uncomfortable choice;




Deliberately waste cycles by using Buffer.alloc, when I have absolutely no need to zero-initialize my buffers.


Use the "non-default" Buffer.allocUnsafe, causing anyone reading my code to wonder why I'm using it over Buffer.alloc in non-performance-critical code.




My proposed alternatives:




Name the two functions equivalently, for example zalloc and allocRaw. Clearly document their difference.


If you're dead-set on "deprecating" the non-zeroing allocation, then just remove it entirely. People who care about performance are screwed anyway, since a lot of modules would use the zeroing allocation when they don't need it, just because it's the "default" one.




>>>jasnell, Owner


@seishun ... I definitely understand the objections and this has been discussed extensively. The current PR is a compromise between several different points of view and I understand that not everyone is happy with the naming. The documentation is careful not to imply that alloc is the "default" choice, it's just one of several choices, and it makes it clear that using alloc has a definite performance cost. Buffer.allocUnsafe is not the prettiest thing in the world, but it does represent a balance of several different points of view.


To be certain tho, the non-zeroing allocation is not being deprecated in any way... it's just being made more explicit.


>>>ChALkeR, Owner


@seishun




causing anyone reading my code to wonder why I'm using it over Buffer.alloc in non-performance-critical code.




You shouldn't.


>>>jasnell, Owner


@ChALkeR .. I want to avoid extending the debate around this any further. Let's keep the conversation focused on technical review of the PR itself, not debates over the validity of when or when not to use alloc vs allocUnsafe.


>>>seishun, Member




You shouldn't.




This statement conflicts with @jasnell's:




The documentation is careful not to imply that alloc is the "default" choice, it's just one of several choices




and




To be certain tho, the non-zeroing allocation is not being deprecated in any way




You're basically saying that everyone should use the zeroing allocation even if they don't need it, unless they absolutely need the performance. That very much sounds like one function is "default".


Also, by this logic every module ever should use the zeroing allocation. That leaves the allocUnsafe only for end-user code, at which point it seems rather useless.


>>>ChALkeR, Owner


@jasnell




@ChALkeR .. I want to avoid extending the debate around this any further. Let's keep the conversation focused on technical review of the PR itself, not debates over the validity of when or when not to use alloc vs allocUnsafe.




Sorry. I missed your message at first, but I have removed my follow-up comments now.


@seishun, we can continue this discussion in IRC.


>>>jasnell, Owner


@ChALkeR ... no worries.


>>>jasnell, Owner


There was a linting issue in CI (fixed now) and some unrelated failures due apparently to the build bot hiccup on arm.


@nodejs/ctc ... can I get a round of sign offs on this so I can get it landed?


>>>trevnorris, Contributor


bad naming. allocraw is supposed to be allocUnsafe()? Personally I still vote for Buffer.allocRaw(), but should probably make these names match either way.


>>>jasnell, Owner


whoops... forgot to get these updated. Will do now


>>>jasnell, Owner


Done


>>>trevnorris, Contributor


since these are being changed already, can they be const-ified?


>>>ChALkeR, Owner


Shouldn't this use Buffer.alloc(size[, fill[, encoding]]) instead of .allocUnsafe(size).fill(fill)?


>>>trevnorris, Contributor


style nit. line up on (.


>>>trevnorris, Contributor


Not sure if it's worth mentioning here, but maybe in either alloc or allocUnsafe that one is pooled and the other isn't.


>>>jasnell, Owner


It's mentioned elsewhere in the doc but it's worth repeating.


>>>ChALkeR, Owner


Perhaps this and the following line could be replaced with Buffer.from(? If res.raw is a string, I mean.


>>>jasnell, Owner


Yes, I need to go through and finish replacing the various new Buffer() uses


>>>ChALkeR, Owner


@jasnell, I see Buffer.allocUnsafe(0) in many places here. To my understanding, it should do the exactly the same as Buffer.alloc(0) does, and have the same performance. If that is true — could you replace them, please? The code might be a bit more readable that way.


>>>trevnorris, Contributor


@jasnell This will change if we add the Uint8Array signature to Buffer.from().


>>>jasnell, Owner


+1


>>>trevnorris, Contributor


Think there's a new doc style, so it'd be:




>>>jasnell, Owner


ah.. good catch, forgot about that change


>>>trevnorris, Contributor


this long code segment may wrap and look funny. maybe just pop it to a one-liner for cleanliness.


>>>jasnell, Owner


+1


>>>jasnell, Owner


Actually, this needs to be updated since it now uses your new fill(value, encoding)


>>>trevnorris, Contributor


should Buffer.poolSize >> 1 (floor of divided by 2)


>>>trevnorris, Contributor


information in this paragraph is good, but i'm missing what exactly is the "key difference"


>>>trevnorris, Contributor



;##D65 Does this throw only for numbers or for any non-string
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

If it's a number, or just if it's not a string?


>>>jasnell, Owner



;##D66 For any non-string
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D65
;##SEN NEU

well, definitely if it's a number, it'll also throw if it's not a string... this part of the code is weird tho because of the overloading


>>>trevnorris, Contributor


style nit: statement continuations indented twice. (going to check if we can add that to the linter)


>>>jasnell, Owner



;##D67 There's no need to replace internal calls to allocUnsafe
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

@ChALkeR ... in all of our Buffer uses internally, we are properly initializing the buffer content and writing to it fully, which means using allocUnsafe internally is just fine. I don't see the need to replace those internal calls with alloc()


>>>ChALkeR, Owner



;##D68 It should be changed when an empty buffer is created, since the result is the same
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D68
;##SEN NEU

@jasnell, I am aware of that and I was talking only about the cases where an empty buffer is created - the result is the same for alloc and allocUnsafe. It's a style nit, nothing else.


>>>trevnorris, Contributor



;##D69 Can we short circuit if size === 0 ?
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

If size === 0 can't we just short circuit here and return early?





This is fine b/c v8 will detect size === 0 and not call ArrayBufferAllocator::Allocate.


>>>ronkorving, Contributor


You can avoid the Math.max function call altogether then (which may shave off a few cycles).





>>>jasnell, Owner


@ChALkeR ... ah! sorry I misread your comment ;-) ... I've updated the allocUnsafe(0) calls to alloc(0) in the latest push.


@trevnorris ... pushed a number of updates, including the modification for Buffer.from(arrayBuffer[, byteOffset[, length]]) and new Buffer(arrayBuffer[, byteOffset[, length]]). Hit the rest of your feedback also. PTAL when you get the chance.


>>>jasnell, Owner


Rebased and updated....


>>>rvagg, Owner


removed ctc-agenda label, this has come up a few times now, there are no outstanding blockers from the CTC at least (minor preferences regarding "unsafe" but not enough to hold up just getting this done)


>>>ChALkeR, Owner


This is outside the bench, so Buffer.alloc(conf.len, 'b') would not change the result, but is more clean.


>>>LinusU, Contributor


Maybe remove the extra parenthesis as well, since it's no longer a new call...


>>>trevnorris, Contributor


It's also immediately filled. There's no logical reason to change it.


EDIT: filled by non-zero


>>>ChALkeR, Owner


@trevnorris Why isn't there? The code would be cleaner.


>>>ChALkeR, Owner


Ditto.


>>>ChALkeR, Owner


Ditto.


>>>ChALkeR, Owner


Btw, this is a mistake.


>>>ChALkeR, Owner


Ditto.


>>>ChALkeR, Owner


Ditto, see the following line.


>>>ChALkeR, Owner



;##D70 allocUnsafe+fill can be replaced with alloc in multiple lines
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

@jasnell, there are some places in bechmarks and tests where allocUnsafe+fill could be replaced with just alloc. I could list them here or just file an PR after this one lands to clean those up separately. Which way would you prefer?


>>>LinusU, Contributor


const outside of strict mode?


>>>ChALkeR, Owner


But the whole file is in the strict mode.
Btw, even outside of strict mode that should be fine on master =).


>>>jasnell, Owner


If you'd like, open a PR against my branch and I'll work them in.
On Feb 24, 2016 4:14 AM, "Сковорода Никита Андреевич" <
notifications@github.com> wrote:




@jasnell https://github.com/jasnell, there are some places in bechmarks
and tests where allocUnsafe+fill could be replaced with just alloc. I
could list them here or just file an PR after this one lands to clean those
up separately. Which way would you prefer?


—
Reply to this email directly or view it on GitHub
#4682 (comment).




>>>BridgeAR, Contributor


This could be rewritten to Buffer.from('abcdefghij', 'ascii');
Otherwise the typo in the line below should be fixed by including the missing i.


>>>ChALkeR, Owner


@jasnell




If you'd like, open a PR against my branch and I'll work them in.




Will do.


>>>ChALkeR, Owner


@jasnell Done in jasnell#4.


>>>jasnell, Owner


Rebased, added @ChALkeR's updates... new CI: https://ci.nodejs.org/job/node-test-pull-request/1811/


>>>jasnell, Owner


@nodejs/ctc ... can I get a final round of LGTM's on this. Would love to get this landed today or tomorrow.


>>>jasnell, Owner


Heh... had another commit hit that broke this between rebasing and starting CI... trying again: https://ci.nodejs.org/job/node-test-pull-request/1813/


>>>jasnell, Owner


So far there's one build error on Windows that looks unrelated (https://ci.nodejs.org/job/node-compile-windows/1585/label=win-vs2015/) ... @bnoordhuis or @trevnorris .. can either of you confirm?


>>>thefourtheye, Contributor




but the returned buffer instance might contain old data that needs to be overwritten




hmmm, this is not very clear.


>>>thefourtheye, Contributor


Buffer constructor function


>>>thefourtheye, Contributor


first argument


>>>thefourtheye, Contributor


to one of these


>>>thefourtheye, Contributor



;##D71 Can be zero replaced by anything or does it hold a value?
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

zero is just a value which we choose, right? It can be anything actually. This kinda gives me a feel that initializing means filling with zero.


>>>jasnell, Owner



;##D72 Zero is te default in the design
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL SOL
;##SEN NEU

No... calling alloc() uses calloc() under the covers which literally fills with zeroes by design. That's not a value we choose. Typically initializing-upon-allocation implies zeroing out.


>>>thefourtheye, Contributor


default value of length is missing.


>>>thefourtheye, Contributor



;##D73 Why is the code escaped only in thsi line?
;##ROLE ETC
;##INV F
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

Why only escaping here?


>>>jasnell, Owner


I had removed the escaping from the others and just missed this one...


>>>thefourtheye, Contributor


js


>>>thefourtheye, Contributor


js


>>>thefourtheye, Contributor


string's?


>>>thefourtheye, Contributor


What about other architectures?


>>>jasnell, Owner


That I don't know. This was taken from the existing documentation. We can add the additional info in a separate PR.


>>>trevnorris, Contributor


The sizes are max int32 (for 32-bit arch) and max uint32 (for 64-bit arch). The value matches the same as v8's max Smi value on that arch.


EDIT: It's half each of those values. e.g. on x64 it's (-1 >>> 0) >>> 1 (2147483647) and on ia32 it's (-1 >>> 0) >>> 2 (1073741823).


>>>jasnell, Owner


@trevnorris ... do the numbers in the doc need to be updated, then?


>>>thefourtheye, Contributor


is the alignment okay here?


>>>jasnell, Owner


linting does not complain


>>>trevnorris, Contributor


it's preferred that statement continuations are double indented. this should be fixed in linter.


>>>thefourtheye, Contributor


alignment.


>>>jasnell, Owner


This was copied directly from test-buffer.js which has the same issue. Let's fix this one in a separate PR


>>>thefourtheye, Contributor


This is one huuuuuuuge test. Can this be broken down to multiple files?


>>>jasnell, Owner


It was copied directly from test-buffer.js. It likely can and should be broken down but I'd prefer to do that in a separate PR


>>>jasnell, Owner


commits rebased and squashed. Added another commit fixing some linting issues in the benchmarks.


>>>jasnell, Owner


ping @nodejs/ctc


>>>jasnell, Owner


@nodejs/ctc ... this needs to get landed. I've been spending quite a bit of time just keeping it updated because other bits keep changing. Can I please get a final round of review and some LGTM's on this.


>>>ChALkeR, Owner

;##D74 The commit message should mention that fill nothing fills with zeros
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

./test/ changes LGTM.
./lib/ changes also LGTM, but perhaps the commit message should mention that fill('') now fills with zeroes intead of doing nothing.


>>>ChALkeR, Owner


What happened here?





Looks like the file encoding was changed from ISO 8859-15 to UTF-8.
Is that intended?


>>>jasnell, Owner


Appears to have been caused by my text editor being overly "helpful".  The change does not appear to have any effect on the actual benchmark so I'm inclined to leave it as it for now.


>>>ChALkeR, Owner


Not sure why it was changed in this place (it's not even the first line where it's used, but that's code style only).
Also note that no similar change was performed in benchmark/http_simple.js, where i is also not declared.


It shouldn't hold landing this PR, though, ignore this nit.


>>>ChALkeR, Owner


./benchmark/ changes LGTM with an encoding question (see above).


>>>ChALkeR, Owner


Nit: unneeded whitespace at the end of line.


>>>ChALkeR, Owner


Nit: unneeded whitespace at the end of line.
There are other cases below, I will not list all of them.


>>>ChALkeR, Owner


./doc/ changes also LGTM.


>>>jasnell, Owner


@ChALkeR ... addressed a couple of the nits, rebased and updated.


>>>trevnorris, Contributor


It's Buffer.poolSize >> 1. >> 2 is divided by 4.


>>>jasnell, Owner


good catch... looks like I simply hit the 2 instead of the 1


>>>trevnorris, Contributor



;##D75 Buffer constructor cannot ever be removed
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D58
;##SEN NEU

Even if it's "hard deprecated" it can never be removed. Since it still needs to act as a constructor for any typed array methods, or anything inheriting from Buffer.


>>>jasnell, Owner



;##D76 We could make Buffer(size) zero-fill
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

@trevnorris ... I'm now wondering if we shouldn't just go ahead and bite the bullet on this and make new Buffer(size) zero-fill by default.


>>>feross, Member



;##D77 It's too early for such a decision
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D77
;##SEN NEu

@jasnell That's a larger discussion that should probably happen after lots more code is using the new factory functions. Otherwise, users who haven't heard of the new factory functions will see that Buffer() zero fills and may write code that's insecure on older versions of Node.


>>>jasnell, Owner



;##D78 It would require parallel releases
;##ROLE OP
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D77
;##SEN NEU

Well, if we made the change we'd have to do parallel releases in each of the downlevel streams (v4, v0.12 and v0.10) that also zero filled by default. You're right, let's hold off on that one a bit longer.


>>>trevnorris, Contributor



;##D79 It might have to happen before v6 because of ES6
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D77
;##SEN NEU

Actually, it may have to happen before v6. Since using Uint8Array methods on Buffer may call the constructor due to inheritance changes in v8 to better match the ES6 spec, it'll expect it to be zero-filled.


>>>feross, Member



;##D80 Can we override the default ES6 Bahviour with @species?
;##ROLE PM
;##INV F
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

@trevnorris I thought we could override the default ES6 subclass behavior using @@species? For example, @littledan sent this PR to feross/buffer that makes the Uint8Array methods call the Uint8Array constructor instead of the Buffer one: feross/buffer#97 Was there something new that came up that is preventing the use of this strategy?


>>>trevnorris, Contributor


Think we could just make a:





To reduce the number of conditionals in the rest of the code?


EDIT: also may prevent future accidental whatnot if new functionality is added.


>>>jasnell, Owner



;##D81 Can we use a BUFFER_MALLOC macro instead?
;##ROLE OP
;##INV T
;##BCOM T
;##FORM OPQ
;##REL NEW
;##SEN NEU

How about a BUFFER_MALLOC macro instead?


>>>trevnorris, Contributor


sure.


>>>trevnorris, Contributor


@jasnell Finished review. Only have few minor things.


>>>jasnell, Owner


@trevnorris ... updated to address those few nits


>>>Qard, Member


Docs LGTM too. The rest is a bit more than I have time to process currently.


>>>ChALkeR, Owner


@jasnell, jasnell#5


>>>jasnell, Owner


@ChALkeR +1 ... will pull those in. Thank you!


>>>jasnell, Owner


@ChALkeR .. updated!


>>>ChALkeR, Owner


Argh, I broke this line in 5ee370f, sorry.
Revert in jasnell#6.


>>>jasnell, Owner


@ChALkeR ... fixed!


>>>jasnell, Owner


@trevnorris ... what's the expected timeframe when the zero-fill-by-default would need to happen to conform to the upcoming v8 changes? We'll want to coordinate that change across all the major release lines so that we have v0.10, v0.12, v4 and v5 releases that all zero fill by default on new Buffer(size)


>>>jasnell, Owner


@nodejs/collaborators @nodejs/ctc ... this is a last call for comments/feedback on this. I plan on getting this landed on Monday, March 14th.


(btw, I do plan on squashing the commits down to a single commit when landing)


>>>trevnorris, Contributor


@jasnell I believe by v8 v5.x, which I think will land by v6 release. (see: #4701)


>>>littledan, Other


That change landed in 5.1 and is not turned on in 5.0 unless you pass the --harmony flag.


>>>trevnorris, Contributor


@littledan Thanks for the update.



;##D82 zero-filling might not be necessary anymore
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

On further thought, I'm actually not certain if zero-filling is necessary in this case. Since all API calls that depend on this would use or initialize memory. @littledan That sound correct?


>>>littledan, Other



;##D83 It's safer to zero-fill anyway
;##ROLE ETC
;##INV T
;##BCOM T
;##FORM SOL
;##REL ELAB D82
;##SEN NEU

@trevnorris If you ask me, I'd err on the size of zero-filling whenever a buffer is returned to JavaScript, or even for most C++ code! Returning memory from something to something else is a pretty critical security issue, so you'd better have pretty great performance gains to justify it. However I don't have much context about this particular case.


>>>jasnell, Owner


New CI Run: https://ci.nodejs.org/job/node-test-pull-request/1931/


>>>jasnell, Owner


Unrelated CI failure in arm, otherwise everything is green.
@nodejs/collaborators @nodejs/ctc ... this is a last call for objections on this one! I will land it tomorrow.


>>>Trott, Owner


I'm not convinced (yet, anyway) that this change is unrelated to the failure on the last CI run.


It appears that this change greatly increases the flakiness of the test that failed.


Stress test on current master shows 28 failures in 999 runs, or a failure rate of about 2.8%.


Stress test with this change is still running as of this writing but with more than 600 runs, it is failing at about three times the rate of current master.



;##D84 We should not release this if it affects negatively the reliability of the tests
;##ROLE PM
;##INV F
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

I know this change has involved a lot of work and has been a fairly long time coming, But I would prefer we figure out what's going on there before landing. If this change is negatively affecting reliability on that test, it may negatively affect reliability on real world use cases too.


>>>Trott, Owner



;##D85 The test problem was originated by how the Pi drops packets sometimes
;##ROLE PM
;##INV T
;##BCOM T
;##FORM SOL
;##REL NEW
;##SEN NEU

I think I've come up with a fix for that test. Still not sure why this change would increase the problem, but the ultimate source of the issue is the way the Pi drops a packet here or there when there are a lot of connections more readily than other platforms. Not worth trying to address that issue in Node.js itself, I don't think.


Anyway, carry on, I'll open a PR to change the test itself.


>>>jasnell, Owner


@Trott ... +1, yeah I was just looking at the test and can't find a particular reason for it to be more flaky with this change.


>>>jasnell, Owner


Landed in 85ab4a5


>>>feross, Member


@jasnell Nice work!


>>>bminer, Contributor


Just realized the Buffer.from is defined in Node 4.x and it cannot be overwritten without Object.defineProperty call.  Makes it a tad annoying for Node 4.x polyfills.


Just thought I'd mention it since new Buffer is technically deprecated now and many users are still using Node 4.x.


>>>MylesBorins, Owner


@bminer it is defined because we backported the function. No need to polyfill afaik


>>>bminer, Contributor


Right, but I have systems running 6.x and Node 4.2.2, for example.


So, I have to do this to use Buffer.from everywhere:





>>>MylesBorins, Owner


is there a particular reason you are running on v4. 2.2? this is an
understatement supported and insecure version of v4


On Thu, Oct 6, 2016, 8:26 PM Blake Miner notifications@github.com wrote:




Right, but I have systems running 6.x and Node 4.2.2, for example.


So, I have to do this to use Buffer.from everywhere:


if(parseInt(process.versions.node.split(".")[0]) < 6) {
Object.defineProperty(Buffer, "from", {"value": function() {
return Buffer.apply(this, arguments);
} });
}


—
You are receiving this because you commented.
Reply to this email directly, view it on GitHub
#4682 (comment), or mute
the thread
https://github.com/notifications/unsubscribe-auth/AAecV7Iyx0ZkNw5MllbyrNIY49E8VUgaks5qxZGqgaJpZM4HEl70
.




>>>bminer, Contributor


@TheAlphaNerd - Good point.  I should probably upgrade to latest 4.x.  Just ignore me.  :)


